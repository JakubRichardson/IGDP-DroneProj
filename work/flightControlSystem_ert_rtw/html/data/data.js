var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"flightControlSystem","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.51\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov 13 17:46:32 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"flightControlSystem.h\"\r\n#include \"rtwtypes.h\"\r\n#include <ext_work.h>\r\n#include <ext_svr.h>\r\n#include <ext_share.h>\r\n#include <updown.h>\r\n#include \"rt_logging.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n#ifndef SAVEFILE\r\n#define MATFILE2(file)                 #file \".mat\"\r\n#define MATFILE1(file)                 MATFILE2(file)\r\n#define MATFILE                        MATFILE1(MODEL)\r\n#else\r\n#define QUOTE1(name)                   #name\r\n#define QUOTE(name)                    QUOTE1(name)              /* need to expand name */\r\n#define MATFILE                        QUOTE(SAVEFILE)\r\n#endif\r\n\r\nvolatile int IsrOverrun = 0;\r\nboolean_T isRateRunning[2] = { 0, 0 };\r\n\r\nboolean_T need2runFlags[2] = { 0, 0 };\r\n\r\nvoid rt_OneStep(void)\r\n{\r\n  boolean_T eventFlags[2];\r\n\r\n  /* Check base rate for overrun */\r\n  if (isRateRunning[0]++) {\r\n    IsrOverrun = 1;\r\n    isRateRunning[0]--;                /* allow future iterations to succeed*/\r\n    return;\r\n  }\r\n\r\n  /*\r\n   * For a bare-board target (i.e., no operating system), the rates\r\n   * that execute this base step are buffered locally to allow for\r\n   * overlapping preemption.\r\n   */\r\n  flightControlSystem_SetEventsForThisBaseStep(eventFlags);\r\n  flightControlSystem_step0();\r\n\r\n  /* Get model outputs here */\r\n  isRateRunning[0]--;\r\n  if (eventFlags[1]) {\r\n    if (need2runFlags[1]++) {\r\n      IsrOverrun = 1;\r\n      need2runFlags[1]--;              /* allow future iterations to succeed*/\r\n      return;\r\n    }\r\n  }\r\n\r\n  if (need2runFlags[1]) {\r\n    if (isRateRunning[1]) {\r\n      /* Yield to higher priority*/\r\n      return;\r\n    }\r\n\r\n    isRateRunning[1]++;\r\n\r\n    /* Step the model for subrate \"1\" */\r\n    switch (1)\r\n    {\r\n     case 1 :\r\n      flightControlSystem_step1();\r\n\r\n      /* Get model outputs here */\r\n      break;\r\n\r\n     default :\r\n      break;\r\n    }\r\n\r\n    need2runFlags[1]--;\r\n    isRateRunning[1]--;\r\n  }\r\n\r\n  rtExtModeCheckEndTrigger();\r\n}\r\n\r\n#define UNUSED(x)                      x = x\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 0.005;\r\n  float systemClock = 416;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  UNUSED(modelBaseRate);\r\n  UNUSED(systemClock);\r\n  rtmSetErrorStatus(flightControlSystem_M, 0);\r\n\r\n  /* initialize external mode */\r\n  rtParseArgsForExtMode(0, NULL);\r\n  flightControlSystem_initialize();\r\n  ;\r\n  ;\r\n\r\n  /* External mode */\r\n  rtSetTFinalForExtMode(&rtmGetTFinal(flightControlSystem_M));\r\n  rtExtModeCheckInit(2);\r\n\r\n  {\r\n    boolean_T rtmStopReq = false;\r\n    rtExtModeWaitForStartPkt(flightControlSystem_M->extModeInfo, 2, &rtmStopReq);\r\n    if (rtmStopReq) {\r\n      rtmSetStopRequested(flightControlSystem_M, true);\r\n    }\r\n  }\r\n\r\n  rtERTExtModeStartMsg();\r\n  ;\r\n  runModel = (rtmGetErrorStatus(flightControlSystem_M) == (NULL)) &&\r\n    !rtmGetStopRequested(flightControlSystem_M);\r\n  ;\r\n  while (runModel) {\r\n    /* External mode */\r\n    {\r\n      boolean_T rtmStopReq = false;\r\n      rtExtModeOneStep(flightControlSystem_M->extModeInfo, 2, &rtmStopReq);\r\n      if (rtmStopReq) {\r\n        rtmSetStopRequested(flightControlSystem_M, true);\r\n      }\r\n    }\r\n\r\n    rt_OneStep();\r\n    stopRequested = !((rtmGetErrorStatus(flightControlSystem_M) == (NULL)) &&\r\n                      !rtmGetStopRequested(flightControlSystem_M));\r\n    runModel = !(stopRequested);\r\n  }\r\n\r\n  rt_StopDataLogging(MATFILE, flightControlSystem_M->rtwLogInfo);\r\n\r\n  /* Terminate model */\r\n  flightControlSystem_terminate();\r\n\r\n  /* External mode shutdown */\r\n  rtExtModeShutdown(2);\r\n  ;\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem.c","type":"source","group":"model","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: flightControlSystem.c\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.51\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov 13 17:46:32 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"flightControlSystem.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"flightControlSystem_types.h\"\r\n#include \"flightControlSystem_private.h\"\r\n#include <math.h>\r\n#include \"rt_roundd_snf.h\"\r\n#include <string.h>\r\n#include \"mean_0sSgOgPG.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"flightControlSystem_dt.h\"\r\n#define flightController_MDLREF_HIDE_CHILD_\r\n#include \"flightController.h\"\r\n#define stateEstimator_MDLREF_HIDE_CHILD_\r\n#include \"stateEstimator.h\"\r\n\r\n/* Named constants for Chart: '<S5>/Chart' */\r\n#define flightControlSystem_IN_A3      (1U)\r\n#define flightControlSystem_IN_A4      (2U)\r\n#define flightControlSystem_IN_CloseGrabber (1U)\r\n#define flightControlSystem_IN_FollowPath (2U)\r\n#define flightControlSystem_IN_Hover   (3U)\r\n#define flightControlSystem_IN_Land    (4U)\r\n#define flightControlSystem_IN_NO_ACTIVE_CHILD ((uint8_T)0U)\r\n#define flightControlSystem_IN_Takeoff (5U)\r\n\r\n/* Named constants for Chart: '<S5>/Chart1' */\r\n#define flightControlSystem_IN_A       (1U)\r\n#define flightControlSystem_IN_Start   (2U)\r\n\r\n/* Named constants for Chart: '<S5>/Chart2' */\r\n#define flightControlSystem_IN_Forward (1U)\r\n#define flightControlSystem_IN_Forward1 (2U)\r\n#define flightControlSystem_IN_Land_d  (3U)\r\n#define flightControlSystem_IN_Left    (4U)\r\n#define flightControlSystem_IN_Right   (5U)\r\n\r\n/* Named constants for Chart: '<S5>/Chart3' */\r\n#define flightControlSystem_IN_Left_f  (3U)\r\n\r\n/* Exported block signals */\r\nCommandBus cmd_inport;                 /* '<Root>/AC cmd' */\r\nSensorsBus sensor_inport;              /* '<Root>/Sensors' */\r\nreal32_T motors_outport[4];            /* '<S1>/controller' */\r\nuint8_T flag_outport;                  /* '<S3>/Merge' */\r\n\r\n/* Block signals (default storage) */\r\nB_flightControlSystem_T flightControlSystem_B;\r\n\r\n/* Block states (default storage) */\r\nDW_flightControlSystem_T flightControlSystem_DW;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_flightControlSystem_T flightControlSystem_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_flightControlSystem_T flightControlSystem_M_;\r\nRT_MODEL_flightControlSystem_T *const flightControlSystem_M =\r\n  &flightControlSystem_M_;\r\nstatic void rate_monotonic_scheduler(void);\r\n\r\n/*\r\n * Set which subrates need to run this base step (base rate always runs).\r\n * This function must be called prior to calling the model step function\r\n * in order to remember which rates need to run this base step.  The\r\n * buffering of events allows for overlapping preemption.\r\n */\r\nvoid flightControlSystem_SetEventsForThisBaseStep(boolean_T *eventFlags)\r\n{\r\n  /* Task runs when its counter is zero, computed via rtmStepTask macro */\r\n  eventFlags[1] = ((boolean_T)rtmStepTask(flightControlSystem_M, 1));\r\n}\r\n\r\n/*\r\n *         This function updates active task flag for each subrate\r\n *         and rate transition flags for tasks that exchange data.\r\n *         The function assumes rate-monotonic multitasking scheduler.\r\n *         The function must be called at model base rate so that\r\n *         the generated code self-manages all its subrates and rate\r\n *         transition flags.\r\n */\r\nstatic void rate_monotonic_scheduler(void)\r\n{\r\n  /* Compute which subrates run during the next base time step.  Subrates\r\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\r\n   * counter is reset when it reaches its limit (zero means run).\r\n   */\r\n  (flightControlSystem_M->Timing.TaskCounters.TID[1])++;\r\n  if ((flightControlSystem_M->Timing.TaskCounters.TID[1]) > 39) {/* Sample time: [0.2s, 0.0s] */\r\n    flightControlSystem_M->Timing.TaskCounters.TID[1] = 0;\r\n  }\r\n}\r\n\r\n/*\r\n * Output and update for action system:\r\n *    '<S3>/Geofencing error'\r\n *    '<S3>/estimator//Optical flow error'\r\n *    '<S3>/Normal condition'\r\n */\r\nvoid flightControlSystem_Geofencingerror(uint8_T *rty_Out1,\r\n  P_Geofencingerror_flightControlSystem_T *localP)\r\n{\r\n  /* SignalConversion generated from: '<S13>/Out1' incorporates:\r\n   *  Constant: '<S13>/Constant'\r\n   */\r\n  *rty_Out1 = localP->Constant_Value;\r\n}\r\n\r\n/* System initialize for atomic system: '<S1>/Logging' */\r\nvoid flightControlSystem_Logging_Init(RT_MODEL_flightControlSystem_T * const\r\n  flightControlSystem_M, DW_Logging_flightControlSystem_T *localDW)\r\n{\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace2' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 12 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 12 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace2\";\r\n    localDW->ToWorkspace2_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"estim\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace2_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace6' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 10 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 10 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace6\";\r\n    localDW->ToWorkspace6_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"sensor\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace6_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace3' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 9 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 9 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace3\";\r\n    localDW->ToWorkspace3_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"cmd\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace3_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace4' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 8 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 8 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace4\";\r\n    localDW->ToWorkspace4_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"optical\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace4_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace5' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 8 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 8 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"SensorCalibration\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace5\";\r\n    localDW->ToWorkspace5_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"calib\",\r\n      1,\r\n      0,\r\n      100,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace5_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 4 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 4 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace\";\r\n    localDW->ToWorkspace_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"motor\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n\r\n  /* SetupRuntimeResources for ToWorkspace: '<S4>/To Workspace1' */\r\n  {\r\n    static int_T rt_ToWksWidths[] = { 8 };\r\n\r\n    static int_T rt_ToWksNumDimensions[] = { 1 };\r\n\r\n    static int_T rt_ToWksDimensions[] = { 8 };\r\n\r\n    static boolean_T rt_ToWksIsVarDims[] = { 0 };\r\n\r\n    static void *rt_ToWksCurrSigDims[] = { (NULL) };\r\n\r\n    static int_T rt_ToWksCurrSigDimsSize[] = { 4 };\r\n\r\n    static BuiltInDTypeId rt_ToWksDataTypeIds[] = { SS_SINGLE };\r\n\r\n    static int_T rt_ToWksComplexSignals[] = { 0 };\r\n\r\n    static int_T rt_ToWksFrameData[] = { 0 };\r\n\r\n    static RTWPreprocessingFcnPtr rt_ToWksLoggingPreprocessingFcnPtrs[] = {\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T *rt_ToWksLabels[] = { \"\" };\r\n\r\n    static RTWLogSignalInfo rt_ToWksSignalInfo = {\r\n      1,\r\n      rt_ToWksWidths,\r\n      rt_ToWksNumDimensions,\r\n      rt_ToWksDimensions,\r\n      rt_ToWksIsVarDims,\r\n      rt_ToWksCurrSigDims,\r\n      rt_ToWksCurrSigDimsSize,\r\n      rt_ToWksDataTypeIds,\r\n      rt_ToWksComplexSignals,\r\n      rt_ToWksFrameData,\r\n      rt_ToWksLoggingPreprocessingFcnPtrs,\r\n\r\n      { rt_ToWksLabels },\r\n      (NULL),\r\n      (NULL),\r\n      (NULL),\r\n\r\n      { (NULL) },\r\n\r\n      { (NULL) },\r\n      (NULL),\r\n      (NULL)\r\n    };\r\n\r\n    static const char_T rt_ToWksBlockName[] =\r\n      \"flightControlSystem/Flight Control System/Logging/To Workspace1\";\r\n    localDW->ToWorkspace1_PWORK.LoggedData = rt_CreateStructLogVar(\r\n      flightControlSystem_M->rtwLogInfo,\r\n      0.0,\r\n      rtmGetTFinal(flightControlSystem_M),\r\n      flightControlSystem_M->Timing.stepSize0,\r\n      (&rtmGetErrorStatus(flightControlSystem_M)),\r\n      \"posref\",\r\n      1,\r\n      0,\r\n      1,\r\n      0.005,\r\n      &rt_ToWksSignalInfo,\r\n      rt_ToWksBlockName);\r\n    if (localDW->ToWorkspace1_PWORK.LoggedData == (NULL))\r\n      return;\r\n  }\r\n}\r\n\r\n/* Output and update for atomic system: '<S1>/Logging' */\r\nvoid flightControlSystem_Logging(RT_MODEL_flightControlSystem_T * const\r\n  flightControlSystem_M, const real32_T rtu_motorCmds[4], const real32_T\r\n  rtu_posRef[8], const statesEstim_t *rtu_states_estim_Inport_3, const\r\n  CommandBus *rtu_ReferenceValueServerBus_Inport_4, const SensorsBus\r\n  *rtu_Sensors_Inport_5, real32_T rtu_sensordata_datin_Inport_6, uint32_T\r\n  rtu_sensordata_datin_Inport_6_d, real32_T rtu_sensordata_datin_Inport_6_e,\r\n  real32_T rtu_sensordata_datin_Inport_6_c, real32_T\r\n  rtu_sensordata_datin_Inport_6_cg, real32_T rtu_sensordata_datin_Inport_6_i,\r\n  real32_T rtu_sensordata_datin_Inport_6_h, real32_T\r\n  rtu_sensordata_datin_Inport_6_b, real32_T rtu_sensordata_datin_Inport_6_dz,\r\n  real32_T rtu_sensordata_datin_Inport_6_n, B_Logging_flightControlSystem_T\r\n  *localB, DW_Logging_flightControlSystem_T *localDW)\r\n{\r\n  int32_T i;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->X = rtu_states_estim_Inport_3->X;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->Y = rtu_states_estim_Inport_3->Y;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->Z = rtu_states_estim_Inport_3->Z;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->yaw = rtu_states_estim_Inport_3->yaw;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->pitch = rtu_states_estim_Inport_3->pitch;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->roll = rtu_states_estim_Inport_3->roll;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->dx = rtu_states_estim_Inport_3->dx;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->dy = rtu_states_estim_Inport_3->dy;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->dz = rtu_states_estim_Inport_3->dz;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->p = rtu_states_estim_Inport_3->p;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->q = rtu_states_estim_Inport_3->q;\r\n\r\n  /* SignalConversion generated from: '<S4>/states_estim_BusSelector' */\r\n  localB->r = rtu_states_estim_Inport_3->r;\r\n\r\n  /* SignalConversion generated from: '<S4>/To Workspace2' */\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[0] = localB->X;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[1] = localB->Y;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[2] = localB->Z;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[3] = localB->yaw;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[4] = localB->pitch;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[5] = localB->roll;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[6] = localB->dx;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[7] = localB->dy;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[8] = localB->dz;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[9] = localB->p;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[10] = localB->q;\r\n  localB->TmpSignalConversionAtToWorkspace2Inport1[11] = localB->r;\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace2' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace2_PWORK.LoggedData,\r\n                          &locTime,\r\n                          &localB->TmpSignalConversionAtToWorkspace2Inport1[0]);\r\n  }\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion1' */\r\n  localB->DataTypeConversion1 = rtu_sensordata_datin_Inport_6;\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion2' */\r\n  localB->DataTypeConversion2 = (real32_T)rtu_sensordata_datin_Inport_6_d;\r\n\r\n  /* SignalConversion generated from: '<S4>/To Workspace6' */\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[0] =\r\n    rtu_sensordata_datin_Inport_6_e;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[1] =\r\n    rtu_sensordata_datin_Inport_6_c;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[2] =\r\n    rtu_sensordata_datin_Inport_6_cg;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[3] =\r\n    rtu_sensordata_datin_Inport_6_i;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[4] =\r\n    rtu_sensordata_datin_Inport_6_h;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[5] =\r\n    rtu_sensordata_datin_Inport_6_b;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[6] =\r\n    rtu_sensordata_datin_Inport_6_dz;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[7] =\r\n    rtu_sensordata_datin_Inport_6_n;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[8] =\r\n    localB->DataTypeConversion1;\r\n  localB->TmpSignalConversionAtToWorkspace6Inport1[9] =\r\n    localB->DataTypeConversion2;\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace6' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace6_PWORK.LoggedData,\r\n                          &locTime,\r\n                          &localB->TmpSignalConversionAtToWorkspace6Inport1[0]);\r\n  }\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion3' */\r\n  localB->DataTypeConversion3 =\r\n    rtu_ReferenceValueServerBus_Inport_4->controlModePosVSOrient;\r\n\r\n  /* SignalConversion generated from: '<S4>/ReferenceValueServerBus_BusSelector' */\r\n  localB->pos_ref[0] = rtu_ReferenceValueServerBus_Inport_4->pos_ref[0];\r\n  localB->pos_ref[1] = rtu_ReferenceValueServerBus_Inport_4->pos_ref[1];\r\n  localB->pos_ref[2] = rtu_ReferenceValueServerBus_Inport_4->pos_ref[2];\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion7' */\r\n  localB->DataTypeConversion7 =\r\n    rtu_ReferenceValueServerBus_Inport_4->takeoff_flag;\r\n\r\n  /* SignalConversion generated from: '<S4>/ReferenceValueServerBus_BusSelector' */\r\n  localB->orient_ref[0] = rtu_ReferenceValueServerBus_Inport_4->orient_ref[0];\r\n  localB->orient_ref[1] = rtu_ReferenceValueServerBus_Inport_4->orient_ref[1];\r\n  localB->orient_ref[2] = rtu_ReferenceValueServerBus_Inport_4->orient_ref[2];\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion9' */\r\n  localB->DataTypeConversion9 = (real32_T)\r\n    rtu_ReferenceValueServerBus_Inport_4->live_time_ticks;\r\n\r\n  /* SignalConversion generated from: '<S4>/To Workspace3' */\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[0] =\r\n    localB->DataTypeConversion3;\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[1] = localB->pos_ref[0];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[2] = localB->pos_ref[1];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[3] = localB->pos_ref[2];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[4] =\r\n    localB->DataTypeConversion7;\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[5] = localB->orient_ref[0];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[6] = localB->orient_ref[1];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[7] = localB->orient_ref[2];\r\n  localB->TmpSignalConversionAtToWorkspace3Inport1[8] =\r\n    localB->DataTypeConversion9;\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace3' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace3_PWORK.LoggedData,\r\n                          &locTime,\r\n                          &localB->TmpSignalConversionAtToWorkspace3Inport1[0]);\r\n  }\r\n\r\n  /* DataTypeConversion: '<S4>/Data Type Conversion11' */\r\n  localB->DataTypeConversion11 =\r\n    rtu_Sensors_Inport_5->VisionSensors.usePosVIS_flag;\r\n\r\n  /* SignalConversion generated from: '<S4>/Sensors_BusSelector' */\r\n  localB->opticalFlow_data[0] =\r\n    rtu_Sensors_Inport_5->VisionSensors.opticalFlow_data[0];\r\n  localB->opticalFlow_data[1] =\r\n    rtu_Sensors_Inport_5->VisionSensors.opticalFlow_data[1];\r\n  localB->opticalFlow_data[2] =\r\n    rtu_Sensors_Inport_5->VisionSensors.opticalFlow_data[2];\r\n\r\n  /* SignalConversion generated from: '<S4>/Sensors_BusSelector' */\r\n  localB->posVIS_data[0] = rtu_Sensors_Inport_5->VisionSensors.posVIS_data[0];\r\n  localB->posVIS_data[1] = rtu_Sensors_Inport_5->VisionSensors.posVIS_data[1];\r\n  localB->posVIS_data[2] = rtu_Sensors_Inport_5->VisionSensors.posVIS_data[2];\r\n  localB->posVIS_data[3] = rtu_Sensors_Inport_5->VisionSensors.posVIS_data[3];\r\n\r\n  /* SignalConversion generated from: '<S4>/To Workspace4' */\r\n  localB->TmpSignalConversionAtToWorkspace4Inport1[0] =\r\n    localB->DataTypeConversion11;\r\n  localB->TmpSignalConversionAtToWorkspace4Inport1[1] = localB->\r\n    opticalFlow_data[0];\r\n  localB->TmpSignalConversionAtToWorkspace4Inport1[2] = localB->\r\n    opticalFlow_data[1];\r\n  localB->TmpSignalConversionAtToWorkspace4Inport1[3] = localB->\r\n    opticalFlow_data[2];\r\n  localB->TmpSignalConversionAtToWorkspace4Inport1[4] = localB->posVIS_data[0];\r\n  localB->TmpSignalConversionAtToWorkspace4Inport1[5] = localB->posVIS_data[1];\r\n  localB->TmpSignalConversionAtToWorkspace4Inport1[6] = localB->posVIS_data[2];\r\n  localB->TmpSignalConversionAtToWorkspace4Inport1[7] = localB->posVIS_data[3];\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace4' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace4_PWORK.LoggedData,\r\n                          &locTime,\r\n                          &localB->TmpSignalConversionAtToWorkspace4Inport1[0]);\r\n  }\r\n\r\n  for (i = 0; i < 8; i++) {\r\n    /* SignalConversion generated from: '<S4>/Sensors_BusSelector' */\r\n    localB->SensorCalibration[i] = rtu_Sensors_Inport_5->SensorCalibration[i];\r\n  }\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace5' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace5_PWORK.LoggedData,\r\n                          &locTime, &localB->SensorCalibration[0]);\r\n  }\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace_PWORK.LoggedData,\r\n                          &locTime, &rtu_motorCmds[0]);\r\n  }\r\n\r\n  /* ToWorkspace: '<S4>/To Workspace1' */\r\n  {\r\n    double locTime = flightControlSystem_M->Timing.taskTime0\r\n      ;\r\n    rt_UpdateStructLogVar((StructLogVar *)localDW->ToWorkspace1_PWORK.LoggedData,\r\n                          &locTime, &rtu_posRef[0]);\r\n  }\r\n}\r\n\r\n/* System initialize for atomic system: '<Root>/Flight Control System' */\r\nvoid flightControlSystem_FlightControlSystem_Init(RT_MODEL_flightControlSystem_T\r\n  * const flightControlSystem_M, uint8_T *rty_Flag,\r\n  DW_FlightControlSystem_flightControlSystem_T *localDW,\r\n  P_FlightControlSystem_flightControlSystem_T *localP)\r\n{\r\n  /* SystemInitialize for Atomic SubSystem: '<S1>/Logging' */\r\n  flightControlSystem_Logging_Init(flightControlSystem_M, &localDW->Logging);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<S1>/Logging' */\r\n\r\n  /* SystemInitialize for Merge: '<S3>/Merge' */\r\n  *rty_Flag = localP->Merge_InitialOutput;\r\n\r\n  /* SystemInitialize for ModelReference: '<S1>/controller' */\r\n  flightController_Init();\r\n\r\n  /* SystemInitialize for ModelReference: '<S1>/estimator' */\r\n  stateEstimator_Init();\r\n}\r\n\r\n/* Output and update for atomic system: '<Root>/Flight Control System' */\r\nvoid flightControlSystem_FlightControlSystem(RT_MODEL_flightControlSystem_T *\r\n  const flightControlSystem_M, const CommandBus *rtu_ReferenceValueServerCmds,\r\n  const SensorsBus *rtu_Sensors_Inport_2, real_T rtu_VisionbasedData, real_T\r\n  rtu_VisionbasedData_p, real32_T rty_motorCmds[4], uint8_T *rty_Flag,\r\n  B_FlightControlSystem_flightControlSystem_T *localB,\r\n  DW_FlightControlSystem_flightControlSystem_T *localDW,\r\n  P_FlightControlSystem_flightControlSystem_T *localP)\r\n{\r\n  /* Chart: '<S5>/Chart' */\r\n  if (localDW->temporalCounter_i1_g < 4095U) {\r\n    localDW->temporalCounter_i1_g++;\r\n  }\r\n\r\n  if (localDW->temporalCounter_i2 < 511U) {\r\n    localDW->temporalCounter_i2++;\r\n  }\r\n\r\n  if (localDW->is_active_c3_flightControlSystem == 0U) {\r\n    localDW->is_active_c3_flightControlSystem = 1U;\r\n    localB->x_g = 0.0;\r\n    localB->y_b = 0.0;\r\n    localB->z_g = -1.0;\r\n    localB->grabber_c = 1.0;\r\n    localDW->is_c3_flightControlSystem = flightControlSystem_IN_Takeoff;\r\n    localDW->temporalCounter_i2 = 0U;\r\n    localDW->is_Takeoff = flightControlSystem_IN_A3;\r\n    localDW->temporalCounter_i1_g = 0U;\r\n    localB->takeoff_flag = 1.0;\r\n  } else {\r\n    switch (localDW->is_c3_flightControlSystem) {\r\n     case flightControlSystem_IN_CloseGrabber:\r\n      if (localDW->temporalCounter_i1_g >= 200U) {\r\n        localDW->is_c3_flightControlSystem = flightControlSystem_IN_Takeoff;\r\n        localDW->temporalCounter_i2 = 0U;\r\n        localDW->is_Takeoff = flightControlSystem_IN_A3;\r\n        localDW->temporalCounter_i1_g = 0U;\r\n        localB->takeoff_flag = 1.0;\r\n      }\r\n      break;\r\n\r\n     case flightControlSystem_IN_FollowPath:\r\n      if (localDW->temporalCounter_i1_g >= 4000U) {\r\n        localDW->is_c3_flightControlSystem = flightControlSystem_IN_Land;\r\n        localB->z_g = -0.4;\r\n      } else {\r\n        localB->x_g -= rtu_VisionbasedData / 50000.0;\r\n        localB->y_b += rtu_VisionbasedData_p / 50000.0;\r\n      }\r\n      break;\r\n\r\n     case flightControlSystem_IN_Hover:\r\n      if (localDW->temporalCounter_i1_g >= 400U) {\r\n        localDW->is_c3_flightControlSystem = flightControlSystem_IN_FollowPath;\r\n        localDW->temporalCounter_i1_g = 0U;\r\n      }\r\n      break;\r\n\r\n     case flightControlSystem_IN_Land:\r\n      break;\r\n\r\n     default:\r\n      /* case IN_Takeoff: */\r\n      if (localDW->temporalCounter_i2 >= 400U) {\r\n        localDW->is_Takeoff = flightControlSystem_IN_NO_ACTIVE_CHILD;\r\n        localDW->is_c3_flightControlSystem = flightControlSystem_IN_Hover;\r\n        localDW->temporalCounter_i1_g = 0U;\r\n        localB->z_g = -1.0;\r\n      } else if ((localDW->is_Takeoff == flightControlSystem_IN_A3) &&\r\n                 (localDW->temporalCounter_i1_g >= 160U)) {\r\n        localDW->is_Takeoff = flightControlSystem_IN_A4;\r\n        localB->takeoff_flag = 0.0;\r\n      } else {\r\n        /* case IN_A4: */\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S5>/Chart' */\r\n\r\n  /* BusCreator: '<S5>/Bus Creator' incorporates:\r\n   *  Constant: '<S5>/Constant1'\r\n   *  Constant: '<S5>/Constant3'\r\n   *  DataTypeConversion: '<S5>/Cast To Boolean'\r\n   *  DataTypeConversion: '<S5>/Cast To Single'\r\n   */\r\n  localB->BusCreator.controlModePosVSOrient = localP->Constant1_Value;\r\n  localB->BusCreator.pos_ref[0] = (real32_T)localB->x_g;\r\n  localB->BusCreator.pos_ref[1] = (real32_T)localB->y_b;\r\n  localB->BusCreator.pos_ref[2] = (real32_T)localB->z_g;\r\n  localB->BusCreator.takeoff_flag = (localB->takeoff_flag != 0.0);\r\n  localB->BusCreator.orient_ref[0] = localP->Constant3_Value[0];\r\n  localB->BusCreator.orient_ref[1] = localP->Constant3_Value[1];\r\n  localB->BusCreator.orient_ref[2] = localP->Constant3_Value[2];\r\n  localB->BusCreator.live_time_ticks =\r\n    rtu_ReferenceValueServerCmds->live_time_ticks;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector3' */\r\n  localB->x_c = rtu_Sensors_Inport_2->HALSensors.HAL_acc_SI.x;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector3' */\r\n  localB->y_n = rtu_Sensors_Inport_2->HALSensors.HAL_acc_SI.y;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector3' */\r\n  localB->z_p = rtu_Sensors_Inport_2->HALSensors.HAL_acc_SI.z;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector4' */\r\n  localB->x_cd = rtu_Sensors_Inport_2->HALSensors.HAL_gyro_SI.x;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector4' */\r\n  localB->y_nb = rtu_Sensors_Inport_2->HALSensors.HAL_gyro_SI.y;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector4' */\r\n  localB->z_p1 = rtu_Sensors_Inport_2->HALSensors.HAL_gyro_SI.z;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector5' */\r\n  localB->altitude = rtu_Sensors_Inport_2->HALSensors.HAL_ultrasound_SI.altitude;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector6' */\r\n  localB->pressure = rtu_Sensors_Inport_2->HALSensors.HAL_pressure_SI.pressure;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector1' */\r\n  localB->rtb_vbat_V_m = rtu_Sensors_Inport_2->HALSensors.HAL_vbat_SI.vbat_V;\r\n\r\n  /* SignalConversion generated from: '<S6>/Bus Selector1' */\r\n  localB->rtb_vbat_percentage_c =\r\n    rtu_Sensors_Inport_2->HALSensors.HAL_vbat_SI.vbat_percentage;\r\n\r\n  /* BusCreator generated from: '<S1>/estimator' */\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.ddx =\r\n    localB->x_c;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.ddy =\r\n    localB->y_n;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.ddz =\r\n    localB->z_p;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.p =\r\n    localB->x_cd;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.q =\r\n    localB->y_nb;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.r =\r\n    localB->z_p1;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.altitude_sonar\r\n    = localB->altitude;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.prs =\r\n    localB->pressure;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.vbat_V =\r\n    localB->rtb_vbat_V_m;\r\n  localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1.vbat_percentage\r\n    = localB->rtb_vbat_percentage_c;\r\n\r\n  /* ModelReference: '<S1>/estimator' incorporates:\r\n   *  Constant: '<S5>/Constant1'\r\n   */\r\n  stateEstimator_run(localP->Constant1_Value,\r\n                     &localB->BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1,\r\n                     rtu_Sensors_Inport_2->VisionSensors.usePosVIS_flag,\r\n                     &rtu_Sensors_Inport_2->VisionSensors.opticalFlow_data[0],\r\n                     &rtu_Sensors_Inport_2->VisionSensors.posVIS_data[0],\r\n                     &localB->estimator,\r\n                     &rtu_Sensors_Inport_2->SensorCalibration[0]);\r\n\r\n  /* ModelReference: '<S1>/controller' */\r\n  flightController_run(&localB->BusCreator, &localB->estimator, &rty_motorCmds[0],\r\n                       &localB->controller_o2[0]);\r\n\r\n  /* Outputs for Atomic SubSystem: '<S1>/Logging' */\r\n  flightControlSystem_Logging(flightControlSystem_M, rty_motorCmds,\r\n    localB->controller_o2, &localB->estimator, rtu_ReferenceValueServerCmds,\r\n    rtu_Sensors_Inport_2, localB->rtb_vbat_V_m, localB->rtb_vbat_percentage_c,\r\n    localB->x_c, localB->y_n, localB->z_p, localB->x_cd, localB->y_nb,\r\n    localB->z_p1, localB->altitude, localB->pressure, &localB->Logging,\r\n    &localDW->Logging);\r\n\r\n  /* End of Outputs for SubSystem: '<S1>/Logging' */\r\n\r\n  /* Abs: '<S3>/Abs2' */\r\n  localB->Max = (real32_T)fabs\r\n    (rtu_Sensors_Inport_2->VisionSensors.opticalFlow_data[0]);\r\n\r\n  /* RelationalOperator: '<S9>/Compare' incorporates:\r\n   *  Constant: '<S9>/Constant'\r\n   */\r\n  localB->Compare_h = (localB->Max > localP->CompareToConstant2_const);\r\n\r\n  /* Gain: '<S3>/Gain2' */\r\n  localB->Max = localP->Gain2_Gain *\r\n    rtu_Sensors_Inport_2->VisionSensors.opticalFlow_data[0];\r\n\r\n  /* RelationalOperator: '<S12>/Compare' incorporates:\r\n   *  Abs: '<S3>/Abs6'\r\n   *  Constant: '<S12>/Constant'\r\n   *  Sum: '<S3>/Add1'\r\n   */\r\n  localB->Compare_l = ((real32_T)fabs(localB->Max - localB->estimator.dx) >\r\n                       localP->CompareToConstant6_const);\r\n\r\n  /* Gain: '<S3>/Gain1' */\r\n  localB->Max = localP->Gain1_Gain *\r\n    rtu_Sensors_Inport_2->VisionSensors.opticalFlow_data[1];\r\n\r\n  /* RelationalOperator: '<S10>/Compare' incorporates:\r\n   *  Abs: '<S3>/Abs3'\r\n   *  Constant: '<S10>/Constant'\r\n   *  Sum: '<S3>/Add'\r\n   */\r\n  localB->Compare_mb = ((real32_T)fabs(localB->Max - localB->estimator.dy) >\r\n                        localP->CompareToConstant3_const);\r\n\r\n  /* Abs: '<S3>/Abs5' */\r\n  localB->Max = (real32_T)fabs\r\n    (rtu_Sensors_Inport_2->VisionSensors.opticalFlow_data[1]);\r\n\r\n  /* If: '<S3>/If' incorporates:\r\n   *  Abs: '<S3>/Abs'\r\n   *  Abs: '<S3>/Abs1'\r\n   *  Constant: '<S11>/Constant'\r\n   *  Constant: '<S7>/Constant'\r\n   *  Constant: '<S8>/Constant'\r\n   *  Logic: '<S3>/Logical Operator'\r\n   *  Logic: '<S3>/Logical Operator1'\r\n   *  Logic: '<S3>/Logical Operator2'\r\n   *  Logic: '<S3>/Logical Operator3'\r\n   *  RelationalOperator: '<S11>/Compare'\r\n   *  RelationalOperator: '<S7>/Compare'\r\n   *  RelationalOperator: '<S8>/Compare'\r\n   */\r\n  if (((real32_T)fabs(localB->estimator.X) > localP->CompareToConstant_const) ||\r\n      ((real32_T)fabs(localB->estimator.Y) > localP->CompareToConstant1_const))\r\n  {\r\n    /* Outputs for IfAction SubSystem: '<S3>/Geofencing error' incorporates:\r\n     *  ActionPort: '<S13>/Action Port'\r\n     */\r\n    flightControlSystem_Geofencingerror(rty_Flag, &localP->Geofencingerror);\r\n\r\n    /* End of Outputs for SubSystem: '<S3>/Geofencing error' */\r\n  } else if ((localB->Compare_h && localB->Compare_l) || (localB->Compare_mb &&\r\n              (localB->Max > localP->CompareToConstant5_const))) {\r\n    /* Outputs for IfAction SubSystem: '<S3>/estimator//Optical flow error' incorporates:\r\n     *  ActionPort: '<S15>/Action Port'\r\n     */\r\n    flightControlSystem_Geofencingerror(rty_Flag,\r\n      &localP->estimatorOpticalflowerror);\r\n\r\n    /* End of Outputs for SubSystem: '<S3>/estimator//Optical flow error' */\r\n  } else {\r\n    /* Outputs for IfAction SubSystem: '<S3>/Normal condition' incorporates:\r\n     *  ActionPort: '<S14>/Action Port'\r\n     */\r\n    flightControlSystem_Geofencingerror(rty_Flag, &localP->Normalcondition);\r\n\r\n    /* End of Outputs for SubSystem: '<S3>/Normal condition' */\r\n  }\r\n\r\n  /* End of If: '<S3>/If' */\r\n\r\n  /* MATLABSystem: '<S5>/Grabber' */\r\n  localB->d = rt_roundd_snf(localB->grabber_c);\r\n  if (localB->d < 256.0) {\r\n    if (localB->d >= 0.0) {\r\n      localB->u = (uint8_T)localB->d;\r\n    } else {\r\n      localB->u = 0U;\r\n    }\r\n  } else {\r\n    localB->u = MAX_uint8_T;\r\n  }\r\n\r\n  localB->d = MW_PARROT_Grabber(localB->u);\r\n\r\n  /* MATLABSystem: '<S5>/Grabber' */\r\n  localB->Grabber = localB->d;\r\n\r\n  /* Chart: '<S5>/Chart1' */\r\n  if (localDW->temporalCounter_i1_p < 1023U) {\r\n    localDW->temporalCounter_i1_p++;\r\n  }\r\n\r\n  if (localDW->is_active_c1_flightControlSystem == 0U) {\r\n    localDW->is_active_c1_flightControlSystem = 1U;\r\n    localDW->is_c1_flightControlSystem = flightControlSystem_IN_Start;\r\n    localDW->temporalCounter_i1_p = 0U;\r\n  } else {\r\n    switch (localDW->is_c1_flightControlSystem) {\r\n     case flightControlSystem_IN_A:\r\n      break;\r\n\r\n     default:\r\n      /* case IN_Start: */\r\n      if (localDW->temporalCounter_i1_p >= 1000U) {\r\n        localDW->is_c1_flightControlSystem = flightControlSystem_IN_A;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S5>/Chart1' */\r\n\r\n  /* Chart: '<S5>/Chart2' */\r\n  if (localDW->temporalCounter_i1_d < 2047U) {\r\n    localDW->temporalCounter_i1_d++;\r\n  }\r\n\r\n  if (localDW->is_active_c2_flightControlSystem == 0U) {\r\n    localDW->is_active_c2_flightControlSystem = 1U;\r\n    localDW->is_c2_flightControlSystem = flightControlSystem_IN_Forward;\r\n    localDW->temporalCounter_i1_d = 0U;\r\n  } else {\r\n    switch (localDW->is_c2_flightControlSystem) {\r\n     case flightControlSystem_IN_Forward:\r\n      if (localDW->temporalCounter_i1_d >= 1400U) {\r\n        localDW->is_c2_flightControlSystem = flightControlSystem_IN_Forward1;\r\n        localDW->temporalCounter_i1_d = 0U;\r\n      }\r\n      break;\r\n\r\n     case flightControlSystem_IN_Forward1:\r\n      if (localDW->temporalCounter_i1_d >= 1000U) {\r\n        localDW->is_c2_flightControlSystem = flightControlSystem_IN_Left;\r\n        localDW->temporalCounter_i1_d = 0U;\r\n      }\r\n      break;\r\n\r\n     case flightControlSystem_IN_Land_d:\r\n      break;\r\n\r\n     case flightControlSystem_IN_Left:\r\n      if (localDW->temporalCounter_i1_d >= 1000U) {\r\n        localDW->is_c2_flightControlSystem = flightControlSystem_IN_Right;\r\n        localDW->temporalCounter_i1_d = 0U;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_Right: */\r\n      if (localDW->temporalCounter_i1_d >= 1000U) {\r\n        localDW->is_c2_flightControlSystem = flightControlSystem_IN_Land_d;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S5>/Chart2' */\r\n\r\n  /* Chart: '<S5>/Chart3' */\r\n  if (localDW->temporalCounter_i1 < 1023U) {\r\n    localDW->temporalCounter_i1++;\r\n  }\r\n\r\n  if (localDW->is_active_c4_flightControlSystem == 0U) {\r\n    localDW->is_active_c4_flightControlSystem = 1U;\r\n    localDW->is_c4_flightControlSystem = flightControlSystem_IN_Forward;\r\n    localDW->temporalCounter_i1 = 0U;\r\n  } else {\r\n    switch (localDW->is_c4_flightControlSystem) {\r\n     case flightControlSystem_IN_Forward:\r\n      if (localDW->temporalCounter_i1 >= 1000U) {\r\n        localDW->is_c4_flightControlSystem = flightControlSystem_IN_Forward1;\r\n        localDW->temporalCounter_i1 = 0U;\r\n      }\r\n      break;\r\n\r\n     case flightControlSystem_IN_Forward1:\r\n      if (localDW->temporalCounter_i1 >= 1000U) {\r\n        localDW->is_c4_flightControlSystem = flightControlSystem_IN_Left_f;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_Left: */\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S5>/Chart3' */\r\n}\r\n\r\n/* Model step function for TID0 */\r\nvoid flightControlSystem_step0(void)   /* Sample time: [0.005s, 0.0s] */\r\n{\r\n  {                                    /* Sample time: [0.005s, 0.0s] */\r\n    rate_monotonic_scheduler();\r\n  }\r\n\r\n  /* Reset subsysRan breadcrumbs */\r\n  srClearBC\r\n    (flightControlSystem_DW.FlightControlSystem.Geofencingerror.Geofencingerror_SubsysRanBC);\r\n\r\n  /* RateTransition generated from: '<Root>/Rate Transition' */\r\n  flightControlSystem_B.dy =\r\n    flightControlSystem_DW.RateTransition_1_Buffer[flightControlSystem_DW.RateTransition_1_ActiveBufIdx];\r\n\r\n  /* RateTransition generated from: '<Root>/Rate Transition' */\r\n  flightControlSystem_B.dx =\r\n    flightControlSystem_DW.RateTransition_2_Buffer[flightControlSystem_DW.RateTransition_2_ActiveBufIdx];\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/Flight Control System' */\r\n\r\n  /* Inport: '<Root>/AC cmd' incorporates:\r\n   *  Inport: '<Root>/Sensors'\r\n   */\r\n  flightControlSystem_FlightControlSystem(flightControlSystem_M, &cmd_inport,\r\n    &sensor_inport, flightControlSystem_B.dx, flightControlSystem_B.dy,\r\n    motors_outport, &flag_outport, &flightControlSystem_B.FlightControlSystem,\r\n    &flightControlSystem_DW.FlightControlSystem,\r\n    &flightControlSystem_P.FlightControlSystem);\r\n\r\n  /* End of Outputs for SubSystem: '<Root>/Flight Control System' */\r\n\r\n  /* Outport: '<Root>/Actuators' */\r\n  flightControlSystem_Y.Actuators[0] = motors_outport[0];\r\n  flightControlSystem_Y.Actuators[1] = motors_outport[1];\r\n  flightControlSystem_Y.Actuators[2] = motors_outport[2];\r\n  flightControlSystem_Y.Actuators[3] = motors_outport[3];\r\n\r\n  /* Outport: '<Root>/Flag' */\r\n  flightControlSystem_Y.Flag = flag_outport;\r\n\r\n  /* Matfile logging */\r\n  rt_UpdateTXYLogVars(flightControlSystem_M->rtwLogInfo,\r\n                      (&flightControlSystem_M->Timing.taskTime0));\r\n\r\n  /* External mode */\r\n  rtExtModeUploadCheckTrigger(2);\r\n  rtExtModeUpload(0, (real_T)flightControlSystem_M->Timing.taskTime0);\r\n\r\n  /* signal main to stop simulation */\r\n  {                                    /* Sample time: [0.005s, 0.0s] */\r\n    if ((rtmGetTFinal(flightControlSystem_M)!=-1) &&\r\n        !((rtmGetTFinal(flightControlSystem_M)-\r\n           flightControlSystem_M->Timing.taskTime0) >\r\n          flightControlSystem_M->Timing.taskTime0 * (DBL_EPSILON))) {\r\n      rtmSetErrorStatus(flightControlSystem_M, \"Simulation finished\");\r\n    }\r\n\r\n    if (rtmGetStopRequested(flightControlSystem_M)) {\r\n      rtmSetErrorStatus(flightControlSystem_M, \"Simulation finished\");\r\n    }\r\n  }\r\n\r\n  /* Update absolute time */\r\n  /* The \"clockTick0\" counts the number of times the code of this task has\r\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n   * overflow during the application lifespan selected.\r\n   */\r\n  flightControlSystem_M->Timing.taskTime0 =\r\n    ((time_T)(++flightControlSystem_M->Timing.clockTick0)) *\r\n    flightControlSystem_M->Timing.stepSize0;\r\n}\r\n\r\n/* Model step function for TID1 */\r\nvoid flightControlSystem_step1(void)   /* Sample time: [0.2s, 0.0s] */\r\n{\r\n  int32_T colIdx;\r\n  int32_T colIdx_size;\r\n  int32_T loop;\r\n  int32_T rowIdx_size;\r\n  int32_T yIdx;\r\n  boolean_T exitg1;\r\n  boolean_T guard1;\r\n\r\n  /* Outputs for Atomic SubSystem: '<Root>/Image Processing System' */\r\n  /* MATLABSystem: '<S2>/PARROT Image Conversion' incorporates:\r\n   *  Inport: '<Root>/Image Data'\r\n   */\r\n  MW_Build_RGB(&imRGB[0], &flightControlSystem_B.imageBuff_1[0],\r\n               &flightControlSystem_B.imageBuff_2[0],\r\n               &flightControlSystem_B.imageBuff_3[0]);\r\n\r\n  /* MATLAB Function: '<S2>/MATLAB Function' incorporates:\r\n   *  MATLABSystem: '<S2>/PARROT Image Conversion'\r\n   */\r\n  for (colIdx = 0; colIdx < 19200; colIdx++) {\r\n    flightControlSystem_B.BW[colIdx] =\r\n      ((flightControlSystem_B.imageBuff_1[colIdx] >= 80) &&\r\n       (flightControlSystem_B.imageBuff_2[colIdx] <= 100) &&\r\n       (flightControlSystem_B.imageBuff_3[colIdx] <= 80));\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S2>/MATLAB Function' */\r\n\r\n  /* S-Function (sdspsubmtrx): '<S2>/Submatrix' */\r\n  yIdx = 0;\r\n  for (colIdx = 0; colIdx < 160; colIdx++) {\r\n    memcpy(&flightControlSystem_B.Submatrix[yIdx],\r\n           &flightControlSystem_B.BW[colIdx * 120], 120U * sizeof(boolean_T));\r\n    yIdx += 120;\r\n  }\r\n\r\n  /* End of S-Function (sdspsubmtrx): '<S2>/Submatrix' */\r\n\r\n  /* Sum: '<S2>/Matrix Sum2' incorporates:\r\n   *  S-Function (sdspsubmtrx): '<S2>/Submatrix'\r\n   */\r\n  colIdx = 0;\r\n  for (yIdx = 0; yIdx < 19200; yIdx++) {\r\n    colIdx = (int32_T)((uint32_T)colIdx + flightControlSystem_B.Submatrix[yIdx]);\r\n  }\r\n\r\n  /* DataTypeConversion: '<S2>/Cast To Double' incorporates:\r\n   *  Sum: '<S2>/Matrix Sum2'\r\n   */\r\n  flightControlSystem_B.CastToDouble = (uint8_T)colIdx;\r\n\r\n  /* RelationalOperator: '<S20>/Compare' incorporates:\r\n   *  Constant: '<S20>/Constant'\r\n   */\r\n  flightControlSystem_B.Compare = (flightControlSystem_B.CastToDouble >=\r\n    flightControlSystem_P.CompareToConstant2_const);\r\n\r\n  /* MATLAB Function: '<S2>/MATLAB Function1' */\r\n  yIdx = -1;\r\n  colIdx = 1;\r\n  loop = 1;\r\n  exitg1 = false;\r\n  while ((!exitg1) && (loop <= 160)) {\r\n    guard1 = false;\r\n    if (flightControlSystem_B.BW[((loop - 1) * 120 + colIdx) + 13]) {\r\n      yIdx++;\r\n      flightControlSystem_B.i_data[yIdx] = colIdx;\r\n      flightControlSystem_B.j_data[yIdx] = (uint8_T)loop;\r\n      if (yIdx + 1 >= 4960) {\r\n        exitg1 = true;\r\n      } else {\r\n        guard1 = true;\r\n      }\r\n    } else {\r\n      guard1 = true;\r\n    }\r\n\r\n    if (guard1) {\r\n      colIdx++;\r\n      if (colIdx > 31) {\r\n        colIdx = 1;\r\n        loop++;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (yIdx + 1 < 1) {\r\n    loop = -1;\r\n  } else {\r\n    loop = yIdx;\r\n  }\r\n\r\n  rowIdx_size = loop + 1;\r\n  for (colIdx = 0; colIdx <= loop; colIdx++) {\r\n    flightControlSystem_B.rowIdx_data[colIdx] =\r\n      flightControlSystem_B.i_data[colIdx];\r\n  }\r\n\r\n  if (yIdx + 1 < 1) {\r\n    yIdx = -1;\r\n  }\r\n\r\n  colIdx_size = yIdx + 1;\r\n  for (colIdx = 0; colIdx <= yIdx; colIdx++) {\r\n    flightControlSystem_B.colIdx_data[colIdx] =\r\n      flightControlSystem_B.j_data[colIdx];\r\n  }\r\n\r\n  if ((loop + 1 == 0) || (yIdx + 1 == 0)) {\r\n    flightControlSystem_B.avgX = 80.0;\r\n    flightControlSystem_B.avgY = 60.0;\r\n  } else {\r\n    flightControlSystem_B.avgX = mean_0sSgOgPG(flightControlSystem_B.colIdx_data,\r\n      &colIdx_size);\r\n    flightControlSystem_B.avgY = mean_0sSgOgPG(flightControlSystem_B.rowIdx_data,\r\n      &rowIdx_size);\r\n  }\r\n\r\n  flightControlSystem_B.deltaX = flightControlSystem_B.avgX - 80.0;\r\n  flightControlSystem_B.deltaY = flightControlSystem_B.avgY - 60.0;\r\n\r\n  /* End of MATLAB Function: '<S2>/MATLAB Function1' */\r\n  /* RateTransition generated from: '<Root>/Rate Transition' */\r\n  flightControlSystem_DW.RateTransition_1_Buffer[flightControlSystem_DW.RateTransition_1_ActiveBufIdx\r\n    == 0] = flightControlSystem_B.deltaX;\r\n  flightControlSystem_DW.RateTransition_1_ActiveBufIdx = (int8_T)\r\n    (flightControlSystem_DW.RateTransition_1_ActiveBufIdx == 0);\r\n\r\n  /* RateTransition generated from: '<Root>/Rate Transition' */\r\n  flightControlSystem_DW.RateTransition_2_Buffer[flightControlSystem_DW.RateTransition_2_ActiveBufIdx\r\n    == 0] = flightControlSystem_B.deltaY;\r\n  flightControlSystem_DW.RateTransition_2_ActiveBufIdx = (int8_T)\r\n    (flightControlSystem_DW.RateTransition_2_ActiveBufIdx == 0);\r\n  rtExtModeUpload(1, (real_T)((flightControlSystem_M->Timing.clockTick1) * 0.2));\r\n\r\n  /* Update absolute time */\r\n  /* The \"clockTick1\" counts the number of times the code of this task has\r\n   * been executed. The resolution of this integer timer is 0.2, which is the step size\r\n   * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n   * application lifespan selected.\r\n   */\r\n  flightControlSystem_M->Timing.clockTick1++;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid flightControlSystem_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n  rtmSetTFinal(flightControlSystem_M, 30.0);\r\n  flightControlSystem_M->Timing.stepSize0 = 0.005;\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    static RTWLogInfo rt_DataLoggingInfo;\r\n    rt_DataLoggingInfo.loggingInterval = (NULL);\r\n    flightControlSystem_M->rtwLogInfo = &rt_DataLoggingInfo;\r\n  }\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    rtliSetLogXSignalInfo(flightControlSystem_M->rtwLogInfo, (NULL));\r\n    rtliSetLogXSignalPtrs(flightControlSystem_M->rtwLogInfo, (NULL));\r\n    rtliSetLogT(flightControlSystem_M->rtwLogInfo, \"tout\");\r\n    rtliSetLogX(flightControlSystem_M->rtwLogInfo, \"\");\r\n    rtliSetLogXFinal(flightControlSystem_M->rtwLogInfo, \"\");\r\n    rtliSetLogVarNameModifier(flightControlSystem_M->rtwLogInfo, \"rt_\");\r\n    rtliSetLogFormat(flightControlSystem_M->rtwLogInfo, 2);\r\n    rtliSetLogMaxRows(flightControlSystem_M->rtwLogInfo, 1000);\r\n    rtliSetLogDecimation(flightControlSystem_M->rtwLogInfo, 1);\r\n\r\n    /*\r\n     * Set pointers to the data and signal info for each output\r\n     */\r\n    {\r\n      static void * rt_LoggedOutputSignalPtrs[] = {\r\n        &flightControlSystem_Y.Actuators[0],\r\n        &flightControlSystem_Y.Flag\r\n      };\r\n\r\n      rtliSetLogYSignalPtrs(flightControlSystem_M->rtwLogInfo,\r\n                            ((LogSignalPtrsType)rt_LoggedOutputSignalPtrs));\r\n    }\r\n\r\n    {\r\n      static int_T rt_LoggedOutputWidths[] = {\r\n        4,\r\n        1\r\n      };\r\n\r\n      static int_T rt_LoggedOutputNumDimensions[] = {\r\n        1,\r\n        1\r\n      };\r\n\r\n      static int_T rt_LoggedOutputDimensions[] = {\r\n        4,\r\n        1\r\n      };\r\n\r\n      static boolean_T rt_LoggedOutputIsVarDims[] = {\r\n        0,\r\n        0\r\n      };\r\n\r\n      static void* rt_LoggedCurrentSignalDimensions[] = {\r\n        (NULL),\r\n        (NULL)\r\n      };\r\n\r\n      static int_T rt_LoggedCurrentSignalDimensionsSize[] = {\r\n        4,\r\n        4\r\n      };\r\n\r\n      static BuiltInDTypeId rt_LoggedOutputDataTypeIds[] = {\r\n        SS_SINGLE,\r\n        SS_UINT8\r\n      };\r\n\r\n      static int_T rt_LoggedOutputComplexSignals[] = {\r\n        0,\r\n        0\r\n      };\r\n\r\n      static RTWPreprocessingFcnPtr rt_LoggingPreprocessingFcnPtrs[] = {\r\n        (NULL),\r\n        (NULL)\r\n      };\r\n\r\n      static const char_T *rt_LoggedOutputLabels[] = {\r\n        \"motors\",\r\n        \"flag\" };\r\n\r\n      static const char_T *rt_LoggedOutputBlockNames[] = {\r\n        \"flightControlSystem/Actuators\",\r\n        \"flightControlSystem/Flag\" };\r\n\r\n      static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert[] = {\r\n        { 0, SS_SINGLE, SS_SINGLE, 0, 0, 0, 1.0, 0, 0.0 },\r\n\r\n        { 0, SS_UINT8, SS_UINT8, 0, 0, 0, 1.0, 0, 0.0 }\r\n      };\r\n\r\n      static RTWLogSignalInfo rt_LoggedOutputSignalInfo[] = {\r\n        {\r\n          2,\r\n          rt_LoggedOutputWidths,\r\n          rt_LoggedOutputNumDimensions,\r\n          rt_LoggedOutputDimensions,\r\n          rt_LoggedOutputIsVarDims,\r\n          rt_LoggedCurrentSignalDimensions,\r\n          rt_LoggedCurrentSignalDimensionsSize,\r\n          rt_LoggedOutputDataTypeIds,\r\n          rt_LoggedOutputComplexSignals,\r\n          (NULL),\r\n          rt_LoggingPreprocessingFcnPtrs,\r\n\r\n          { rt_LoggedOutputLabels },\r\n          (NULL),\r\n          (NULL),\r\n          (NULL),\r\n\r\n          { rt_LoggedOutputBlockNames },\r\n\r\n          { (NULL) },\r\n          (NULL),\r\n          rt_RTWLogDataTypeConvert\r\n        }\r\n      };\r\n\r\n      rtliSetLogYSignalInfo(flightControlSystem_M->rtwLogInfo,\r\n                            rt_LoggedOutputSignalInfo);\r\n\r\n      /* set currSigDims field */\r\n      rt_LoggedCurrentSignalDimensions[0] = &rt_LoggedOutputWidths[0];\r\n      rt_LoggedCurrentSignalDimensions[1] = &rt_LoggedOutputWidths[1];\r\n    }\r\n\r\n    rtliSetLogY(flightControlSystem_M->rtwLogInfo, \"yout\");\r\n  }\r\n\r\n  /* External mode info */\r\n  flightControlSystem_M->Sizes.checksums[0] = (1191579305U);\r\n  flightControlSystem_M->Sizes.checksums[1] = (3338200727U);\r\n  flightControlSystem_M->Sizes.checksums[2] = (1210126136U);\r\n  flightControlSystem_M->Sizes.checksums[3] = (858923583U);\r\n\r\n  {\r\n    static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;\r\n    static RTWExtModeInfo rt_ExtModeInfo;\r\n    static const sysRanDType *systemRan[15];\r\n    flightControlSystem_M->extModeInfo = (&rt_ExtModeInfo);\r\n    rteiSetSubSystemActiveVectorAddresses(&rt_ExtModeInfo, systemRan);\r\n    systemRan[0] = &rtAlwaysEnabled;\r\n    systemRan[1] = (sysRanDType *)\r\n      &flightControlSystem_DW.FlightControlSystem.Geofencingerror.Geofencingerror_SubsysRanBC;\r\n    systemRan[2] = (sysRanDType *)\r\n      &flightControlSystem_DW.FlightControlSystem.Normalcondition.Geofencingerror_SubsysRanBC;\r\n    systemRan[3] = (sysRanDType *)\r\n      &flightControlSystem_DW.FlightControlSystem.estimatorOpticalflowerror.Geofencingerror_SubsysRanBC;\r\n    systemRan[4] = &rtAlwaysEnabled;\r\n    systemRan[5] = &rtAlwaysEnabled;\r\n    systemRan[6] = &rtAlwaysEnabled;\r\n    systemRan[7] = &rtAlwaysEnabled;\r\n    systemRan[8] = &rtAlwaysEnabled;\r\n    systemRan[9] = &rtAlwaysEnabled;\r\n    systemRan[10] = &rtAlwaysEnabled;\r\n    systemRan[11] = &rtAlwaysEnabled;\r\n    systemRan[12] = &rtAlwaysEnabled;\r\n    systemRan[13] = &rtAlwaysEnabled;\r\n    systemRan[14] = &rtAlwaysEnabled;\r\n    rteiSetModelMappingInfoPtr(flightControlSystem_M->extModeInfo,\r\n      &flightControlSystem_M->SpecialInfo.mappingInfo);\r\n    rteiSetChecksumsPtr(flightControlSystem_M->extModeInfo,\r\n                        flightControlSystem_M->Sizes.checksums);\r\n    rteiSetTPtr(flightControlSystem_M->extModeInfo, rtmGetTPtr\r\n                (flightControlSystem_M));\r\n  }\r\n\r\n  /* data type transition information */\r\n  {\r\n    static DataTypeTransInfo dtInfo;\r\n    (void) memset((char_T *) &dtInfo, 0,\r\n                  sizeof(dtInfo));\r\n    flightControlSystem_M->SpecialInfo.mappingInfo = (&dtInfo);\r\n    dtInfo.numDataTypes = 49;\r\n    dtInfo.dataTypeSizes = &rtDataTypeSizes[0];\r\n    dtInfo.dataTypeNames = &rtDataTypeNames[0];\r\n\r\n    /* Block I/O transition table */\r\n    dtInfo.BTransTable = &rtBTransTable;\r\n\r\n    /* Parameters transition table */\r\n    dtInfo.PTransTable = &rtPTransTable;\r\n  }\r\n\r\n  /* Model Initialize function for ModelReference Block: '<S1>/controller' */\r\n  flightController_g_initialize(rtmGetErrorStatusPointer(flightControlSystem_M));\r\n\r\n  /* Model Initialize function for ModelReference Block: '<S1>/estimator' */\r\n  stateEstimator_o_initialize(rtmGetErrorStatusPointer(flightControlSystem_M));\r\n\r\n  /* Matfile logging */\r\n  rt_StartDataLoggingWithStartTime(flightControlSystem_M->rtwLogInfo, 0.0,\r\n    rtmGetTFinal(flightControlSystem_M), flightControlSystem_M->Timing.stepSize0,\r\n    (&rtmGetErrorStatus(flightControlSystem_M)));\r\n\r\n  /* InitializeConditions for RateTransition generated from: '<Root>/Rate Transition' */\r\n  flightControlSystem_DW.RateTransition_1_Buffer[0] =\r\n    flightControlSystem_P.RateTransition_1_InitialCondition;\r\n\r\n  /* InitializeConditions for RateTransition generated from: '<Root>/Rate Transition' */\r\n  flightControlSystem_DW.RateTransition_2_Buffer[0] =\r\n    flightControlSystem_P.RateTransition_2_InitialCondition;\r\n\r\n  /* SystemInitialize for Atomic SubSystem: '<Root>/Flight Control System' */\r\n\r\n  /* SystemInitialize for Inport: '<Root>/Sensors' */\r\n  flightControlSystem_FlightControlSystem_Init(flightControlSystem_M,\r\n    &flag_outport, &flightControlSystem_DW.FlightControlSystem,\r\n    &flightControlSystem_P.FlightControlSystem);\r\n\r\n  /* End of SystemInitialize for SubSystem: '<Root>/Flight Control System' */\r\n}\r\n\r\n/* Model terminate function */\r\nvoid flightControlSystem_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem.h","type":"header","group":"model","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: flightControlSystem.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.51\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov 13 17:46:32 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_flightControlSystem_h_\r\n#define RTW_HEADER_flightControlSystem_h_\r\n#ifndef flightControlSystem_COMMON_INCLUDES_\r\n#define flightControlSystem_COMMON_INCLUDES_\r\n#include <stdlib.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_extmode.h\"\r\n#include \"sysran_types.h\"\r\n#include \"rt_logging.h\"\r\n#include \"dt_info.h\"\r\n#include \"ext_work.h\"\r\n#include \"grabberCannon.h\"\r\n#include \"rsedu_image.h\"\r\n#endif                                /* flightControlSystem_COMMON_INCLUDES_ */\r\n\r\n#include \"flightControlSystem_types.h\"\r\n#include <stddef.h>\r\n#include <float.h>\r\n#include <string.h>\r\n#include \"rt_nonfinite.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetFinalTime\r\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetRTWExtModeInfo\r\n#define rtmGetRTWExtModeInfo(rtm)      ((rtm)->extModeInfo)\r\n#endif\r\n\r\n#ifndef rtmGetRTWLogInfo\r\n#define rtmGetRTWLogInfo(rtm)          ((rtm)->rtwLogInfo)\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatusPointer\r\n#define rtmGetErrorStatusPointer(rtm)  ((const char_T **)(&((rtm)->errorStatus)))\r\n#endif\r\n\r\n#ifndef rtmStepTask\r\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   ((rtm)->Timing.taskTime0)\r\n#endif\r\n\r\n#ifndef rtmGetTFinal\r\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                (&(rtm)->Timing.taskTime0)\r\n#endif\r\n\r\n#ifndef rtmTaskCounter\r\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\r\n#endif\r\n\r\n/* Block states (default storage) for system '<S3>/Geofencing error' */\r\ntypedef struct {\r\n  int8_T Geofencingerror_SubsysRanBC;  /* '<S3>/Geofencing error' */\r\n} DW_Geofencingerror_flightControlSystem_T;\r\n\r\n/* Block signals for system '<S1>/Logging' */\r\ntypedef struct {\r\n  real32_T X;                          /* '<S4>/states_estim_BusSelector' */\r\n  real32_T Y;                          /* '<S4>/states_estim_BusSelector' */\r\n  real32_T Z;                          /* '<S4>/states_estim_BusSelector' */\r\n  real32_T yaw;                        /* '<S4>/states_estim_BusSelector' */\r\n  real32_T pitch;                      /* '<S4>/states_estim_BusSelector' */\r\n  real32_T roll;                       /* '<S4>/states_estim_BusSelector' */\r\n  real32_T dx;                         /* '<S4>/states_estim_BusSelector' */\r\n  real32_T dy;                         /* '<S4>/states_estim_BusSelector' */\r\n  real32_T dz;                         /* '<S4>/states_estim_BusSelector' */\r\n  real32_T p;                          /* '<S4>/states_estim_BusSelector' */\r\n  real32_T q;                          /* '<S4>/states_estim_BusSelector' */\r\n  real32_T r;                          /* '<S4>/states_estim_BusSelector' */\r\n  real32_T TmpSignalConversionAtToWorkspace2Inport1[12];\r\n  real32_T DataTypeConversion1;        /* '<S4>/Data Type Conversion1' */\r\n  real32_T DataTypeConversion2;        /* '<S4>/Data Type Conversion2' */\r\n  real32_T TmpSignalConversionAtToWorkspace6Inport1[10];\r\n  real32_T DataTypeConversion3;        /* '<S4>/Data Type Conversion3' */\r\n  real32_T pos_ref[3];          /* '<S4>/ReferenceValueServerBus_BusSelector' */\r\n  real32_T DataTypeConversion7;        /* '<S4>/Data Type Conversion7' */\r\n  real32_T orient_ref[3];       /* '<S4>/ReferenceValueServerBus_BusSelector' */\r\n  real32_T DataTypeConversion9;        /* '<S4>/Data Type Conversion9' */\r\n  real32_T TmpSignalConversionAtToWorkspace3Inport1[9];\r\n  real32_T DataTypeConversion11;       /* '<S4>/Data Type Conversion11' */\r\n  real32_T opticalFlow_data[3];        /* '<S4>/Sensors_BusSelector' */\r\n  real32_T posVIS_data[4];             /* '<S4>/Sensors_BusSelector' */\r\n  real32_T TmpSignalConversionAtToWorkspace4Inport1[8];\r\n  real32_T SensorCalibration[8];       /* '<S4>/Sensors_BusSelector' */\r\n} B_Logging_flightControlSystem_T;\r\n\r\n/* Block states (default storage) for system '<S1>/Logging' */\r\ntypedef struct {\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace2_PWORK;                /* '<S4>/To Workspace2' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace6_PWORK;                /* '<S4>/To Workspace6' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace3_PWORK;                /* '<S4>/To Workspace3' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace4_PWORK;                /* '<S4>/To Workspace4' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace5_PWORK;                /* '<S4>/To Workspace5' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace_PWORK;                 /* '<S4>/To Workspace' */\r\n\r\n  struct {\r\n    void *LoggedData;\r\n  } ToWorkspace1_PWORK;                /* '<S4>/To Workspace1' */\r\n} DW_Logging_flightControlSystem_T;\r\n\r\n/* Block signals for system '<Root>/Flight Control System' */\r\ntypedef struct {\r\n  statesEstim_t estimator;             /* '<S1>/estimator' */\r\n  sensordata_t BusConversion_InsertedFor_estimator_at_inport_1_BusCreator1;\r\n  CommandBus BusCreator;               /* '<S5>/Bus Creator' */\r\n  real_T Grabber;                      /* '<S5>/Grabber' */\r\n  real_T x_g;                          /* '<S5>/Chart' */\r\n  real_T y_b;                          /* '<S5>/Chart' */\r\n  real_T z_g;                          /* '<S5>/Chart' */\r\n  real_T grabber_c;                    /* '<S5>/Chart' */\r\n  real_T takeoff_flag;                 /* '<S5>/Chart' */\r\n  real_T d;\r\n  real32_T x_c;\r\n  real32_T y_n;\r\n  real32_T z_p;\r\n  real32_T x_cd;\r\n  real32_T y_nb;\r\n  real32_T z_p1;\r\n  real32_T altitude;\r\n  real32_T pressure;\r\n  real32_T controller_o2[8];           /* '<S1>/controller' */\r\n  real32_T Max;                        /* '<S5>/Max' */\r\n  real32_T rtb_vbat_V_m;\r\n  uint32_T rtb_vbat_percentage_c;\r\n  uint8_T u;\r\n  boolean_T Compare_h;                 /* '<S9>/Compare' */\r\n  boolean_T Compare_l;                 /* '<S12>/Compare' */\r\n  boolean_T Compare_mb;                /* '<S10>/Compare' */\r\n  B_Logging_flightControlSystem_T Logging;/* '<S1>/Logging' */\r\n} B_FlightControlSystem_flightControlSystem_T;\r\n\r\n/* Block states (default storage) for system '<Root>/Flight Control System' */\r\ntypedef struct {\r\n  struct {\r\n    void *LoggedData;\r\n  } Scope_PWORK;                       /* '<S5>/Scope' */\r\n\r\n  uint32_T is_c4_flightControlSystem;  /* '<S5>/Chart3' */\r\n  uint32_T is_c2_flightControlSystem;  /* '<S5>/Chart2' */\r\n  uint32_T is_c1_flightControlSystem;  /* '<S5>/Chart1' */\r\n  uint32_T is_c3_flightControlSystem;  /* '<S5>/Chart' */\r\n  uint32_T is_Takeoff;                 /* '<S5>/Chart' */\r\n  uint16_T temporalCounter_i1;         /* '<S5>/Chart3' */\r\n  uint16_T temporalCounter_i1_d;       /* '<S5>/Chart2' */\r\n  uint16_T temporalCounter_i1_p;       /* '<S5>/Chart1' */\r\n  uint16_T temporalCounter_i1_g;       /* '<S5>/Chart' */\r\n  uint16_T temporalCounter_i2;         /* '<S5>/Chart' */\r\n  uint8_T is_active_c4_flightControlSystem;/* '<S5>/Chart3' */\r\n  uint8_T is_active_c2_flightControlSystem;/* '<S5>/Chart2' */\r\n  uint8_T is_active_c1_flightControlSystem;/* '<S5>/Chart1' */\r\n  uint8_T is_active_c3_flightControlSystem;/* '<S5>/Chart' */\r\n  DW_Logging_flightControlSystem_T Logging;/* '<S1>/Logging' */\r\n  DW_Geofencingerror_flightControlSystem_T Normalcondition;/* '<S3>/Normal condition' */\r\n  DW_Geofencingerror_flightControlSystem_T estimatorOpticalflowerror;\r\n                                      /* '<S3>/estimator//Optical flow error' */\r\n  DW_Geofencingerror_flightControlSystem_T Geofencingerror;/* '<S3>/Geofencing error' */\r\n} DW_FlightControlSystem_flightControlSystem_T;\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T rowIdx_data[4960];\r\n  real_T colIdx_data[4960];\r\n  int32_T i_data[4960];\r\n  uint8_T imageBuff_1[19200];\r\n  uint8_T imageBuff_2[19200];\r\n  uint8_T imageBuff_3[19200];\r\n  uint8_T j_data[4960];\r\n  real_T dy;                           /* '<Root>/Rate Transition' */\r\n  real_T dx;                           /* '<Root>/Rate Transition' */\r\n  real_T CastToDouble;                 /* '<S2>/Cast To Double' */\r\n  real_T deltaX;                       /* '<S2>/MATLAB Function1' */\r\n  real_T deltaY;                       /* '<S2>/MATLAB Function1' */\r\n  boolean_T Submatrix[19200];          /* '<S2>/Submatrix' */\r\n  real_T avgX;\r\n  real_T avgY;\r\n  boolean_T Compare;                   /* '<S20>/Compare' */\r\n  boolean_T BW[19200];                 /* '<S2>/MATLAB Function' */\r\n  B_FlightControlSystem_flightControlSystem_T FlightControlSystem;/* '<Root>/Flight Control System' */\r\n} B_flightControlSystem_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  volatile real_T RateTransition_1_Buffer[2];/* '<Root>/Rate Transition' */\r\n  volatile real_T RateTransition_2_Buffer[2];/* '<Root>/Rate Transition' */\r\n  struct {\r\n    void *LoggedData[5];\r\n  } Scope_PWORK;                       /* '<S2>/Scope' */\r\n\r\n  volatile int8_T RateTransition_1_ActiveBufIdx;/* '<Root>/Rate Transition' */\r\n  volatile int8_T RateTransition_2_ActiveBufIdx;/* '<Root>/Rate Transition' */\r\n  uint8_T is_active_c6_flightControlSystem;/* '<S2>/MATLAB Function1' */\r\n  uint8_T is_active_c5_flightControlSystem;/* '<S2>/MATLAB Function' */\r\n  boolean_T doneDoubleBufferReInit;    /* '<S2>/MATLAB Function1' */\r\n  boolean_T doneDoubleBufferReInit_c;  /* '<S2>/MATLAB Function' */\r\n  DW_FlightControlSystem_flightControlSystem_T FlightControlSystem;/* '<Root>/Flight Control System' */\r\n} DW_flightControlSystem_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real32_T Actuators[4];               /* '<Root>/Actuators' */\r\n  uint8_T Flag;                        /* '<Root>/Flag' */\r\n} ExtY_flightControlSystem_T;\r\n\r\n/* Parameters for system: '<S3>/Geofencing error' */\r\nstruct P_Geofencingerror_flightControlSystem_T_ {\r\n  uint8_T Constant_Value;              /* Computed Parameter: Constant_Value\r\n                                        * Referenced by: '<S13>/Constant'\r\n                                        */\r\n};\r\n\r\n/* Parameters for system: '<Root>/Flight Control System' */\r\nstruct P_FlightControlSystem_flightControlSystem_T_ {\r\n  real32_T CompareToConstant_const;   /* Mask Parameter: CompareToConstant_const\r\n                                       * Referenced by: '<S7>/Constant'\r\n                                       */\r\n  real32_T CompareToConstant1_const; /* Mask Parameter: CompareToConstant1_const\r\n                                      * Referenced by: '<S8>/Constant'\r\n                                      */\r\n  real32_T CompareToConstant2_const; /* Mask Parameter: CompareToConstant2_const\r\n                                      * Referenced by: '<S9>/Constant'\r\n                                      */\r\n  real32_T CompareToConstant6_const; /* Mask Parameter: CompareToConstant6_const\r\n                                      * Referenced by: '<S12>/Constant'\r\n                                      */\r\n  real32_T CompareToConstant3_const; /* Mask Parameter: CompareToConstant3_const\r\n                                      * Referenced by: '<S10>/Constant'\r\n                                      */\r\n  real32_T CompareToConstant5_const; /* Mask Parameter: CompareToConstant5_const\r\n                                      * Referenced by: '<S11>/Constant'\r\n                                      */\r\n  statesEstim_t Memory_InitialCondition;\r\n                                  /* Computed Parameter: Memory_InitialCondition\r\n                                   * Referenced by: '<S5>/Memory'\r\n                                   */\r\n  real_T landingOverrideLimit_Value;\r\n                             /* Expression: landingAltitude-measurementTolerance\r\n                              * Referenced by: '<S5>/landingOverrideLimit'\r\n                              */\r\n  real32_T Constant3_Value[3];         /* Computed Parameter: Constant3_Value\r\n                                        * Referenced by: '<S5>/Constant3'\r\n                                        */\r\n  real32_T Gain2_Gain;                 /* Computed Parameter: Gain2_Gain\r\n                                        * Referenced by: '<S3>/Gain2'\r\n                                        */\r\n  real32_T Gain1_Gain;                 /* Computed Parameter: Gain1_Gain\r\n                                        * Referenced by: '<S3>/Gain1'\r\n                                        */\r\n  real32_T Constant2_Value;            /* Expression: landingAltitude\r\n                                        * Referenced by: '<S5>/Constant2'\r\n                                        */\r\n  boolean_T Constant1_Value;           /* Expression: true\r\n                                        * Referenced by: '<S5>/Constant1'\r\n                                        */\r\n  uint8_T Merge_InitialOutput;        /* Computed Parameter: Merge_InitialOutput\r\n                                       * Referenced by: '<S3>/Merge'\r\n                                       */\r\n  P_Geofencingerror_flightControlSystem_T Normalcondition;/* '<S3>/Normal condition' */\r\n  P_Geofencingerror_flightControlSystem_T estimatorOpticalflowerror;\r\n                                      /* '<S3>/estimator//Optical flow error' */\r\n  P_Geofencingerror_flightControlSystem_T Geofencingerror;/* '<S3>/Geofencing error' */\r\n};\r\n\r\n/* Parameters (default storage) */\r\nstruct P_flightControlSystem_T_ {\r\n  real_T CompareToConstant2_const;   /* Mask Parameter: CompareToConstant2_const\r\n                                      * Referenced by: '<S20>/Constant'\r\n                                      */\r\n  real_T RateTransition_1_InitialCondition;/* Expression: 0\r\n                                            * Referenced by: '<Root>/Rate Transition'\r\n                                            */\r\n  real_T RateTransition_2_InitialCondition;/* Expression: 0\r\n                                            * Referenced by: '<Root>/Rate Transition'\r\n                                            */\r\n  P_FlightControlSystem_flightControlSystem_T FlightControlSystem;/* '<Root>/Flight Control System' */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_flightControlSystem_T {\r\n  const char_T *errorStatus;\r\n  RTWLogInfo *rtwLogInfo;\r\n  RTWExtModeInfo *extModeInfo;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    uint32_T checksums[4];\r\n  } Sizes;\r\n\r\n  /*\r\n   * SpecialInfo:\r\n   * The following substructure contains special information\r\n   * related to other components that are dependent on RTW.\r\n   */\r\n  struct {\r\n    const void *mappingInfo;\r\n  } SpecialInfo;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    time_T taskTime0;\r\n    uint32_T clockTick0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    struct {\r\n      uint32_T TID[2];\r\n    } TaskCounters;\r\n\r\n    time_T tFinal;\r\n    boolean_T stopRequestedFlag;\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_flightControlSystem_T flightControlSystem_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_flightControlSystem_T flightControlSystem_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_flightControlSystem_T flightControlSystem_DW;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_flightControlSystem_T flightControlSystem_Y;\r\n\r\n/* Model block global parameters (default storage) */\r\nextern struct_pAcs5k38eV6MpgiqrKAV4 rtP_Sensors;/* Variable: Sensors\r\n                                                 * Referenced by: '<S1>/estimator'\r\n                                                 */\r\nextern boolean_T rtP_enableLanding;    /* Variable: enableLanding\r\n                                        * Referenced by: '<S5>/Constant'\r\n                                        */\r\n\r\n/*\r\n * Exported Global Signals\r\n *\r\n * Note: Exported global signals are block signals with an exported global\r\n * storage class designation.  Code generation will declare the memory for\r\n * these signals and export their symbols.\r\n *\r\n */\r\nextern CommandBus cmd_inport;          /* '<Root>/AC cmd' */\r\nextern SensorsBus sensor_inport;       /* '<Root>/Sensors' */\r\nextern real32_T motors_outport[4];     /* '<S1>/controller' */\r\nextern uint8_T flag_outport;           /* '<S3>/Merge' */\r\n\r\n/* External function called from main */\r\nextern void flightControlSystem_SetEventsForThisBaseStep(boolean_T *eventFlags);\r\n\r\n/* Model entry point functions */\r\nextern void flightControlSystem_initialize(void);\r\nextern void flightControlSystem_step0(void);\r\nextern void flightControlSystem_step1(void);\r\nextern void flightControlSystem_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_flightControlSystem_T *const flightControlSystem_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'flightControlSystem'\r\n * '<S1>'   : 'flightControlSystem/Flight Control System'\r\n * '<S2>'   : 'flightControlSystem/Image Processing System'\r\n * '<S3>'   : 'flightControlSystem/Flight Control System/Crash Predictor Flags'\r\n * '<S4>'   : 'flightControlSystem/Flight Control System/Logging'\r\n * '<S5>'   : 'flightControlSystem/Flight Control System/landing logic'\r\n * '<S6>'   : 'flightControlSystem/Flight Control System/sensordata_group'\r\n * '<S7>'   : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant'\r\n * '<S8>'   : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant1'\r\n * '<S9>'   : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant2'\r\n * '<S10>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant3'\r\n * '<S11>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant5'\r\n * '<S12>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Compare To Constant6'\r\n * '<S13>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Geofencing error'\r\n * '<S14>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/Normal condition'\r\n * '<S15>'  : 'flightControlSystem/Flight Control System/Crash Predictor Flags/estimator//Optical flow error'\r\n * '<S16>'  : 'flightControlSystem/Flight Control System/landing logic/Chart'\r\n * '<S17>'  : 'flightControlSystem/Flight Control System/landing logic/Chart1'\r\n * '<S18>'  : 'flightControlSystem/Flight Control System/landing logic/Chart2'\r\n * '<S19>'  : 'flightControlSystem/Flight Control System/landing logic/Chart3'\r\n * '<S20>'  : 'flightControlSystem/Image Processing System/Compare To Constant2'\r\n * '<S21>'  : 'flightControlSystem/Image Processing System/MATLAB Function'\r\n * '<S22>'  : 'flightControlSystem/Image Processing System/MATLAB Function1'\r\n */\r\n#endif                                 /* RTW_HEADER_flightControlSystem_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem_private.h","type":"header","group":"model","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: flightControlSystem_private.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.51\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov 13 17:46:32 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_flightControlSystem_private_h_\r\n#define RTW_HEADER_flightControlSystem_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"builtin_typeid_types.h\"\r\n#include \"multiword_types.h\"\r\n#include \"flightControlSystem.h\"\r\n#include \"flightControlSystem_types.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmSetTFinal\r\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\r\n#endif\r\n\r\n/* Imported (extern) pointer block signals */\r\nextern uint8_T *imRGB;                 /* '<Root>/Image Data' */\r\nextern void flightControlSystem_Geofencingerror(uint8_T *rty_Out1,\r\n  P_Geofencingerror_flightControlSystem_T *localP);\r\nextern void flightControlSystem_Logging_Init(RT_MODEL_flightControlSystem_T *\r\n  const flightControlSystem_M, DW_Logging_flightControlSystem_T *localDW);\r\nextern void flightControlSystem_Logging(RT_MODEL_flightControlSystem_T * const\r\n  flightControlSystem_M, const real32_T rtu_motorCmds[4], const real32_T\r\n  rtu_posRef[8], const statesEstim_t *rtu_states_estim_Inport_3, const\r\n  CommandBus *rtu_ReferenceValueServerBus_Inport_4, const SensorsBus\r\n  *rtu_Sensors_Inport_5, real32_T rtu_sensordata_datin_Inport_6, uint32_T\r\n  rtu_sensordata_datin_Inport_6_d, real32_T rtu_sensordata_datin_Inport_6_e,\r\n  real32_T rtu_sensordata_datin_Inport_6_c, real32_T\r\n  rtu_sensordata_datin_Inport_6_cg, real32_T rtu_sensordata_datin_Inport_6_i,\r\n  real32_T rtu_sensordata_datin_Inport_6_h, real32_T\r\n  rtu_sensordata_datin_Inport_6_b, real32_T rtu_sensordata_datin_Inport_6_dz,\r\n  real32_T rtu_sensordata_datin_Inport_6_n, B_Logging_flightControlSystem_T\r\n  *localB, DW_Logging_flightControlSystem_T *localDW);\r\nextern void flightControlSystem_FlightControlSystem_Init\r\n  (RT_MODEL_flightControlSystem_T * const flightControlSystem_M, uint8_T\r\n   *rty_Flag, DW_FlightControlSystem_flightControlSystem_T *localDW,\r\n   P_FlightControlSystem_flightControlSystem_T *localP);\r\nextern void flightControlSystem_FlightControlSystem\r\n  (RT_MODEL_flightControlSystem_T * const flightControlSystem_M, const\r\n   CommandBus *rtu_ReferenceValueServerCmds, const SensorsBus\r\n   *rtu_Sensors_Inport_2, real_T rtu_VisionbasedData, real_T\r\n   rtu_VisionbasedData_p, real32_T rty_motorCmds[4], uint8_T *rty_Flag,\r\n   B_FlightControlSystem_flightControlSystem_T *localB,\r\n   DW_FlightControlSystem_flightControlSystem_T *localDW,\r\n   P_FlightControlSystem_flightControlSystem_T *localP);\r\n\r\n#endif                           /* RTW_HEADER_flightControlSystem_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem_types.h","type":"header","group":"model","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: flightControlSystem_types.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.51\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov 13 17:46:32 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_flightControlSystem_types_h_\r\n#define RTW_HEADER_flightControlSystem_types_h_\r\n#include \"rtwtypes.h\"\r\n#include \"C:\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\parrot\\include\\HAL.h\"\r\n#ifndef DEFINED_TYPEDEF_FOR_CommandBus_\r\n#define DEFINED_TYPEDEF_FOR_CommandBus_\r\n\r\ntypedef struct {\r\n  boolean_T controlModePosVSOrient;\r\n  real32_T pos_ref[3];\r\n  boolean_T takeoff_flag;\r\n  real32_T orient_ref[3];\r\n  uint32_T live_time_ticks;\r\n} CommandBus;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_extraSensorData_t_\r\n#define DEFINED_TYPEDEF_FOR_extraSensorData_t_\r\n\r\ntypedef struct {\r\n  real32_T opticalFlow_data[3];\r\n  real32_T posVIS_data[4];\r\n  real32_T usePosVIS_flag;\r\n} extraSensorData_t;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_SensorsBus_\r\n#define DEFINED_TYPEDEF_FOR_SensorsBus_\r\n\r\ntypedef struct {\r\n  extraSensorData_t VisionSensors;\r\n  HAL_acquisition_t HALSensors;\r\n  real32_T SensorCalibration[8];\r\n} SensorsBus;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_statesEstim_t_\r\n#define DEFINED_TYPEDEF_FOR_statesEstim_t_\r\n\r\ntypedef struct {\r\n  real32_T X;\r\n  real32_T Y;\r\n  real32_T Z;\r\n  real32_T yaw;\r\n  real32_T pitch;\r\n  real32_T roll;\r\n  real32_T dx;\r\n  real32_T dy;\r\n  real32_T dz;\r\n  real32_T p;\r\n  real32_T q;\r\n  real32_T r;\r\n} statesEstim_t;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_sensordata_t_\r\n#define DEFINED_TYPEDEF_FOR_sensordata_t_\r\n\r\ntypedef struct {\r\n  real32_T ddx;\r\n  real32_T ddy;\r\n  real32_T ddz;\r\n  real32_T p;\r\n  real32_T q;\r\n  real32_T r;\r\n  real32_T altitude_sonar;\r\n  real32_T prs;\r\n  real32_T vbat_V;\r\n  uint32_T vbat_percentage;\r\n} sensordata_t;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_eF5OUT33sX0T9pzS8027m_\r\n#define DEFINED_TYPEDEF_FOR_struct_eF5OUT33sX0T9pzS8027m_\r\n\r\ntypedef struct {\r\n  real_T cg[3];\r\n  real_T location[3];\r\n  real_T accNatFreq;\r\n  real_T accDamping;\r\n  real_T accScaleCross[9];\r\n  real_T accBias[3];\r\n  real_T accLimits[6];\r\n  real_T gyroNatFreq;\r\n  real_T gyroDamping;\r\n  real_T gyroScaleCross[9];\r\n  real_T gyroBias[3];\r\n  real_T gyroGBias[3];\r\n  real_T gyroLimits[6];\r\n  real_T noiseSeeds[6];\r\n  real_T noiseWeights[6];\r\n  real_T noisePower[6];\r\n} struct_eF5OUT33sX0T9pzS8027m;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_FIfaVnupBjYAxo1EdNiDlF_\r\n#define DEFINED_TYPEDEF_FOR_struct_FIfaVnupBjYAxo1EdNiDlF_\r\n\r\ntypedef struct {\r\n  real_T noisePower;\r\n  real_T noiseSeeds;\r\n} struct_FIfaVnupBjYAxo1EdNiDlF;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_eFnp8sKFNJLN84XLbLzaFF_\r\n#define DEFINED_TYPEDEF_FOR_struct_eFnp8sKFNJLN84XLbLzaFF_\r\n\r\ntypedef struct {\r\n  real_T posVISNoVisionAvail[4];\r\n  real_T usePosVISFlag;\r\n  real_T batteryStatus[2];\r\n} struct_eFnp8sKFNJLN84XLbLzaFF;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_pAcs5k38eV6MpgiqrKAV4_\r\n#define DEFINED_TYPEDEF_FOR_struct_pAcs5k38eV6MpgiqrKAV4_\r\n\r\ntypedef struct {\r\n  real_T IMUAccelGain[3];\r\n  real_T IMUGyroGain[3];\r\n  struct_eF5OUT33sX0T9pzS8027m IMU;\r\n  struct_FIfaVnupBjYAxo1EdNiDlF Sonar;\r\n  real_T NO_VIS_X;\r\n  real_T NO_VIS_YAW;\r\n  struct_eFnp8sKFNJLN84XLbLzaFF dummy;\r\n  real_T sensorDelay;\r\n  real_T airDensity;\r\n  real_T altToPrsGain;\r\n  real_T altToPrsBias;\r\n  real_T inverseIMUGain[6];\r\n  real_T altSensorMin;\r\n  real_T velocityToOpticalFlowGain;\r\n  real_T cameraResolution[2];\r\n} struct_pAcs5k38eV6MpgiqrKAV4;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_eAf0NJvzCY9HYTXF7bLNgB_\r\n#define DEFINED_TYPEDEF_FOR_struct_eAf0NJvzCY9HYTXF7bLNgB_\r\n\r\ntypedef struct {\r\n  real_T Ts2Q[16];\r\n  real_T Q2Ts[16];\r\n  real_T takeoffGain;\r\n  real_T totalThrustMaxRelative;\r\n  real_T motorsThrustPerMotorMax;\r\n} struct_eAf0NJvzCY9HYTXF7bLNgB;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_XRMsui9C07VjBvdq1msujB_\r\n#define DEFINED_TYPEDEF_FOR_struct_XRMsui9C07VjBvdq1msujB_\r\n\r\ntypedef struct {\r\n  real_T initGreenwich;\r\n  real_T quatGain;\r\n} struct_XRMsui9C07VjBvdq1msujB;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_hxsmtt0xTZOLDNa2Rz7GAF_\r\n#define DEFINED_TYPEDEF_FOR_struct_hxsmtt0xTZOLDNa2Rz7GAF_\r\n\r\ntypedef struct {\r\n  real_T xAxis;\r\n} struct_hxsmtt0xTZOLDNa2Rz7GAF;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_IZWOW0zYvpphl7qLgSfN7E_\r\n#define DEFINED_TYPEDEF_FOR_struct_IZWOW0zYvpphl7qLgSfN7E_\r\n\r\ntypedef struct {\r\n  real_T href;\r\n  struct_hxsmtt0xTZOLDNa2Rz7GAF FlatEarthToLLA;\r\n} struct_IZWOW0zYvpphl7qLgSfN7E;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_q6UUpnZ4gTjFvULFx6Rxa_\r\n#define DEFINED_TYPEDEF_FOR_struct_q6UUpnZ4gTjFvULFx6Rxa_\r\n\r\ntypedef struct {\r\n  real_T mass;\r\n  real_T inertia[9];\r\n  real_T d;\r\n  real_T xy;\r\n  real_T h;\r\n  real_T Cdx;\r\n  real_T Cdy;\r\n  real_T diameter;\r\n} struct_q6UUpnZ4gTjFvULFx6Rxa;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_OMRgDnJcZuQneKEj9vdTyD_\r\n#define DEFINED_TYPEDEF_FOR_struct_OMRgDnJcZuQneKEj9vdTyD_\r\n\r\ntypedef struct {\r\n  real_T blades;\r\n  real_T radius;\r\n  real_T chord;\r\n  real_T flappingOffset;\r\n  real_T bladeMass;\r\n  real_T bladeInertia;\r\n  real_T hubMass;\r\n  real_T hubInertia;\r\n  real_T inertia;\r\n  real_T Ct;\r\n  real_T Cq;\r\n  real_T solidity;\r\n  real_T theta0;\r\n  real_T thetaTip;\r\n  real_T theta1;\r\n  real_T theta34;\r\n  real_T a;\r\n  real_T area;\r\n  real_T lock;\r\n  real_T b;\r\n  real_T k;\r\n  real_T w2ToThrustGain;\r\n} struct_OMRgDnJcZuQneKEj9vdTyD;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_p3FXZIgqtjF2uqDpmYjb6C_\r\n#define DEFINED_TYPEDEF_FOR_struct_p3FXZIgqtjF2uqDpmYjb6C_\r\n\r\ntypedef struct {\r\n  real_T maxLimit;\r\n  real_T minLimit;\r\n  real_T commandToW2Gain;\r\n  real_T thrustToMotorCommand;\r\n} struct_p3FXZIgqtjF2uqDpmYjb6C;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_OSJpyIZcrpXqReVWwh9iuG_\r\n#define DEFINED_TYPEDEF_FOR_struct_OSJpyIZcrpXqReVWwh9iuG_\r\n\r\ntypedef struct {\r\n  struct_XRMsui9C07VjBvdq1msujB SixDOF;\r\n  struct_IZWOW0zYvpphl7qLgSfN7E PositionOnEarth;\r\n  struct_q6UUpnZ4gTjFvULFx6Rxa Airframe;\r\n  struct_OMRgDnJcZuQneKEj9vdTyD Rotor;\r\n  struct_p3FXZIgqtjF2uqDpmYjb6C Motor;\r\n} struct_OSJpyIZcrpXqReVWwh9iuG;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_struct_hE1099BMemg5OfzqcWAA6G_\r\n#define DEFINED_TYPEDEF_FOR_struct_hE1099BMemg5OfzqcWAA6G_\r\n\r\ntypedef struct {\r\n  real_T date[6];\r\n  real_T posLLA[3];\r\n  real_T posNED[3];\r\n  real_T vb[3];\r\n  real_T euler[3];\r\n  real_T angRates[3];\r\n} struct_hE1099BMemg5OfzqcWAA6G;\r\n\r\n#endif\r\n\r\n#ifndef struct_tag_3Gf95DFWcKEKwFsG1zCAqH\r\n#define struct_tag_3Gf95DFWcKEKwFsG1zCAqH\r\n\r\nstruct tag_3Gf95DFWcKEKwFsG1zCAqH\r\n{\r\n  int32_T isInitialized;\r\n};\r\n\r\n#endif                                 /* struct_tag_3Gf95DFWcKEKwFsG1zCAqH */\r\n\r\n#ifndef typedef_parrot_Grabber_flightControlSystem_T\r\n#define typedef_parrot_Grabber_flightControlSystem_T\r\n\r\ntypedef struct tag_3Gf95DFWcKEKwFsG1zCAqH parrot_Grabber_flightControlSystem_T;\r\n\r\n#endif                        /* typedef_parrot_Grabber_flightControlSystem_T */\r\n\r\n#ifndef struct_tag_XlO2h99uDeEYSa2APM6LVB\r\n#define struct_tag_XlO2h99uDeEYSa2APM6LVB\r\n\r\nstruct tag_XlO2h99uDeEYSa2APM6LVB\r\n{\r\n  int32_T isInitialized;\r\n};\r\n\r\n#endif                                 /* struct_tag_XlO2h99uDeEYSa2APM6LVB */\r\n\r\n#ifndef typedef_parrot_ImageProcess_flightControlSystem_T\r\n#define typedef_parrot_ImageProcess_flightControlSystem_T\r\n\r\ntypedef struct tag_XlO2h99uDeEYSa2APM6LVB\r\n  parrot_ImageProcess_flightControlSystem_T;\r\n\r\n#endif                   /* typedef_parrot_ImageProcess_flightControlSystem_T */\r\n\r\n/* Parameters for system: '<S3>/Geofencing error' */\r\ntypedef struct P_Geofencingerror_flightControlSystem_T_\r\n  P_Geofencingerror_flightControlSystem_T;\r\n\r\n/* Parameters for system: '<Root>/Flight Control System' */\r\ntypedef struct P_FlightControlSystem_flightControlSystem_T_\r\n  P_FlightControlSystem_flightControlSystem_T;\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_flightControlSystem_T_ P_flightControlSystem_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_flightControlSystem_T RT_MODEL_flightControlSystem_T;\r\n\r\n#endif                             /* RTW_HEADER_flightControlSystem_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem_data.c","type":"source","group":"data","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: flightControlSystem_data.c\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.51\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov 13 17:46:32 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"flightControlSystem.h\"\r\n\r\n/* Model block global parameters (default storage) */\r\nstruct_pAcs5k38eV6MpgiqrKAV4 rtP_Sensors = {\r\n  { 1.00596, 1.00383, 0.99454 },\r\n\r\n  { 0.99861, 1.00644, 0.99997 },\r\n\r\n  {\r\n    { 0.0, 0.0, 0.0 },\r\n\r\n    { 0.0, 0.0, 0.0 },\r\n    190.0,\r\n    0.707,\r\n\r\n    { 1.00596, 0.0, 0.0, 0.0, 1.00383, 0.0, 0.0, 0.0, 0.99454 },\r\n\r\n    { 0.09, -0.06, 0.33699999999999974 },\r\n\r\n    { -50.0, -50.0, -50.0, 50.0, 50.0, 50.0 },\r\n    190.0,\r\n    0.707,\r\n\r\n    { 0.99861, 0.0, 0.0, 0.0, 1.00644, 0.0, 0.0, 0.0, 0.99997 },\r\n\r\n    { -0.0095, -0.0075, 0.0015 },\r\n\r\n    { 0.0, 0.0, 0.0 },\r\n\r\n    { -10.0, -10.0, -10.0, 10.0, 10.0, 10.0 },\r\n\r\n    { 41.0, 41.0, 41.0, 41.0, 41.0, 41.0 },\r\n\r\n    { 0.8, 0.8, 0.8, 0.025, 0.025, 0.025 },\r\n\r\n    { 0.00021831529882618725, 0.00018641345254680647, 0.00037251068300213613,\r\n      1.0651514622688397e-8, 1.3021327403798377e-8, 1.1929474437781302e-8 }\r\n  },\r\n\r\n  {\r\n    1.0,\r\n    41.0\r\n  },\r\n  -99.0,\r\n  -9.0,\r\n\r\n  {\r\n    { -99.0, 0.0, 0.0, -9.0 },\r\n    0.0,\r\n\r\n    { 3.5, 70.0 }\r\n  },\r\n  1.0,\r\n  1.225,\r\n  12.01725,\r\n  101270.95,\r\n\r\n  { 0.99407531114557246, 0.99618461293246863, 1.0054899752649467,\r\n    1.0013919347893572, 0.99360120821906917, 1.0000300009000269 },\r\n  0.44,\r\n  1.0,\r\n\r\n  { 160.0, 120.0 }\r\n} ;                                    /* Variable: Sensors\r\n                                        * Referenced by: '<S1>/estimator'\r\n                                        */\r\n\r\nboolean_T rtP_enableLanding = true;    /* Variable: enableLanding\r\n                                        * Referenced by: '<S5>/Constant'\r\n                                        */\r\n\r\n/* Block parameters (default storage) */\r\nP_flightControlSystem_T flightControlSystem_P = {\r\n  /* Mask Parameter: CompareToConstant2_const\r\n   * Referenced by: '<S20>/Constant'\r\n   */\r\n  2000.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Rate Transition'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Rate Transition'\r\n   */\r\n  0.0,\r\n\r\n  /* Start of '<Root>/Flight Control System' */\r\n  {\r\n    /* Mask Parameter: CompareToConstant_const\r\n     * Referenced by: '<S7>/Constant'\r\n     */\r\n    10.0F,\r\n\r\n    /* Mask Parameter: CompareToConstant1_const\r\n     * Referenced by: '<S8>/Constant'\r\n     */\r\n    10.0F,\r\n\r\n    /* Mask Parameter: CompareToConstant2_const\r\n     * Referenced by: '<S9>/Constant'\r\n     */\r\n    0.01F,\r\n\r\n    /* Mask Parameter: CompareToConstant6_const\r\n     * Referenced by: '<S12>/Constant'\r\n     */\r\n    6.0F,\r\n\r\n    /* Mask Parameter: CompareToConstant3_const\r\n     * Referenced by: '<S10>/Constant'\r\n     */\r\n    6.0F,\r\n\r\n    /* Mask Parameter: CompareToConstant5_const\r\n     * Referenced by: '<S11>/Constant'\r\n     */\r\n    0.01F,\r\n\r\n    /* Computed Parameter: Memory_InitialCondition\r\n     * Referenced by: '<S5>/Memory'\r\n     */\r\n    {\r\n      0.0F,                            /* X */\r\n      0.0F,                            /* Y */\r\n      0.0F,                            /* Z */\r\n      0.0F,                            /* yaw */\r\n      0.0F,                            /* pitch */\r\n      0.0F,                            /* roll */\r\n      0.0F,                            /* dx */\r\n      0.0F,                            /* dy */\r\n      0.0F,                            /* dz */\r\n      0.0F,                            /* p */\r\n      0.0F,                            /* q */\r\n      0.0F                             /* r */\r\n    },\r\n\r\n    /* Expression: landingAltitude-measurementTolerance\r\n     * Referenced by: '<S5>/landingOverrideLimit'\r\n     */\r\n    -0.61,\r\n\r\n    /* Computed Parameter: Constant3_Value\r\n     * Referenced by: '<S5>/Constant3'\r\n     */\r\n    { 0.0F, 0.0F, 0.0F },\r\n\r\n    /* Computed Parameter: Gain2_Gain\r\n     * Referenced by: '<S3>/Gain2'\r\n     */\r\n    1.0F,\r\n\r\n    /* Computed Parameter: Gain1_Gain\r\n     * Referenced by: '<S3>/Gain1'\r\n     */\r\n    1.0F,\r\n\r\n    /* Expression: landingAltitude\r\n     * Referenced by: '<S5>/Constant2'\r\n     */\r\n    -0.6F,\r\n\r\n    /* Expression: true\r\n     * Referenced by: '<S5>/Constant1'\r\n     */\r\n    true,\r\n\r\n    /* Computed Parameter: Merge_InitialOutput\r\n     * Referenced by: '<S3>/Merge'\r\n     */\r\n    0U,\r\n\r\n    /* Start of '<S3>/Normal condition' */\r\n    {\r\n      /* Computed Parameter: Constant_Value\r\n       * Referenced by: '<S14>/Constant'\r\n       */\r\n      0U\r\n    }\r\n    ,\r\n\r\n    /* End of '<S3>/Normal condition' */\r\n\r\n    /* Start of '<S3>/estimator//Optical flow error' */\r\n    {\r\n      /* Computed Parameter: Constant_Value\r\n       * Referenced by: '<S15>/Constant'\r\n       */\r\n      99U\r\n    }\r\n    ,\r\n\r\n    /* End of '<S3>/estimator//Optical flow error' */\r\n\r\n    /* Start of '<S3>/Geofencing error' */\r\n    {\r\n      /* Computed Parameter: Constant_Value\r\n       * Referenced by: '<S13>/Constant'\r\n       */\r\n      1U\r\n    }\r\n    /* End of '<S3>/Geofencing error' */\r\n  }\r\n  /* End of '<Root>/Flight Control System' */\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"builtin_typeid_types.h","type":"header","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: builtin_typeid_types.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.1\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 18:11:20 2024\r\n */\r\n\r\n#ifndef BUILTIN_TYPEID_TYPES_H\r\n#define BUILTIN_TYPEID_TYPES_H\r\n#ifndef BUILTIN_TYPEID_TYPES\r\n#define BUILTIN_TYPEID_TYPES\r\n\r\n/* Enumeration of built-in data types */\r\ntypedef enum {\r\n  SS_DOUBLE = 0,\r\n  SS_SINGLE = 1,\r\n  SS_INT8 = 2,\r\n  SS_UINT8 = 3,\r\n  SS_INT16 = 4,\r\n  SS_UINT16 = 5,\r\n  SS_INT32 = 6,\r\n  SS_UINT32 = 7,\r\n  SS_BOOLEAN = 8\r\n} BuiltInDTypeId;\r\n\r\n#define SS_NUM_BUILT_IN_DTYPE          ((int)SS_BOOLEAN+1)\r\n\r\n/* Enumeration for MAT-file logging code */\r\ntypedef int DTypeId;\r\n\r\n/* Enumeration of pre-defined data types */\r\ntypedef enum {\r\n  SS_FCN_CALL = 9,\r\n  SS_INTEGER = 10,\r\n  SS_POINTER = 11,\r\n  SS_INTERNAL_DTYPE2 = 12,\r\n  SS_TIMER_UINT32_PAIR = 13,\r\n  SS_CONNECTION_TYPE = 14\r\n} PreDefinedDTypeId;\r\n\r\n#endif                                 /* BUILTIN_TYPEID_TYPES */\r\n#endif                                 /* BUILTIN_TYPEID_TYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mean_0sSgOgPG.c","type":"source","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mean_0sSgOgPG.c\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.36\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov 13 15:46:35 2024\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"mean_0sSgOgPG.h\"\r\n\r\n/* Function for MATLAB Function: '<S2>/MATLAB Function1' */\r\nreal_T mean_0sSgOgPG(const real_T x_data[], const int32_T *x_size)\r\n{\r\n  real_T b_y;\r\n  real_T bsum;\r\n  int32_T b_k;\r\n  int32_T firstBlockLength;\r\n  int32_T hi;\r\n  int32_T lastBlockLength;\r\n  int32_T nblocks;\r\n  int32_T xblockoffset;\r\n  if (*x_size <= 1024) {\r\n    firstBlockLength = *x_size;\r\n    lastBlockLength = 0;\r\n    nblocks = 1;\r\n  } else {\r\n    firstBlockLength = 1024;\r\n    nblocks = (int32_T)((uint32_T)*x_size >> 10);\r\n    lastBlockLength = *x_size - (nblocks << 10);\r\n    if (lastBlockLength > 0) {\r\n      nblocks++;\r\n    } else {\r\n      lastBlockLength = 1024;\r\n    }\r\n  }\r\n\r\n  b_y = x_data[0];\r\n  for (xblockoffset = 2; xblockoffset <= firstBlockLength; xblockoffset++) {\r\n    b_y += x_data[xblockoffset - 1];\r\n  }\r\n\r\n  for (firstBlockLength = 2; firstBlockLength <= nblocks; firstBlockLength++) {\r\n    xblockoffset = (firstBlockLength - 1) << 10;\r\n    bsum = x_data[xblockoffset];\r\n    if (firstBlockLength == nblocks) {\r\n      hi = lastBlockLength;\r\n    } else {\r\n      hi = 1024;\r\n    }\r\n\r\n    for (b_k = 2; b_k <= hi; b_k++) {\r\n      bsum += x_data[(xblockoffset + b_k) - 1];\r\n    }\r\n\r\n    b_y += bsum;\r\n  }\r\n\r\n  return b_y / (real_T)*x_size;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"mean_0sSgOgPG.h","type":"header","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: mean_0sSgOgPG.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.36\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov 13 15:46:35 2024\r\n */\r\n\r\n#ifndef RTW_HEADER_mean_0sSgOgPG_h_\r\n#define RTW_HEADER_mean_0sSgOgPG_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T mean_0sSgOgPG(const real_T x_data[], const int32_T *x_size);\r\n\r\n#endif                                 /* RTW_HEADER_mean_0sSgOgPG_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"multiword_types.h","type":"header","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: multiword_types.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.1\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 18:11:20 2024\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int32_T chunk_T;\r\ntypedef uint32_T uchunk_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 8.1\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 18:11:07 2024\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 8.1\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 18:11:07 2024\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 8.1\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 18:11:07 2024\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 8.1\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 18:11:07 2024\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 8.1\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 18:11:07 2024\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'stateEstimator'.\r\n *\r\n * Model version                  : 8.1\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 18:11:07 2024\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_roundd_snf.c","type":"source","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_roundd_snf.c\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.2\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 20:22:26 2024\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rt_roundd_snf.h\"\r\n#include <math.h>\r\n\r\nreal_T rt_roundd_snf(real_T u)\r\n{\r\n  real_T y;\r\n  if (fabs(u) < 4.503599627370496E+15) {\r\n    if (u >= 0.5) {\r\n      y = floor(u + 0.5);\r\n    } else if (u > -0.5) {\r\n      y = u * 0.0;\r\n    } else {\r\n      y = ceil(u - 0.5);\r\n    }\r\n  } else {\r\n    y = u;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_roundd_snf.h","type":"header","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_roundd_snf.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.2\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 20:22:26 2024\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_roundd_snf_h_\r\n#define RTW_HEADER_rt_roundd_snf_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rt_roundd_snf(real_T u);\r\n\r\n#endif                                 /* RTW_HEADER_rt_roundd_snf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"sharedutility","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\slprj\\ert\\_sharedutils","tag":"","groupDisplay":"Shared files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'conversionYUV'.\r\n *\r\n * Model version                  : 8.1\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov  6 18:10:37 2024\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM 9\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"flightControlSystem_dt.h","type":"header","group":"interface","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * flightControlSystem_dt.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"flightControlSystem\".\r\n *\r\n * Model version              : 8.51\r\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\r\n * C source code generated on : Wed Nov 13 17:46:32 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"ext_types.h\"\r\n\r\n/* data type size table */\r\nstatic uint_T rtDataTypeSizes[] = {\r\n  sizeof(real_T),\r\n  sizeof(real32_T),\r\n  sizeof(int8_T),\r\n  sizeof(uint8_T),\r\n  sizeof(int16_T),\r\n  sizeof(uint16_T),\r\n  sizeof(int32_T),\r\n  sizeof(uint32_T),\r\n  sizeof(boolean_T),\r\n  sizeof(fcn_call_T),\r\n  sizeof(int_T),\r\n  sizeof(pointer_T),\r\n  sizeof(action_T),\r\n  2*sizeof(uint32_T),\r\n  sizeof(int32_T),\r\n  sizeof(CommandBus),\r\n  sizeof(extraSensorData_t),\r\n  sizeof(HAL_acc_SI_t),\r\n  sizeof(HAL_gyro_SI_t),\r\n  sizeof(HAL_fifo_gyro_SI_t),\r\n  sizeof(HAL_magn_mG_t),\r\n  sizeof(HAL_pressure_SI_t),\r\n  sizeof(HAL_echo_t),\r\n  sizeof(HAL_list_echo_t),\r\n  sizeof(HAL_ultrasound_SI_t),\r\n  sizeof(HAL_vbat_SI_t),\r\n  sizeof(HAL_acquisition_t),\r\n  sizeof(SensorsBus),\r\n  sizeof(statesEstim_t),\r\n  sizeof(sensordata_t),\r\n  sizeof(struct_eF5OUT33sX0T9pzS8027m),\r\n  sizeof(struct_FIfaVnupBjYAxo1EdNiDlF),\r\n  sizeof(struct_eFnp8sKFNJLN84XLbLzaFF),\r\n  sizeof(struct_pAcs5k38eV6MpgiqrKAV4),\r\n  sizeof(parrot_Grabber_flightControlSystem_T),\r\n  sizeof(parrot_ImageProcess_flightControlSystem_T),\r\n  sizeof(struct_eAf0NJvzCY9HYTXF7bLNgB),\r\n  sizeof(struct_XRMsui9C07VjBvdq1msujB),\r\n  sizeof(struct_hxsmtt0xTZOLDNa2Rz7GAF),\r\n  sizeof(struct_IZWOW0zYvpphl7qLgSfN7E),\r\n  sizeof(struct_q6UUpnZ4gTjFvULFx6Rxa),\r\n  sizeof(struct_OMRgDnJcZuQneKEj9vdTyD),\r\n  sizeof(struct_p3FXZIgqtjF2uqDpmYjb6C),\r\n  sizeof(struct_OSJpyIZcrpXqReVWwh9iuG),\r\n  sizeof(struct_hE1099BMemg5OfzqcWAA6G),\r\n  sizeof(uint_T),\r\n  sizeof(char_T),\r\n  sizeof(uchar_T),\r\n  sizeof(time_T)\r\n};\r\n\r\n/* data type name table */\r\nstatic const char_T * rtDataTypeNames[] = {\r\n  \"real_T\",\r\n  \"real32_T\",\r\n  \"int8_T\",\r\n  \"uint8_T\",\r\n  \"int16_T\",\r\n  \"uint16_T\",\r\n  \"int32_T\",\r\n  \"uint32_T\",\r\n  \"boolean_T\",\r\n  \"fcn_call_T\",\r\n  \"int_T\",\r\n  \"pointer_T\",\r\n  \"action_T\",\r\n  \"timer_uint32_pair_T\",\r\n  \"physical_connection\",\r\n  \"CommandBus\",\r\n  \"extraSensorData_t\",\r\n  \"HAL_acc_SI_t\",\r\n  \"HAL_gyro_SI_t\",\r\n  \"HAL_fifo_gyro_SI_t\",\r\n  \"HAL_magn_mG_t\",\r\n  \"HAL_pressure_SI_t\",\r\n  \"HAL_echo_t\",\r\n  \"HAL_list_echo_t\",\r\n  \"HAL_ultrasound_SI_t\",\r\n  \"HAL_vbat_SI_t\",\r\n  \"HAL_acquisition_t\",\r\n  \"SensorsBus\",\r\n  \"statesEstim_t\",\r\n  \"sensordata_t\",\r\n  \"struct_eF5OUT33sX0T9pzS8027m\",\r\n  \"struct_FIfaVnupBjYAxo1EdNiDlF\",\r\n  \"struct_eFnp8sKFNJLN84XLbLzaFF\",\r\n  \"struct_pAcs5k38eV6MpgiqrKAV4\",\r\n  \"parrot_Grabber_flightControlSystem_T\",\r\n  \"parrot_ImageProcess_flightControlSystem_T\",\r\n  \"struct_eAf0NJvzCY9HYTXF7bLNgB\",\r\n  \"struct_XRMsui9C07VjBvdq1msujB\",\r\n  \"struct_hxsmtt0xTZOLDNa2Rz7GAF\",\r\n  \"struct_IZWOW0zYvpphl7qLgSfN7E\",\r\n  \"struct_q6UUpnZ4gTjFvULFx6Rxa\",\r\n  \"struct_OMRgDnJcZuQneKEj9vdTyD\",\r\n  \"struct_p3FXZIgqtjF2uqDpmYjb6C\",\r\n  \"struct_OSJpyIZcrpXqReVWwh9iuG\",\r\n  \"struct_hE1099BMemg5OfzqcWAA6G\",\r\n  \"uint_T\",\r\n  \"char_T\",\r\n  \"uchar_T\",\r\n  \"time_T\"\r\n};\r\n\r\n/* data type transitions for block I/O structure */\r\nstatic DataTypeTransition rtBTransitions[] = {\r\n  { (char_T *)(&flightControlSystem_B.dy), 0, 0, 5 },\r\n\r\n  { (char_T *)(&flightControlSystem_B.Submatrix[0]), 8, 0, 19200 },\r\n\r\n  { (char_T *)(&flightControlSystem_B.Compare), 8, 0, 19201 },\r\n\r\n  { (char_T *)(&flightControlSystem_B.FlightControlSystem.Grabber), 0, 0, 6 },\r\n\r\n  { (char_T *)(&flightControlSystem_B.FlightControlSystem.x_c), 1, 0, 16 },\r\n\r\n  { (char_T *)(&flightControlSystem_B.FlightControlSystem.Logging.X), 1, 0, 78 }\r\n  ,\r\n\r\n  { (char_T *)(&motors_outport[0]), 1, 0, 4 }\r\n  ,\r\n\r\n  { (char_T *)(&flag_outport), 3, 0, 1 }\r\n  ,\r\n\r\n  { (char_T *)(&flightControlSystem_DW.RateTransition_1_Buffer[0]), 0, 0, 4 },\r\n\r\n  { (char_T *)(&flightControlSystem_DW.Scope_PWORK.LoggedData[0]), 11, 0, 5 },\r\n\r\n  { (char_T *)(&flightControlSystem_DW.RateTransition_1_ActiveBufIdx), 2, 0, 2 },\r\n\r\n  { (char_T *)(&flightControlSystem_DW.is_active_c6_flightControlSystem), 3, 0,\r\n    2 },\r\n\r\n  { (char_T *)(&flightControlSystem_DW.doneDoubleBufferReInit), 8, 0, 2 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_DW.FlightControlSystem.Scope_PWORK.LoggedData), 11, 0,\r\n    1 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_DW.FlightControlSystem.is_c4_flightControlSystem), 7,\r\n    0, 5 },\r\n\r\n  { (char_T *)(&flightControlSystem_DW.FlightControlSystem.temporalCounter_i1),\r\n    5, 0, 5 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_DW.FlightControlSystem.is_active_c4_flightControlSystem),\r\n    3, 0, 4 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_DW.FlightControlSystem.Logging.ToWorkspace2_PWORK.LoggedData),\r\n    11, 0, 7 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_DW.FlightControlSystem.Normalcondition.Geofencingerror_SubsysRanBC),\r\n    2, 0, 1 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_DW.FlightControlSystem.estimatorOpticalflowerror.Geofencingerror_SubsysRanBC),\r\n    2, 0, 1 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_DW.FlightControlSystem.Geofencingerror.Geofencingerror_SubsysRanBC),\r\n    2, 0, 1 }\r\n};\r\n\r\n/* data type transition table for block I/O structure */\r\nstatic DataTypeTransitionTable rtBTransTable = {\r\n  21U,\r\n  rtBTransitions\r\n};\r\n\r\n/* data type transitions for Parameters structure */\r\nstatic DataTypeTransition rtPTransitions[] = {\r\n  { (char_T *)(&flightControlSystem_P.CompareToConstant2_const), 0, 0, 3 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_P.FlightControlSystem.CompareToConstant_const), 1, 0,\r\n    6 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_P.FlightControlSystem.Memory_InitialCondition), 28, 0,\r\n    1 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_P.FlightControlSystem.landingOverrideLimit_Value), 0,\r\n    0, 1 },\r\n\r\n  { (char_T *)(&flightControlSystem_P.FlightControlSystem.Constant3_Value[0]), 1,\r\n    0, 6 },\r\n\r\n  { (char_T *)(&flightControlSystem_P.FlightControlSystem.Constant1_Value), 8, 0,\r\n    1 },\r\n\r\n  { (char_T *)(&flightControlSystem_P.FlightControlSystem.Merge_InitialOutput),\r\n    3, 0, 1 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_P.FlightControlSystem.Normalcondition.Constant_Value),\r\n    3, 0, 1 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_P.FlightControlSystem.estimatorOpticalflowerror.Constant_Value),\r\n    3, 0, 1 },\r\n\r\n  { (char_T *)\r\n    (&flightControlSystem_P.FlightControlSystem.Geofencingerror.Constant_Value),\r\n    3, 0, 1 }\r\n  ,\r\n\r\n  { (char_T *)(&rtP_Sensors), 33, 0, 1 }\r\n  ,\r\n\r\n  { (char_T *)(&rtP_enableLanding), 8, 0, 1 }\r\n};\r\n\r\n/* data type transition table for Parameters structure */\r\nstatic DataTypeTransitionTable rtPTransTable = {\r\n  12U,\r\n  rtPTransitions\r\n};\r\n\r\n/* [EOF] flightControlSystem_dt.h */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'flightControlSystem'.\r\n *\r\n * Model version                  : 8.51\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Wed Nov 13 17:46:32 2024\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM 9\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"flightControlSystem.h\"\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"HAL.h","type":"header","group":"legacy","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\parrot\\include","tag":"","groupDisplay":"Other files","code":"#ifndef _HAL_H_\n#define _HAL_H_\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdint.h>\n#include <stdio.h>\n\n\n#define NB_TAB_ECHO  4\n#define MAX_ECHO 30\n\ntypedef uint16_t status_t;\n\n\n/**\n * \\struct _HAL_gyro_SI_t\n * \\brief Gyroscope data with SI unit (rad/s)\n */\ntypedef struct _HAL_gyro_SI_t\n{\n    union{\n        float v[3];\n        struct\n        {\n            float x;\n            float y;\n            float z;\n        };\n    };\n    float temperature; //celsius\n    int temperature_lsb;\n} HAL_gyro_SI_t;\n\n\n/**\n * \\struct _HAL_fifo_gyro_SI_t\n * \\brief Gyroscope data with SI unit (rad/s)\n */\ntypedef struct _HAL_fifo_gyro_SI_t\n{\n    union{\n        float v[3];\n        struct\n        {\n            float x;\n            float y;\n            float z;\n        };\n    };\n} HAL_fifo_gyro_SI_t;\n\n/**\n * \\struct _HAL_acc_SI_t\n * \\brief Accelerometer data with SI unit (m/s2)\n */\ntypedef struct _HAL_acc_SI_t\n{\n    union{\n        float v[3];\n        struct\n        {\n            float x;\n            float y;\n            float z;\n        };\n    };\n    float temperature; ///< Unit is Celsius\n} HAL_acc_SI_t;\n\n/**\n * \\struct _HAL_magn_mg_t\n * \\brief Magnetic data with mG unit\n */\ntypedef struct _HAL_magn_mG_t\n{\n    union{\n        float v[3];\n        struct\n        {\n            float x;\n            float y;\n            float z;\n        };\n    };\n} HAL_magn_mG_t;\n\n\n/**\n * \\struct _HAL_pressurePS_SI_t\n * \\brief Pressure data of pressure sensor with SI unit\n */\ntypedef struct _HAL_pressure_SI_t\n{\n    double __attribute__((aligned(8))) temperature; ///< Unit is Celsius\n    float pressure;  ///< Unit is Pascal\n} HAL_pressure_SI_t;\n\n\n/**\n * \\struct _HAL_vbat_SI_t\n * \\brief  Voltage of battery powering device\n */\ntypedef struct _HAL_vbat_SI_t\n{\n    float vbat_V; ///< Battery voltage (unit : Volt)\n    uint32_t vbat_percentage; ///< percentage of battery according of min and max of tension permitted\n#ifdef MAMBO\n    float ibat_A; ///< Battery current intensity (unit : Ampere)\n#endif\n} HAL_vbat_SI_t;\n\n#ifdef ROLLINGSPIDER\n/**\n * \\struct _HAL_etron_gpio_t\n * \\brief Etron Chip GPIOs\n */\ntypedef struct _HAL_etron_gpio_t\n{\n    int jump_half_load; ///< Input active high (inverted from HW)\n    int onoff_button; ///< Input active high (inverted from HW)\n    int charging; ///< Input active high\n    int charge_done;\n} HAL_etron_gpio_t;\n#endif\n\n#ifdef MAMBO\ntypedef struct _HAL_temperature_us_SI_t\n{\n    float vtemp_us_V; /**< Temperature US voltage (unit : Volt)\n    \t\t\t (-1: last read failed, NaN: No value yet) */\n    float temp_us; /**< Temperature US in celsius (NaN: No value yet) */\n} HAL_temperature_us_SI_t;\n#endif\n/**\n * Echo information\n * */\n#ifdef ROLLINGSPIDER\ntypedef struct _HAL_echo_t\n{\n    uint16_t begin_echo_index; ///<index of raw data corresponding to the beggining of the echo (begin_echo_index/ultrasound_frequency_acquisition = time)\n    uint16_t end_echo_index; ///<index of raw data corresponding to the end of the echo (end_echo_index/ultrasound_frequency_acquisition = time)\n    int16_t max_value_index; ///<index of max value of the echo\n    int32_t max_value; ///<Max value of the echo\n    uint16_t precedent; ///<Number \"id\" of the echo matched in precedent ADC_acquistion serie\n    int16_t d_echo; ///<Index difference between this echo and the echo matched in precedent ADC_acquisition serie\n    uint16_t pre_max_index; ///<Index of raw data corresponding to maw_value minus noise\n} HAL_echo_t;\n#endif\n\n#ifdef MAMBO\ntypedef struct _HAL_echo_t\n{\n    uint16_t begin_echo_index; ///<index of raw data corresponding to the beggining of the echo (begin_echo_index/ultrasound_frequency_acquisition = time)\n    uint16_t end_echo_index; ///<index of raw data corresponding to the end of the echo (end_echo_index/ultrasound_frequency_acquisition = time)\n    int16_t max_value_index; ///<index of max value of the echo\n    uint16_t precedent; ///<Number \"id\" of the echo matched in precedent ADC_acquistion serie\n    int16_t d_echo; ///<Index difference between this echo and the echo matched in precedent ADC_acquisition serie\n    uint16_t pre_max_index; ///<Index of raw data corresponding to maw_value minus noise\n    int32_t max_value; ///<Max value of the echo\n} HAL_echo_t;\n#endif\n/**\n * Array with echo found and number of echo found\n * */\ntypedef struct _HAL_list_echo_t\n{\n    HAL_echo_t tab_echo[MAX_ECHO]; ///<array with echo found\n    uint8_t number_of_echoes; ///<number of echoes found\n}HAL_list_echo_t;\n\nenum\n{\n    HAL_US_status_No_Measure = 0,   //  1\n    HAL_US_status_Inv_Data_number,  //  2\n    HAL_US_status_No_Echo_Init,     //  4\n    HAL_US_status_No_Echo,          //  8\n    HAL_US_status_No_Matching,      // 16\n};\n\n\ntypedef struct _HAL_ultrasound_SI_t\n{\n    float altitude; ///<Unit is meter\n    float raw_altitude;\n    uint16_t nb_echo;\n    int measure_ref;\n    int measure_status;\n    uint8_t new_data;\n    HAL_list_echo_t HAL_list_echo;\n        HAL_list_echo_t HAL_list_echo_p;\n} HAL_ultrasound_SI_t;\n\n\n/**\n * Information used for processing altitude\n * */\ntypedef struct _HAL_ultrasound_result_t\n{\n\n    HAL_list_echo_t list_echo[NB_TAB_ECHO]; ///<array of last NB_TAB_ECHO succession acquisition process\n    HAL_echo_t echo_altitude; ///<Echo chosen as \"real\" echo\n    uint8_t index_list_echo_used; ///<Index of element of list echo used\n    uint8_t index_last_list_echo_used; ///<Index of element of list used in last succession acquisition process\n    uint8_t nb_echoes; //number of elements of actual list echo\n    uint32_t sum_echo; ///<Value corresponding to area before ultrasound envelope\n    int32_t gradient; ///<Gradient when envelope reaches threshold curve\n}HAL_ultrasound_result_t;\n\n/**\n * USB plugged or not\n * */\ntypedef enum HAL_VBUS_state_t\n{\n    HAL_VBUS_ON = 0,\n    HAL_VBUS_OFF,\n} HAL_VBUS_state_t;\n\n/**\n * \\struct _HAL_acquisition_t\n * \\brief data result of data_format function\n */\n#ifdef ROLLINGSPIDER\ntypedef struct __attribute__((aligned(8))) _HAL_acquisition_t\n{\n    /*HAL_acquisition general information*/\n    int number_HAL_read_call; ///< number of HAL_read() call\n    int64_t timestamp; ///< timestamp corresponding to HAL_acquisition\n    status_t status; ///<bitfield indicating if a sensors have been updated>\n    uint8_t used; ///< indicating if HAL_acquisition is used or not\n    uint8_t count_user; ///< number of threads using this element\n\n    /* IMU data = acc/gyro on NONE-FIFO mode*/\n    HAL_acc_SI_t HAL_acc_SI; ///< accelerometer data    TODO REMOVE this\n    HAL_gyro_SI_t HAL_gyro_SI; ///< gyroscope data      TODO REMOVE this\n\n    /*IMU data = acc + gyro on FIFO mode*/\n    /*FIXME: please make a structure*/\n    uint16_t HAL_fifo_count;        ///< Raw fifo size in the MPU6050 (debug purpose only)\n    int64_t fifo_timestamp; ///< timestamp corresponding to the very last set of data read from fifo\n\n\n    HAL_fifo_gyro_SI_t HAL_fifo_gyro_SI_TempCorr[5];  ///< gyroscope temperature corrected data in FIFO\n    HAL_fifo_gyro_SI_t HAL_fifo_acce_SI_TempCorr[5];  ///< accelerometer temperature corrected data in FIFO\n    union\n    {\n        HAL_fifo_gyro_SI_t HAL_fifo_gyro_SI_Raw[5];  ///< gyroscope data in FIFO\n        HAL_fifo_gyro_SI_t HAL_fifo_gyro_SI[5]; ///< Fifo abstracter: pointer to choose between SI_Raw and SI_TempCorr\n    };\n    union\n    {\n        HAL_fifo_gyro_SI_t HAL_fifo_acce_SI_Raw[5];  ///< accelerometer data in FIFO\n        HAL_fifo_gyro_SI_t HAL_fifo_acce_SI[5]; ///< Fifo abstracter: pointer to choose between SI_Raw and SI_TempCorr\n    };\n\n    float HAL_ref_IMU_temp; ///< Desired IMU temperature\n    uint8_t HAL_fifo_fsync[5]; ///< imu fsync signal\n    int HAL_fifo_size;                     ///< Size of each array HAL_fifo_gyro_SI and HAL_fifo_acce_SI\n\n    /*Magnetometer data*/\n    HAL_magn_mG_t HAL_magn_mG; ///< magnetic data\n\n    /*Pressure data*/\n    HAL_pressure_SI_t HAL_pressure_SI; ///< pressure data\n\n    /*Ultrasound data*/\n    HAL_ultrasound_SI_t HAL_ultrasound_SI; ///< ultrasound data\n\n    uint8_t padding[52+144];\n\n    /*Battery data*/\n    HAL_vbat_SI_t HAL_vbat_SI; //Battery voltage value (unit : V)\n\n} HAL_acquisition_t;\n#endif\n\n#ifdef MAMBO\ntypedef struct __attribute__((aligned(8))) _HAL_acquisition_t\n{\n    /*HAL_acquisition general information*/\n    int number_HAL_read_call; ///< number of HAL_read() call\n    int64_t timestamp; ///< timestamp corresponding to HAL_acquisition\n    status_t status; ///<bitfield indicating if a sensors have been updated>\n    uint8_t used; ///< indicating if HAL_acquisition is used or not\n    uint8_t count_user; ///< number of threads using this element\n\n    /* IMU data = acc/gyro on NONE-FIFO mode*/\n    HAL_acc_SI_t HAL_acc_SI; ///< accelerometer data    TODO REMOVE this\n    HAL_gyro_SI_t HAL_gyro_SI; ///< gyroscope data      TODO REMOVE this\n\n    /*IMU data = acc + gyro on FIFO mode*/\n    /*FIXME: please make a structure*/\n    uint16_t HAL_fifo_count;        ///< Raw fifo size in the MPU6050 (debug purpose only)\n    int64_t fifo_timestamp; ///< timestamp corresponding to the very last set of data read from fifo\n    HAL_fifo_gyro_SI_t HAL_fifo_gyro_SI_Raw[5];  ///< gyroscope data in FIFO\n    HAL_fifo_gyro_SI_t HAL_fifo_acce_SI_Raw[5];  ///< accelerometer data in FIFO\n\n    HAL_fifo_gyro_SI_t HAL_fifo_gyro_SI_TempCorr[5];  ///< gyroscope temperature corrected data in FIFO\n    HAL_fifo_gyro_SI_t HAL_fifo_acce_SI_TempCorr[5];  ///< accelerometer temperature corrected data in FIFO\n\n    HAL_fifo_gyro_SI_t *HAL_fifo_gyro_SI; ///< Fifo abstracter: pointer to choose between SI_Raw and SI_TempCorr\n    HAL_fifo_gyro_SI_t *HAL_fifo_acce_SI; ///< Fifo abstracter: pointer to choose between SI_Raw and SI_TempCorr\n\n    float HAL_ref_IMU_temp; ///< Desired IMU temperature\n    uint8_t HAL_fifo_fsync[5]; ///< imu fsync signal\n    int HAL_fifo_size;                     ///< Size of each array HAL_fifo_gyro_SI and HAL_fifo_acce_SI\n\n    /*Magnetometer data*/\n    HAL_magn_mG_t HAL_magn_mG; ///< magnetic data\n\n    /*Pressure data*/\n    HAL_pressure_SI_t HAL_pressure_SI; ///< pressure data\n    HAL_pressure_SI_t HAL_pressure_SI_nose; ///< pressure data\n    /*Ultrasound data*/\n    HAL_ultrasound_SI_t HAL_ultrasound_SI; ///< ultrasound data\n\n    /*ADC data (not used on Mambo) */\n    uint8_t HAL_adc_jpsumo_results_padding[144]; ///< Jumping Sumo ADC datas\n\n    /* Not used on Mambo */\n    uint8_t HAL_BLDC_result_padding[64];\n\n    /*Battery data*/\n    HAL_vbat_SI_t HAL_vbat_SI; //Battery voltage value (unit : V)\n\n    /* Not used on Mambo*/\n    uint8_t jpsumo_gpios_padding[12]; /**< Jumping Sumo gpio inputs */\n    uint8_t HAL_gps_data_padding[792];\n\n    /* Remote control (not used on Mambo) */\n    uint8_t rc_padding[7];\n\n    /* Not used on Mambo */\n    uint32_t camif_id_field; ///< indicates if camif data is stocked\n    void* result_camif_tab_padding; ///<result camif\n\n    HAL_VBUS_state_t VBUS_state;\n\n    HAL_temperature_us_SI_t HAL_temperature_us_SI;\n\n} HAL_acquisition_t;\n\n#endif\n\n\n\ntypedef enum _HAL_ultrasound_command_t\n{\n    ULTRASOUND_CMD_NO_CMD=0,\n    ULTRASOUND_CMD_SET_MODE = 1,\n    ULTRASOUND_CMD_SET_NB_PULSES = 2,\n    ULTRASOUND_CMD_SET_VOLTAGE_MODE = 4,\n    ULTRASOUND_CMD_SET_NB_PULSES_AND_TENSION_MODE = 6,\n    ULTRASOUND_CMD_SET_FREQUENCY = 8,\n    ULTRASOUND_CMD_START = 16,\n    ULTRASOUND_CMD_STOP = 32,\n} HAL_ultrasound_command_t;\n\n#ifdef ROLLINGSPIDER\ntypedef enum _HAL_BLDC_motor_command_t\n{\n    BLDC_CMD_NO_CMD=0,\n    BLDC_CMD_START=1,\n    BLDC_CMD_STOP=2,\n    BLDC_CMD_RUN=3,\n    BLDC_CMD_CLEAR=4,\n    BLDC_CMD_REBOOT_BLDC=5,\n    BLDC_CMD_LED=6,\n} HAL_BLDC_motor_command_t;\n#endif\n\n#ifdef MAMBO\ntypedef enum _HAL_BLDC_motor_command_t\n{\n    BLDC_CMD_NO_CMD=0,\n    BLDC_CMD_START=1,\n    BLDC_CMD_STOP=2,\n    BLDC_CMD_RUN=3,\n    BLDC_CMD_REVERSE=4,\n    BLDC_CMD_CLEAR=5,\n    BLDC_CMD_REBOOT_BLDC=6,\n    BLDC_CMD_LED=7,\n} HAL_BLDC_motor_command_t;\n#endif\n\ntypedef struct _HAL_command_t\n{\n    HAL_BLDC_motor_command_t command;\n\n    int16_t* motors_speed;\n    uint8_t  enable_security;\n\n    int HAL_ultrasound_command;\n    uint8_t ultrasound_mode;\n    uint8_t nb_pulses;\n    uint8_t voltage_mode;\n    uint32_t acquisition_frequency_wanted;\n#ifdef ROLLINGSPIDER\n    // LEDs commands :\n    void* LEDs_cmds;\n    int32_t HAL_leds_command;\n#endif\n\n} HAL_command_t;\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif  // _HAL_H_"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE PARROT Mambo\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERSIZE 500\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS 192.168.3.1\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 1\n#define MW_CONNECTIONINFO_XCPONTCPIP_IPADDRESS 192.168.3.1\n#define MW_CONNECTIONINFO_XCPONTCPIP_PORT 17725\n#define MW_CONNECTIONINFO_XCPONTCPIP_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION TCP/IP\n#define MW_EXTMODE_RUNNING on\n#define MW_RTOS Baremetal\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_UI_LAUNCH 1\n#define MW_CONFIG_ENABLEPROFILING 0\n#define MW_CONFIG_ENABLEOPTICALFLOW 1\n#define MW_CONFIG_ENABLEIMAGEVISION 0\n#define MW_CONFIG_USEIMAGEVISIONFORPOSITION 0\n#define MW_CONFIG_USELOOKUP 0\n#define MW_CONFIG_NOSAFETY 1\n#define MW_CONFIG_ABORT 0\n#define MW_CONFIG_MAXACCELERATION 60\n#define MW_CONFIG_IMAGELOGGING 0\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 416\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"controlCommand.c","type":"source","group":"legacy","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"/*  @file: controlCommand.c\n *\n *  @description: This module responds to the requests received from the host over TCP.\n *\n */\n\n#include \"controlCommand.h\"\n#include <math.h>\n\nlong int sensorData[3] = {0}; // For storing the x,y,z sensor readings of accelerometer/ Gyroscope\nlong int motorSpeed[4] = {0}; // Motor speeds of all the four motors\nlong int batteryData[2] = {0}; // For storing the battery voltage and percentage of charge left\nlong int streamData[5] = {0}; // For storing the data from all drone sensors\nint ack = 1; // Acknowledgment for position and orientation control\n\n/* Variables to control the drone's landing sequence*/\ndouble current_height,step_height;\ndouble land_height = -0.5;\nextern int landDrone;\n\nvoid processRequest(int connfd,char *recvBuff,HAL_acquisition_t* in,HAL_command_t* out, CommandBus* keyboardServerCommands, int *run_flag)\n{\n\n    if ((recvBuff[0]) != '\\0') {\n\n        switch (recvBuff[0]) {\n          case startFlight:\n            /* Take off command */\n            if (1 != isMotorOn) {\n                isMotorOn = 1;\n                printf(\" TakeOff Sequence Initiated !! \\n\");\n                throttle = *((int*)&recvBuff[4]); // Power Gain (1-100)\n                if ((recvBuff[8]) != '\\0') {\n                    flightDuration = *((int*)&recvBuff[8]); // Flight duration in seconds\n                    printf(\"The flight duration is set to = %d seconds and powergain is set to = %d\\n\", flightDuration,throttle);\n                }\n                else\n                {\n                    /* Use Simulation stop time if flight duration is not provided by user. */\n                    flightDuration = STOP_TIME;\n                    printf(\"The flight duration is set to Simulation Stop Time of = %d seconds and powergain is set to = %d\\n\", flightDuration,throttle);\n                }\n                wrStatus = write(connfd,&(ack),sizeof(ack));\n            }\n            break;\n          case stopFlight:\n            /* Soft Land the drone */\n            if (0 != isMotorOn) {\n                printf(\" Landing Sequence Initiated !! \\n\");\n                //isLanding = 1;\n                landDrone = 1; //Set the landing flag.\n                wrStatus = write(connfd,&(ack),sizeof(ack)); //Send ack to the host app\n            }\n            break;\n\n          case emergencyStop:\n            /* Shut down drone motors */\n            printf(\" Emergency Landing Sequence Initiated !! \\n\");\n            isMotorOn = 0;\n            *run_flag = 0 ; \n            break;\n\n          case getAccelData:\n            /* Read acceleration of drone in m/s^2*/\n            printf(\"ACCELEROMETER DATA: X: %5.3f s^2 - Y: %5.3f s^2 - Z: %5.3f s^2 \\n\",in->HAL_acc_SI.x,in->HAL_acc_SI.y,in->HAL_acc_SI.z);\n            sensorData[0] = in->HAL_acc_SI.x*100;\n            sensorData[1] = in->HAL_acc_SI.y*100;\n            sensorData[2] = in->HAL_acc_SI.z*100;\n            wrStatus = write(connfd,sensorData,sizeof(sensorData));\n            break;\n\n          case getGyroData:\n            /* Read Angular Velocity in rad/s*/\n            printf(\"GYROSCOPE DATA: X: %5.2f rad/s - Y: %5.2f rad/s - Z: %5.2f rad/s \\n\",in->HAL_gyro_SI.x,in->HAL_gyro_SI.y,in->HAL_gyro_SI.z);\n            sensorData[0] = in->HAL_gyro_SI.x*100;\n            sensorData[1] = in->HAL_gyro_SI.y*100;\n            sensorData[2] = in->HAL_gyro_SI.z*100;\n            wrStatus = write(connfd,sensorData,sizeof(sensorData));\n            break;\n\n          case getMagnetoData:\n            /* Read magnetic field in mT*/\n            printf(\"MAGNETOMETER DATA: X: %5.2f mG - Y: %5.2f mG - Z: %5.2f mG \\n\",in->HAL_magn_mG.x,in->HAL_magn_mG.y,in->HAL_magn_mG.z);\n            sensorData[0] = in->HAL_magn_mG.x*100;\n            sensorData[1] = in->HAL_magn_mG.y*100;\n            sensorData[2] = in->HAL_magn_mG.z*100;\n            wrStatus = write(connfd,sensorData,sizeof(sensorData));\n            break;\n\n          case getAltitude:\n            /* Read the altitude seen by the Ultrasound sensor of the drone*/\n            printf(\"ALTITUDE: X: %5.2f m \\n\",in->HAL_ultrasound_SI.altitude);\n            altitude = in->HAL_ultrasound_SI.altitude*100;\n            wrStatus = write(connfd,&(altitude),sizeof(altitude));\n            break;\n\n          case getPressure:\n            /* Read atmospheric pressure in Pascals*/\n            printf(\"PRESSURE: %5.2f pascal \\n\",in->HAL_pressure_SI.pressure);\n            pressure = in->HAL_pressure_SI.pressure*100;\n            wrStatus = write(connfd,&(pressure),sizeof(pressure));\n            break;\n\n          case getBatteryData:\n            /* Read battery Voltage and percentage of charge left in the battery */\n            printf(\"VOLTAGE: %5.2f V - %0d percents\\n\", in->HAL_vbat_SI.vbat_V,(int)in->HAL_vbat_SI.vbat_percentage);\n            batteryData[0] = in->HAL_vbat_SI.vbat_V*100;\n            batteryData[1] = in->HAL_vbat_SI.vbat_percentage*100;\n            wrStatus = write(connfd,batteryData,sizeof(batteryData));\n            break;\n\n          case readSensor:\n            /* Read the sensor readings from Accelerometer, Gyroscope, Pressure and Ultrasound sensor*/\n            streamData[0] = in->HAL_acc_SI.x*100;\n            streamData[1] = in->HAL_acc_SI.y*100;\n            streamData[2] = in->HAL_acc_SI.z*100;\n            streamData[3] = in->HAL_pressure_SI.pressure*100;\n            streamData[4] = in->HAL_ultrasound_SI.altitude*100;\n            wrStatus = write(connfd,streamData,sizeof(streamData));\n            break;\n\n          case setPitch:\n            /*  Set Pitch angle of minidrone in radians */\n            pitch_ref_buff = *((int*)&recvBuff[4]);\n            keyboardServerCommands->orient_ref[1] = (double)((pitch_ref_buff - 10000) / 1000.0);\n            wrStatus = write(connfd,&(ack),sizeof(ack));\n            break;\n\n          case setRoll:\n            /*  Set Roll angle of minidrone in radians */\n            roll_ref_buff = *((int*)&recvBuff[4]);\n            keyboardServerCommands->orient_ref[2] = (double)((roll_ref_buff - 10000) / 1000.0);\n            wrStatus = write(connfd,&(ack),sizeof(ack));\n            break;\n\n          case setYaw:\n            /*  Set Yaw angle of minidrone in radians*/\n            yaw_ref_buff = *((int*)&recvBuff[4]);\n            keyboardServerCommands->orient_ref[0] = (double)((yaw_ref_buff - 10000) / 1000.0);\n            printf(\"Yaw updated to: %f\\n\",keyboardServerCommands->orient_ref[0]);\n            wrStatus = write(connfd,&(ack),sizeof(ack));\n            break;\n\n          case updateZPosition:\n            /*  Set Altitude of minidrone in meters*/\n            z_ref_buff = *((int*)&recvBuff[4]);\n            if (((double)(z_ref_buff / 100.0)) >= -4.0) {\n                keyboardServerCommands->pos_ref[2] = (double)(z_ref_buff / 100.0);\n            }\n            printf(\"Z updated to: %f\\n\",keyboardServerCommands->pos_ref[2]);\n            wrStatus = write(connfd,&(ack),sizeof(ack));\n            break;\n\n          case updateXYPosition:\n            /* Move the drone to the desired coordinate position*/\n            x_ref_buff = *((int*)&recvBuff[4]);\n            y_ref_buff = *((int*)&recvBuff[8]);\n            printf(\"X: %f Y: %f \\n\",x_ref_buff/100.0,y_ref_buff/100.0);\n            keyboardServerCommands->pos_ref[0] = (double)(x_ref_buff / 100.0);\n            keyboardServerCommands->pos_ref[1] = (double)(y_ref_buff / 100.0);\n            wrStatus = write(connfd,&(ack),sizeof(ack));\n            break;\n\n          case enableImageCapture:\n            /* Set flag to enable image capture in the image processing thread (rsedu_vis.c) */\n            capture = 1;\n            printf(\" Capturing Image \\n\");\n            break;\n\n          default:\n            printf(\" Invalid Request !! \\n\");\n        }\n    }\n\n}\n"},{"name":"ext_svr.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2021 The MathWorks, Inc.\n *\n * File: ext_svr.c     \n *\n * Abstract:\n *  External mode server interface (TCPIP example).  Provides functions\n *  that get called by main routine (model-name.c):\n *    o ExtParseArgsAndInitUD:  parse args and create UserData\n *    o ExtWaitForStartPkt:     return true if waiting for host to start\n *    o rt_ExtModeInit:         external mode initialization\n *    o rt_ExtModeSleep:        pause the process\n *    o rt_PktServerWork:       server for setting/getting packets from host\n *    o rt_PktServer:           server dispatcher - for multi-tasking targets\n *    o rt_UploadServerWork:    server for setting data upload packets on host\n *    o rt_UploadServer:        server dispatcher - for multi-tasking targets\n *    o rt_ExtModeShutdown:     external mode termination\n *\n *  Parameter downloading and data uploading supported for single and\n *  multi-tasking targets.\n */\n\n/*****************\n * Include files *\n *****************/\n\n/*ANSI C headers*/\n#ifndef EXTMODE_DISABLEPRINTF  \n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(VXWORKS)\n /*VxWorks headers*/\n# include <selectLib.h>\n# include <sockLib.h>\n# include <inetLib.h>\n# include <ioLib.h>\n# include <taskLib.h>\n#endif\n\n/*Real Time Workshop headers*/\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"rtw_extmode.h\"\n\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"ext_test.h\"\n#include \"ext_svr_transport.h\"\n#include \"updown.h\"\n#include \"updown_util.h\"\n#include \"dt_info.h\"\n\n\n/*Uncomment to test 4 byte reals*/\n/*#define real_T float*/\n\n/***********************\n * Logical definitions *\n ***********************/\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/**********************\n * External Variables *\n **********************/\nextern int_T           volatile startModel;\nextern TargetSimStatus volatile modelStatus;\n#ifdef VXWORKS\nextern SEM_ID uploadSem;\nextern SEM_ID pktSem;\n#endif\nextern boolean_T host_upstatus_is_uploading;\n\n/********************\n * Global Variables *\n ********************/\n\n/*\n * Flags.\n */\nPRIVATE boolean_T   connected       = false;\nPRIVATE boolean_T   commInitialized = false;\nboolean_T gblSetParamPktReceived = false;\n\n/*\n * Pointer to opaque user data (defined by ext_svr_transport.c).\n */\nPRIVATE ExtUserData *extUD          = NULL;\n\n/*\n * Buffer used to receive packets.\n */\nPRIVATE int_T pktBufSize = 0;\nPRIVATE char  *pktBuf    = NULL;\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n#ifndef EXTMODE_DISABLEPRINTF \nPRIVATE char ERRMSG_PROCESSSELECTSIGNAL[] = \n            \"\\nError in UploadLogInfoInit(). Most likely a memory\\n\"\n            \"allocation error or an attempt to re-initialize the\\n\"\n            \"signal selection during the data logging process\\n\"\n            \"(i.e., multiple EXT_SELECT_SIGNAL packets were received\\n\"\n            \"before the logging session terminated or an\\n\"\n            \"EXT_CANCEL_LOGGING packet was received)\\n\";\n\nPRIVATE char ERRMSG_PROCESSSELECTTRIGGER[] = \n            \"\\nError in UploadInitTrigger(). Most likely a memory\\n\"\n            \"allocation error or an attempt to re-initialize the\\n\"\n            \"trigger selection during the data logging process\\n\"\n            \"(i.e., multiple EXT_SELECT_TRIGGER packets were received\\n\"\n            \"before the logging session terminated or an\\n\"\n            \"EXT_CANCEL_LOGGING packet was received)\\n\";\n#else\nPRIVATE char ERRMSG_PROCESSSELECTSIGNAL[] = \"\";\nPRIVATE char ERRMSG_PROCESSSELECTTRIGGER[] = \"\";\n#endif\n#endif\n\n/********************\n *  If DAEMON_MODE  *\n ********************/\n#ifdef DAEMON_MODE\n/*\n * This defines the size of each data chunk (in bytes) that the\n * daemon acknowledgment scheme uses for large data\n */\nconst int_T daemonChunkSize = 32;\n#endif\n\nPRIVATE boolean_T SendPktHdrToHost(const ExtModeAction action,\n                                         const int size);\n\n/*******************\n * Local Functions *\n *******************/\n\n/* Function: GrowRecvBufIfNeeded ===============================================\n * Abstract:\n *  Allocate or increase the size of buffer for receiving packets from target.\n */\nPRIVATE boolean_T GrowRecvBufIfNeeded(const int pktSize)\n{\n    if (pktSize > pktBufSize) {\n        if (pktBuf != NULL) {\n            free(pktBuf);\n            pktBufSize = 0;\n        }\n\n        pktBuf = (char *)malloc(pktSize);\n        if (pktBuf == NULL) return(EXT_ERROR);\n\n        pktBufSize = pktSize;\n    }\n    return(EXT_NO_ERROR);\n} /* end GrowRecvBufIfNeeded */\n\n\n/* Function: GetPktHdr =========================================================\n * Abstract:\n *  Attempts to retrieve a packet header from the host.  If a header is in \n *  fact retrieved, the reference arg, 'hdrAvail' will be returned as true.\n *\n *  EXT_NO_ERROR is returned on success, EXT_ERROR is returned on failure.\n *\n * NOTES:\n *  o It is not necessarily an error for 'hdrAvail' to be returned as false.\n *    It typically means that we were polling for packets and none were\n *    available.\n */\nPRIVATE boolean_T GetPktHdr(PktHeader *pktHdr, boolean_T *hdrAvail)\n{\n    int_T     nGot      = 0; /* assume */\n    int_T     nGotTotal = 0;\n    int_T     pktSize   = sizeof(PktHeader);\n    boolean_T error     = EXT_NO_ERROR;\n    \n    /* Get the header. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD,\n            pktSize - nGotTotal, &nGot, (char_T *)((char_T *)pktHdr + nGotTotal));\n        if (error) goto EXIT_POINT;\n\n        nGotTotal += nGot;\n\n        if (nGotTotal == 0) break;\n    }\n    assert((nGot == 0) || (nGotTotal == pktSize));\n\nEXIT_POINT:\n    *hdrAvail = (boolean_T)(nGot > 0);\n    return(error);\n} /* end GetPktHdr */\n\n\n/* Function: ClearPkt ==========================================================\n * Abstract:\n *  Remove the data from the communication line one byte at a time.  This\n *  function is called when there was not enough memory to receive an entire\n *  packet.  Since the data was never received, it must be discarded so that\n *  other packets can be sent.\n */\nPRIVATE void ClearPkt(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    char      buffer;\n\n    /* Get and discard the data one char at a time. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD, 1, &nGot, (char_T *)&buffer);\n        if (error) {\n#ifndef EXTMODE_DISABLEPRINTF            \n            fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n        }\n        nGotTotal += nGot;\n    }\n\nEXIT_POINT:\n    return;\n\n} /* end ClearPkt */\n\n#ifdef DAEMON_MODE\n/* Function: ClearPktUsingAck ==================================================\n * Abstract:\n *  Derived from ClearPkt(). For the general behaviour see ClearPkt() above.\n *  This variant is used by DAEMON_MODE to clear data in small chunks.\n *  After receiving each chunk reply with a EXT_DAEMON_ACK.\n */\nPRIVATE void ClearPktUsingAck(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    char      buffer;\n    \n    int_T     i;\n    int_T     nChunks   = pktSize/daemonChunkSize;\n    int_T     bytesLeft = pktSize%daemonChunkSize;\n\n    /* Get and discard the data one char at a time.\n\t * Receive chunks here, and reply with ack after receiving each chunk\n\t */\n    for(i=0; i<nChunks; i++){\n        nGotTotal = 0;\n        while(nGotTotal < daemonChunkSize){\n            error = ExtGetHostPkt(extUD,\n                        1,\n                        &nGot,\n                        (char_T *)&buffer);\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n            nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n    \n    /*\n\t * Receive the bytes left over and reply with an ack after you receive all\n\t */\n    nGotTotal=0;\n    if(bytesLeft != 0){\n        while(nGotTotal<bytesLeft){\n            error = ExtGetHostPkt(extUD,\n                        1,\n                        &nGot,\n                        (char_T *)&buffer);\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n        nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n\nEXIT_POINT:\n    return;\n\n} /* end ClearPktUsingAck */\n#endif\n\n\n/* Function: GetPkt ============================================================\n * Abstract:\n *  Receive nBytes from the host.  Return a buffer containing the bytes or\n *  NULL if an error occurs.  Note that the pointer returned is that of the\n *  global pktBuf.  If the buf needs to be grown to accommodate the package,\n *  it is realloc'd.  This function will try to get the requested number\n *  of bytes indefinitely - it is assumed that the data is either already there,\n *  or will show up in a \"reasonable\" amount of time.\n */\nPRIVATE const char *GetPkt(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n\n    error = GrowRecvBufIfNeeded(pktSize);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"Previous pkt from host thrown away due to lack of memory.\\n\");\n#endif\n        ClearPkt(pktSize);\n        goto EXIT_POINT;\n    }\n    \n    /* Get the data. */\n    while(nGotTotal < pktSize) {\n        error = ExtGetHostPkt(extUD,\n            pktSize - nGotTotal, &nGot, (char_T *)(pktBuf + nGotTotal));\n        if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n        }\n\n    nGotTotal += nGot;\n    }\n\nEXIT_POINT:\n    return((error == EXT_NO_ERROR) ? pktBuf : NULL);\n} /* end GetPkt */\n\n#ifdef DAEMON_MODE\n/* Function: GetPktUsingAck ============================================================\n * Abstract:\n *  Derived from GetPkt(). For the general behaviour see GetPkt() above.\n *  This variant is used by DAEMON_MODE to fetch data in small chunks.\n *  After receiving each chunk reply with a EXT_DAEMON_ACK.\n */\nPRIVATE const char *GetPktUsingAck(const int pktSize)\n{\n    int_T     nGot;\n    boolean_T error     = EXT_NO_ERROR;\n    int_T     nGotTotal = 0;\n    \n    int_T     i;\n    int_T     nChunks   = pktSize/daemonChunkSize;\n    int_T     bytesLeft = pktSize%daemonChunkSize;\n\n    error = GrowRecvBufIfNeeded(pktSize);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"Previous pkt from host thrown away due to lack of memory.\\n\");\n#endif\n        ClearPktUsingAck(pktSize);\n        goto EXIT_POINT;\n    }\n    \n    /*\n\t * Receive chunks here, and reply with ack after receiving each chunk\n\t */\n    for(i=0; i<nChunks; i++){\n        nGotTotal = 0;\n        while(nGotTotal < daemonChunkSize){\n            error = ExtGetHostPkt(extUD,\n                        daemonChunkSize - nGotTotal,\n                        &nGot,\n                        (char_T *)(pktBuf + i*daemonChunkSize + nGotTotal));\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n            goto EXIT_POINT;\n            }\n            nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n    \n    /*\n\t * Receive the bytes left over and reply with an ack after you receive all\n\t */\n    nGotTotal=0;\n    if(bytesLeft != 0){\n        while(nGotTotal<bytesLeft){\n            error = ExtGetHostPkt(extUD,\n                        bytesLeft - nGotTotal,\n                        &nGot,\n                        (char_T *)(pktBuf + i*daemonChunkSize + nGotTotal));\n            if (error) {\n#ifndef EXTMODE_DISABLEPRINTF                \n                fprintf(stderr,\"ExtGetHostPkt() failed.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n        nGotTotal += nGot;\n        }\n        SendPktHdrToHost(EXT_DAEMON_ACK, 0);\n    }\n\nEXIT_POINT:\n    return((error == EXT_NO_ERROR) ? pktBuf : NULL);\n} /* end GetPktUsingAck */\n#endif\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Forward declaration */\nvoid UploadServerWork(int32_T, int_T numSampTimes);\n#endif\n\n/* Function: DisconnectFromHost ================================================\n * Abstract:\n *  Disconnect from the host.\n */\nPRIVATE void DisconnectFromHost(int_T numSampTimes)\n{\n    int i;\n    boolean_T upload_signals = host_upstatus_is_uploading;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadPrepareForFinalFlush(i);\n\n#if defined(VXWORKS)\n        /*\n         * UploadPrepareForFinalFlush() has already called semGive(uploadSem)\n         * two times.  Now the server thread will wait until the upload thread\n         * has processed all of the data in the buffers for the final upload\n         * and exhausted the uploadSem semaphores.  If the server thread\n         * attempts to call UploadServerWork() while the upload thread is in\n         * the middle of processing the buffers, the target code may crash\n         * with a NULL pointer exception (the buffers are destroyed after\n         * calling UploadLogInfoTerm).\n         */\n        while(semTake(uploadSem, NO_WAIT) != ERROR) {\n            semGive(uploadSem);\n            taskDelay(1000);\n        }\n#else\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        if (upload_signals) {\n            UploadServerWork(i, numSampTimes);\n        }\n#endif\n#endif\n\n        UploadLogInfoTerm(i, numSampTimes);\n    }\n    \n    connected       = false;\n    commInitialized = false;\n    \n    ExtCloseConnection(extUD);\n} /* end DisconnectFromHost */\n\n\n/* Function: ForceDisconnectFromHost ===========================================\n * Abstract:\n *  Force a disconnect from the host.  This is not a graceful shutdown and\n *  should only be used when the integrity of the external mode connection\n *  is in question.  To shutdown the connection gracefully, use\n *  DisconnectFromHost().\n */\nPRIVATE void ForceDisconnectFromHost(int_T numSampTimes)\n{\n    int i;\n    connected       = false;\n    commInitialized = false;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadEndLoggingSession(i, numSampTimes);\n    }\n\n    ExtForceDisconnect(extUD);\n} /* end ForceDisconnectFromHost */\n\n\n/* Function: ProcessConnectPkt =================================================\n * Abstract:\n *  Process the EXT_CONNECT packet and send response to host.\n */\nPRIVATE boolean_T ProcessConnectPkt(RTWExtModeInfo *ei)\n{\n    int_T                   nSet;\n    PktHeader               pktHdr;\n    int_T                   tmpBufSize;\n    uint32_T                *tmpBuf = NULL;\n    boolean_T               error   = EXT_NO_ERROR;\n    \n    const DataTypeTransInfo *dtInfo    = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    uint_T                  *dtSizes   = dtGetDataTypeSizes(dtInfo);\n    int_T                   nDataTypes = dtGetNumDataTypes(dtInfo);\n\n    assert(connected);\n    assert(!commInitialized);\n\n    /*\n     * Send the 1st of two EXT_CONNECT_RESPONSE packets to the host. \n     * The packet consists purely of the pktHeader.  In this special\n     * case the pktSize actually contains the number of bits per byte\n     * (not always 8 - see TI compiler for C30 and C40).\n     */\n    pktHdr.type = (uint32_T)EXT_CONNECT_RESPONSE;\n    pktHdr.size = (uint32_T)8; /* 8 bits per byte */\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed for 1st EXT_CONNECT_RESPONSE.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\n    /* Send 2nd EXT_CONNECT_RESPONSE packet containing the following \n     * fields:\n     *\n     * CS1 - checksum 1 (uint32_T)\n     * CS2 - checksum 2 (uint32_T)\n     * CS3 - checksum 3 (uint32_T)\n     * CS4 - checksum 4 (uint32_T)\n     *\n     * intCodeOnly   - flag indicating if target is integer only (uint32_T)\n     * \n     * MWChunkSize   - multiword data type chunk size on target (uint32_T)\n     * \n     * targetStatus  - the status of the target (uint32_T)\n     *\n     * nDataTypes    - # of data types        (uint32_T)\n     * dataTypeSizes - 1 per nDataTypes       (uint32_T[])\n     */\n\n    {\n        int nPktEls    = 4 +                        /* checkSums       */\n                         1 +                        /* intCodeOnly     */\n                         1 +                        /* MW chunk size   */\n                         1 +                        /* targetStatus    */\n                         1 +                        /* nDataTypes      */\n                         dtGetNumDataTypes(dtInfo); /* data type sizes */\n\n        tmpBufSize = nPktEls * sizeof(uint32_T);\n        tmpBuf     = (uint32_T *)malloc(tmpBufSize);\n        if (tmpBuf == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    }\n    \n    /* Send packet header. */\n    pktHdr.type = EXT_CONNECT_RESPONSE;\n    pktHdr.size = tmpBufSize;\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed for 2nd EXT_CONNECT_RESPONSE.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n   \n    /* Checksums, target status & SL_DOUBLESize. */\n    tmpBuf[0] = rteiGetChecksum0(ei);\n    tmpBuf[1] = rteiGetChecksum1(ei);\n    tmpBuf[2] = rteiGetChecksum2(ei);\n    tmpBuf[3] = rteiGetChecksum3(ei);\n\n#if INTEGER_CODE == 0\n    tmpBuf[4] = (uint32_T)0;\n#else\n    tmpBuf[4] = (uint32_T)1;\n#endif\n\n    tmpBuf[5] = (uint32_T)sizeof(uchunk_T);\n    \n    tmpBuf[6] = (uint32_T)modelStatus;\n\n    /* nDataTypes and dataTypeSizes */\n    {        \n        int i;\n        tmpBuf[7] = (uint32_T)nDataTypes;\n        for (i=0; i<nDataTypes; i++) {\n            tmpBuf[8+i] = (uint32_T)dtSizes[i];\n        }\n    }\n    \n    /* Send the packet. */\n    error = ExtSetHostPkt(extUD,tmpBufSize,(char_T *)tmpBuf,&nSet);\n    if (error || (nSet != tmpBufSize)) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\n            \"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\n    commInitialized = true;\n\nEXIT_POINT:\n    free(tmpBuf);\n    return(error);\n} /* end ProcessConnectPkt */\n\n\n/* Function: SendPktHdrToHost ==================================================\n * Abstract:\n *  Send a packet header to the host.\n */\nPRIVATE boolean_T SendPktHdrToHost(\n    const ExtModeAction action,\n    const int           size)  /* # of bytes to follow pkt header */\n{\n    int_T     nSet;\n    PktHeader pktHdr;\n    boolean_T error = EXT_NO_ERROR;\n\n    pktHdr.type = (uint32_T)action;\n    pktHdr.size = size;\n\n    error = ExtSetHostPkt(extUD,sizeof(pktHdr),(char_T *)&pktHdr,&nSet);\n    if (error || (nSet != sizeof(pktHdr))) {\n        error = EXT_ERROR;\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end SendPktHdrToHost */\n\n\n/* Function: SendPktDataToHost =================================================\n * Abstract:\n *  Send packet data to host. You are responsible for sending a header\n *  prior to sending the header.\n */\nPRIVATE boolean_T SendPktDataToHost(const char *data, const int size)\n{\n    int_T     nSet;\n    boolean_T error = EXT_NO_ERROR;\n\n    error = ExtSetHostPkt(extUD,size,data,&nSet);\n    if (error || (nSet != size)) {\n        error = EXT_ERROR;\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"ExtSetHostPkt() failed.\\n\");\n#endif\n        goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end SendPktDataToHost */\n\n\n/* Function: SendPktToHost =====================================================\n * Abstract:\n *  Send a packet to the host.  Packets can be of two forms:\n *      o packet header only\n *          the type is used as a flag to notify Simulink of an event\n *          that has taken place on the target (event == action == type)\n *      o pkt header, followed by data\n */\nPUBLIC boolean_T SendPktToHost(\n    const ExtModeAction action,\n    const int           size,  /* # of bytes to follow pkt header */\n    const char          *data)\n{\n    boolean_T error = EXT_NO_ERROR;\n    \n#ifdef VXWORKS\n    semTake(pktSem, WAIT_FOREVER);\n#endif\n\n    error = SendPktHdrToHost(action,size);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    if (data != NULL) {\n        error = SendPktDataToHost(data, size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    } else {\n        assert(size == 0);\n    }\n\nEXIT_POINT:\n#ifdef VXWORKS\n    semGive(pktSem);\n#endif\n    return(error);\n} /* end SendPktToHost */\n\n\n/* Function:  SendResponseStatus ===============================================\n *  \n */\nPRIVATE boolean_T SendResponseStatus(const ExtModeAction  response,\n                                     const ResponseStatus status,\n                                     int32_T upInfoIdx)\n{\n    int32_T   msg[2];\n    boolean_T error = EXT_NO_ERROR;\n\n    msg[0] = (int32_T)status;\n    msg[1] = upInfoIdx;\n\n    error = SendPktToHost(response,2*sizeof(int32_T),(char_T *)&msg);\n    return(error);\n\n} /* end SendResponseStatus */\n\n\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n/* Function: ProcessSetParamPkt ================================================\n * Receive and process the EXT_SETPARAM packet.\n */\nPRIVATE boolean_T ProcessSetParamPkt(RTWExtModeInfo *ei,\n                                     const int pktSize)\n{\n    int32_T    msg;\n    const char *pkt;\n    boolean_T  error = EXT_NO_ERROR;\n\n    /*\n     * Receive packet and set parameters.\n     */\n    \n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        msg = (int32_T)NOT_ENOUGH_MEMORY;\n        SendPktToHost(EXT_SETPARAM_RESPONSE,sizeof(int32_T),(char_T *)&msg);\n        error = EXT_ERROR; \n        goto EXIT_POINT;\n    }\n    SetParam(ei, pkt);\n\n    msg = (int32_T)STATUS_OK;\n    error = SendPktToHost(EXT_SETPARAM_RESPONSE,sizeof(int32_T),(char_T *)&msg);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\nEXIT_POINT:\n    return(error);\n} /* end ProcessSetParamPkt */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n#ifndef EXTMODE_DISABLEPARAMETERTUNING \n/* Function: ProcessGetParamsPkt ===============================================\n *  Respond to the hosts request for the parameters by gathering up all the\n *  params and sending them to the host.\n */\nPRIVATE boolean_T ProcessGetParamsPkt(RTWExtModeInfo *ei)\n{\n    int_T                         i;\n    int_T                         nBytesTotal;\n    boolean_T                     error    = EXT_NO_ERROR;\n    const DataTypeTransInfo       *dtInfo  = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetParamDataTypeTrans(dtInfo);\n\n    if (dtTable != NULL) {\n        /*\n         * We've got some params in the model.  Send their values to the\n         * host.\n         */\n        int_T        nTrans   = dtGetNumTransitions(dtTable);\n        const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n\n #ifdef VERBOSE\n    #ifndef EXTMODE_DISABLEPRINTF             \n        printf(\"\\nUploading initial parameters....\\n\");\n #endif\n#endif \n\n        /*\n         * Take pass 1 through the transitions to figure out how many\n         * bytes we're going to send.\n         */\n        nBytesTotal = 0;\n        for (i=0; i<nTrans; i++) {\n            int_T dt     = dtTransGetDataType(dtTable, i);\n            int_T dtSize = dtSizes[dt];\n            int_T nEls   = dtTransNEls(dtTable, i); /* complexity accounted for in trans tbl num of els */\n            int_T nBytes = dtSize * nEls;\n\n            nBytesTotal += nBytes;\n        }\n\n        /*\n         * Send the packet header.\n         */\n        error = SendPktHdrToHost(EXT_GETPARAMS_RESPONSE,nBytesTotal);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        /*\n         * Take pass 2 through the transitions and send the parameters.\n         */\n        for (i=0; i<nTrans; i++) {\n            char_T *tranAddress  = dtTransGetAddress(dtTable, i);\n            int_T  dt            = dtTransGetDataType(dtTable, i);\n            int_T  dtSize        = dtSizes[dt];\n            int_T  nEls          = dtTransNEls(dtTable, i); /* complexity accounted for in trans tbl num of els */\n            int_T  nBytes        = dtSize * nEls;\n\n            error = SendPktDataToHost(tranAddress, nBytes);\n            if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        }\n    } else {\n        /*\n         * We've got no params in the model.\n         */\n        error = SendPktHdrToHost(EXT_GETPARAMS_RESPONSE,0);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    return(error);\n} /* end ProcessGetParamsPkt */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: ProcessSelectTriggerSignalPkt ===========================================\n * Receive and process the EXT_SELECT_TRIGGER or EXT_SELECT_SIGNALS packet.\n */\nPRIVATE boolean_T ProcessSelectTriggerSignalPkt(const ExtModeAction ACTION_ID, \n                                                RTWExtModeInfo *ei,\n                                                const int pktSize,\n                                                int_T numSampTimes,\n                                                char* errMsg)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, -1);\n        return(EXT_ERROR);\n    }\n\n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T)); /* Extract upInfoIdx */\n    switch(ACTION_ID) {\n    case EXT_SELECT_TRIGGER_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF  \n        PRINT_VERBOSE(\n                    (\"got EXT_SELECT_TRIGGER packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        error = UploadInitTrigger(ei, pkt+sizeof(int32_T), upInfoIdx);\n        break;\n    case EXT_SELECT_SIGNALS_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF  \n        PRINT_VERBOSE(\n                    (\"got EXT_SELECT_SIGNALS packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        error = UploadLogInfoInit(ei, numSampTimes, pkt+sizeof(int32_T), upInfoIdx);\n        break;\n    default:\n        break;\n    }\n\n    if (error != EXT_NO_ERROR) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, upInfoIdx);\n#ifndef EXTMODE_DISABLEPRINTF            \n        printf(\"%s\\n\", errMsg);\n#endif\n        return(error);\n    }\n\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error); /* Can be EXT_NO_ERROR */\n} /* end ProcessSelectTriggerSignalPkt */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: ProcessCancelLoggingArmTriggerPkt ===========================================\n * Receive and process the EXT_CANCEL_LOGGING or EXT_ARM_TRIGGER packet.\n */\nPRIVATE boolean_T ProcessCancelLoggingArmTriggerPkt(const ExtModeAction ACTION_ID, \n                        const int pktSize, \n                        int_T numSampTimes)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n#ifdef DAEMON_MODE\n    pkt = GetPktUsingAck(pktSize);\n#else\n    pkt = GetPkt(pktSize);\n#endif\n\n    if (pkt == NULL) {\n        SendResponseStatus(ACTION_ID, NOT_ENOUGH_MEMORY, -1);\n        return(EXT_ERROR);\n    }\n            \n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T)); /* Extract upInfoIdx */\n        \n    switch(ACTION_ID) {\n    case EXT_CANCEL_LOGGING_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF   \n        PRINT_VERBOSE(\n                (\"got EXT_CANCEL_LOGGING packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        UploadCancelLogging(upInfoIdx);\n        break;\n    case EXT_ARM_TRIGGER_RESPONSE:\n#ifndef EXTMODE_DISABLEPRINTF\n        PRINT_VERBOSE(\n                (\"got EXT_ARM_TRIGGER packet for upInfoIdx : %d\\n\", upInfoIdx));\n#endif\n        UploadArmTrigger(upInfoIdx, numSampTimes);\n        break;\n    default:\n        break;\n    }\n\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error); /* Can be EXT_NO_ERROR */\n} /* end ProcessCancelLoggingArmTriggerPkt */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n#ifdef EXTMODE_DISABLEPARAMETERTUNING\nPRIVATE boolean_T AcknowledgeSetParamPkt(const int pktSize)\n{\n    int32_T    msg;\n    const char *pkt;\n    boolean_T  error = EXT_NO_ERROR;\n\n    pkt = GetPkt(pktSize);\n    msg = (int32_T)STATUS_OK;\n    error = SendPktToHost(EXT_SETPARAM_RESPONSE, sizeof(int32_T), (char_T *)&msg);\n    return(error);\n}\n#endif /* ifdef EXTMODE_DISABLEPARAMETERTUNING */\n\n#ifdef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T AcknowledgeSignalActionPkt(const int pktSize, const ExtModeAction ACTION_ID)\n{\n    const char *pkt;\n    int32_T    upInfoIdx;\n    boolean_T  error = EXT_NO_ERROR;\n\n    pkt = GetPkt(pktSize);\n    (void)memcpy(&upInfoIdx, pkt, sizeof(int32_T));\n    error = SendResponseStatus(ACTION_ID, STATUS_OK, upInfoIdx);\n    return(error);\n} \n#endif /* ifdef EXTMODE_DISABLESIGNALMONITORING */\n\n/*********************\n * Visible Functions *\n *********************/\n\n\n/* Function: ExtParseArgsAndInitUD =============================================\n * Abstract:\n *  Pass remaining arguments (main program should have NULL'ed out any args\n *  that it processed) to external mode.\n *  \n *  The actual, transport-specific parsing routine (implemented in\n *  ext_svr_transport.c) MUST NULL out all entries of argv that it processes.\n *  The main program depends on this in order to determine if any unhandled\n *  command line options were specified (i.e., if the main program detects\n *  any non-null fields after the parse, it throws an error).\n *\n *  Returns an error string on failure, NULL on success.\n *\n * NOTES:\n *  The external mode UserData is created here so that the specified command-\n *  line options can be stored.\n */\nPUBLIC const char_T *ExtParseArgsAndInitUD(const int_T  argc,\n                                           const char_T *argv[])\n{\n    const char_T *error = NULL;\n    \n    /*\n     * Create the user data.\n     */\n    extUD = ExtUserDataCreate();\n    if (extUD == NULL) {\n        error = \"Could not create external mode user data.  Out of memory.\\n\";\n        goto EXIT_POINT;\n    }\n\n    /*\n     * Parse the transport-specific args.\n     */\n    error = ExtProcessArgs(extUD,argc,argv);\n    if (error != NULL) goto EXIT_POINT;\n        \nEXIT_POINT:\n    if (error != NULL) {\n        ExtUserDataDestroy(extUD);\n        extUD = NULL;\n    }\n    return(error);\n} /* end ExtParseArgsAndInitUD */\n\n\n/* Function: ExtWaitForStartPkt ================================================\n * Abstract:\n *  Return true if waiting for host to tell us when to start.\n */\nPUBLIC boolean_T ExtWaitForStartPkt(void)\n{\n    return(ExtWaitForStartPktFromHost(extUD));\n} /* end ExtWaitForStartPkt */\n\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: UploadServerWork =================================================\n * Abstract:\n *  Upload model signals to host for a single upInfo.\n */\nvoid UploadServerWork(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T         i;\n    ExtBufMemList upList;\n    boolean_T     error = EXT_NO_ERROR;\n\n#ifdef VXWORKS\n    /*\n     * Don't spin the CPU unless we've got data to upload.\n     * The upload.c/UploadBufAddTimePoint function gives the sem\n     * each time that data is added.\n     */\ntaskUnsafe();\n    semTake(uploadSem, WAIT_FOREVER);\ntaskSafe();\n#endif\n\n    if (!connected) goto EXIT_POINT;\n    \n    UploadBufGetData(&upList, upInfoIdx, numSampTimes);\n    while(upList.nActiveBufs > 0) {\n        for (i=0; i<upList.nActiveBufs; i++) {\n            const BufMem *bufMem = &upList.bufs[i];\n\n            /*\n             * We call SendPktDataToHost() instead of SendPktToHost() because\n             * the packet header is combined with packet payload.  We do this\n             * to avoid the overhead of making two calls for each upload\n             * packet - one for the head and one for the payload.\n             */\n            error = SendPktDataToHost(\n                bufMem->section1,\n                bufMem->nBytes1);\n            if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                    \n                fprintf(stderr,\"SendPktDataToHost() failed on data upload.\\n\");\n#endif\n                goto EXIT_POINT;\n            }\n            \n            if (bufMem->nBytes2 > 0) {\n\n                error = SendPktDataToHost(\n                    bufMem->section2,\n                    bufMem->nBytes2);\n                if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                        \n                    fprintf(stderr,\"SendPktDataToHost() failed on data upload.\\n\");\n#endif\n                    goto EXIT_POINT;\n                }\n            }\n            /* confirm that the data was sent */\n            UploadBufDataSent(upList.tids[i], upInfoIdx);\n        }\n        UploadBufGetData(&upList, upInfoIdx, numSampTimes);\n    }\n    \nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        /* An error in this function is caused by a physical failure in the\n         * external mode connection.  We assume this failure caused the host\n         * to disconnect.  The target must be disconnected and returned to a\n         * state where it is running and can be re-connected to by the host.\n         */\n        ForceDisconnectFromHost(numSampTimes);\n    }\n}\n/* end UploadServerWork */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: rt_UploadServerWork ===============================================\n * Abstract:\n *  Wrapper function that calls UploadServerWork once for each upInfo\n */\nPUBLIC void rt_UploadServerWork(int_T numSampTimes)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadServerWork(i, numSampTimes);\n    }\n} /* end rt_UploadServerWork */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function: rt_ExtModeInit ====================================================\n * Abstract:\n *  Called once at program startup to do any initialization related to external\n *  mode. \n */\nPUBLIC boolean_T rt_ExtModeInit(void)\n{\n    int i;\n    boolean_T error = EXT_NO_ERROR;\n\n#ifdef TMW_EXTMODE_TESTING_REQ\n#  ifndef TMW_EXTMODE_TESTING\n#ifndef EXTMODE_DISABLEPRINTF \n    fprintf(stderr,\"Error: External mode tests should use the external mode test harness.\\n\");\n#endif\n    error = EXT_ERROR;\n#  endif\n#endif\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    error = ExtInit(extUD);\n    if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadLogInfoReset(i);\n    }\n\n    rtExtModeTestingInit();\n\nEXIT_POINT:\n    return(error);\n} /* end rt_ExtModeInit */\n\n\n/* Function: rt_ExtModeSleep ===================================================\n * Abstract:\n *  Called by grt_main, ert_main, and grt_malloc_main  to \"pause\".  It attempts\n *  to do this in a way that does not hog the processor.\n */\n#ifndef VXWORKS\nPUBLIC void rt_ExtModeSleep(\n    long sec,  /* number of seconds to wait       */\n    long usec) /* number of micro seconds to wait */\n{\n    ExtModeSleep(extUD,sec,usec);\n} /* end rt_ExtModeSleep */\n#endif\n\n\n/* Function: rt_PktServerWork ==================================================\n * Abstract:\n *  If not connected, establish communication of the packet line and the\n *  data upload line.  If connected, send/receive packets and parameters\n *  on the packet line.\n */\nPUBLIC void rt_PktServerWork(RTWExtModeInfo *ei,\n                             int_T          numSampTimes,\n                             boolean_T      *stopReq)\n{\n    PktHeader  pktHdr;\n    boolean_T  hdrAvail;\n    boolean_T  error             = EXT_NO_ERROR;\n    boolean_T  disconnectOnError = false;\n    \n    /*\n     * If not connected, attempt to make connection to host.\n     */\n    if (!connected) {\n        rtExtModeTestingKillIfOrphaned(false);\n\n        error = ExtOpenConnection(extUD,&connected);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\n    /*\n     * If ExtOpenConnection is not blocking and there are no pending\n     * requests to open a connection, we'll still be unconnected.\n     */\n    if (!connected) goto EXIT_POINT; /* nothing to do */\n    \n    /*\n     * Process packets.\n     */\n\n    /* Wait for a packet. */\n    error = GetPktHdr(&pktHdr, &hdrAvail);\n    if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr, \"\\nError occurred getting packet header.\\n\");\n#endif\n        disconnectOnError = true;\n        goto EXIT_POINT;\n    }\n    rtExtModeTestingKillIfOrphaned(hdrAvail);\n    \n    if (!hdrAvail) goto EXIT_POINT; /* nothing to do */\n\n    /*\n     * This is the first packet.  Should contain the string:\n     * 'ext-mode'.  Its contents are not important to us.\n     * It is used as a flag to start the handshaking process.\n     */\n    if (!commInitialized) {\n        pktHdr.type = EXT_CONNECT;\n    }\n\n    /* \n     * At this point we know that we have a packet: process it.\n     */\n#ifdef VXWORKS\n    taskSafe();\n#endif\n    switch(pktHdr.type) {\n\n    case EXT_GET_TIME:\n    {\n        /* Skip verbosity print out - we get too many of these */\n        /*PRINT_VERBOSE((\"got EXT_GET_TIME packet.\\n\"));*/\n        time_T t = rteiGetT(ei);\n        \n        error = SendPktToHost(\n            EXT_GET_TIME_RESPONSE,sizeof(time_T),\n            (char_T *)&t);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    }\n\n    case EXT_ARM_TRIGGER:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessCancelLoggingArmTriggerPkt(EXT_ARM_TRIGGER_RESPONSE, pktHdr.size, numSampTimes);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_ARM_TRIGGER_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_SELECT_SIGNALS:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessSelectTriggerSignalPkt(EXT_SELECT_SIGNALS_RESPONSE, ei, pktHdr.size, numSampTimes, ERRMSG_PROCESSSELECTSIGNAL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_SELECT_SIGNALS_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_SELECT_TRIGGER: \n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessSelectTriggerSignalPkt(EXT_SELECT_TRIGGER_RESPONSE, ei, pktHdr.size, -1, ERRMSG_PROCESSSELECTTRIGGER);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_SELECT_TRIGGER_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_CONNECT:\n    {\n        PRINT_VERBOSE((\"got EXT_CONNECT packet.\\n\"));\n        error = ProcessConnectPkt(ei);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    }\n\n    case EXT_SETPARAM:\n    {\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n        PRINT_VERBOSE((\"got EXT_SETPARAM packet.\\n\"));\n        if (pktHdr.size == 0) {\n            gblSetParamPktReceived = true;\n        } else {\n            error = ProcessSetParamPkt(ei, pktHdr.size);\n            if (error != EXT_NO_ERROR) {\n                goto EXIT_POINT;\n            }\n            else {\n                gblSetParamPktReceived = true;\n            }\n        }\n#else\n        PRINT_VERBOSE((\"discard EXT_SETPARAM packet.\\n\"));\n        error = AcknowledgeSetParamPkt(pktHdr.size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_GETPARAMS:\n    {\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\n        PRINT_VERBOSE((\"got EXT_GETPARAMS packet.\\n\"));\n        error = ProcessGetParamsPkt(ei);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    case EXT_DISCONNECT_REQUEST:\n    {\n        PRINT_VERBOSE((\"got EXT_DISCONNECT_REQUEST packet.\\n\"));\n        \n        /*\n         * Note that from the target's point of view this is\n         * more a \"notify\" than a \"request\".  The host needs to\n         * have this acknowledged before it can begin closing\n         * the connection.\n         */\n        error = SendPktToHost(EXT_DISCONNECT_REQUEST_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        DisconnectFromHost(numSampTimes);\n\n        break;\n    }\n\n    case EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD:\n    {\n        PRINT_VERBOSE((\"got EXT_DISCONNECT_REQUEST_NO_FINAL_UPLOAD packet.\\n\"));\n        \n        /*\n         * The target receives this packet when the host is\n         * immediately terminating the extmode communication due\n         * to some error.  The target should not send back a\n         * response or a final upload of data because the host is\n         * expecting neither.  The target must be disconnected and\n         * returned to a state where it is running and can be\n         * re-connected to by the host.\n         */\n        ForceDisconnectFromHost(numSampTimes);\n\n        break;\n    }\n\n    case EXT_MODEL_START:\n        PRINT_VERBOSE((\"got EXT_MODEL_START packet.\\n\"));\n#ifdef VXWORKS\n        {\n            extern SEM_ID startStopSem;\n            semGive(startStopSem);\n        }\n#endif\n        startModel = true;\n        error = SendPktToHost(EXT_MODEL_START_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n\n    case EXT_MODEL_STOP:\n        PRINT_VERBOSE((\"got EXT_MODEL_STOP packet.\\n\"));\n        *stopReq = true;\n        break;\n#ifndef EXTMODE_DISABLETESTING\n    case EXT_MODEL_PAUSE:\n        PRINT_VERBOSE((\"got EXT_MODEL_PAUSE packet.\\n\"));\n        modelStatus = TARGET_STATUS_PAUSED;\n        startModel  = false;\n\n        error = SendPktToHost(EXT_MODEL_PAUSE_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    case EXT_MODEL_STEP:\n        PRINT_VERBOSE((\"got EXT_MODEL_STEP packet.\\n\"));\n        if ((modelStatus == TARGET_STATUS_PAUSED) && !startModel) {\n            startModel = true;\n        }\n        \n        error = SendPktToHost(EXT_MODEL_STEP_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n        break;\n    case EXT_MODEL_CONTINUE:\n        PRINT_VERBOSE((\"got EXT_MODEL_CONTINUE packet.\\n\"));\n        if (modelStatus == TARGET_STATUS_PAUSED) {\n            modelStatus = TARGET_STATUS_RUNNING;\n            startModel  = false;\n        }\n        \n        error = SendPktToHost(EXT_MODEL_CONTINUE_RESPONSE, 0, NULL);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n\n    case EXT_CANCEL_LOGGING:\n    {\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        error = ProcessCancelLoggingArmTriggerPkt(EXT_CANCEL_LOGGING_RESPONSE, pktHdr.size, numSampTimes);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#else\n        error = AcknowledgeSignalActionPkt(pktHdr.size, EXT_CANCEL_LOGGING_RESPONSE);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n#endif\n        break;\n    }\n\n    default:\n#ifndef EXTMODE_DISABLEPRINTF            \n        fprintf(stderr,\"received invalid packet.\\n\");\n#endif\n        break;\n    } /* end switch */\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        if (disconnectOnError) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\n                \"Error occurred in rt_PktServerWork.\\n\"\n                \"Disconnecting from host!\\n\");\n#endif\n            /* An error in this function which causes disconnectOnError to be\n             * set to true is caused by a physical failure in the external mode\n             * connection.  We assume this failure caused the host to disconnect.\n             * The target must be disconnected and returned to a state\n             * where it is running and can be re-connected to by the host.\n             */\n            ForceDisconnectFromHost(numSampTimes);\n        }\n    }\n#ifdef VXWORKS\n    taskUnsafe();\n#endif\n} /* end rt_PktServerWork */\n\n\n/* Function: rt_PktServer ======================================================\n * Abstract:\n *  Call rt_PktServerWork forever.   Used only for RTOS (e.g., Tornado/VxWorks\n *  when running as a low priority task.\n */\n#ifdef VXWORKS\nPUBLIC void rt_PktServer(RTWExtModeInfo *ei,\n                         int_T          numSampTimes,\n                         boolean_T      *stopReq)\n{\n    for(;;) {\n        rt_PktServerWork(ei,numSampTimes,stopReq); \n    }\n}\n#endif\n\n\n/* Function: rt_UploadServer ===================================================\n * Abstract:\n *  Call rt_UploadServerWork forever.   Used only for RTOS (e.g.,\n *  Tornado/VxWorks when running as a low priority task.\n */\n#ifdef VXWORKS\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void rt_UploadServer(int_T numSampTimes)\n{\n    for(;;) {\n        rt_UploadServerWork(numSampTimes);\n    }\n} /* end rt_UploadServer */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n#endif\n\n\n/* Function: rt_SetPortInExtUD =================================================\n * Abstract:\n *  Set the port in the external mode user data structure.\n */\n#ifdef VXWORKS\nPUBLIC void rt_SetPortInExtUD(const int_T port)\n{\n    ExtUserDataSetPort(extUD, port);\n} /* end rt_SetPortInExtUD */\n#endif\n\n/* Function: ExtModeShutdown ==================================================\n * Abstract:\n *  Called when target program terminates to enable cleanup of external \n *  mode for a given upInfo.\n */\nPRIVATE void ExtModeShutdown(int32_T upInfoIdx, int_T numSampTimes)\n{\n    /*\n     * Make sure buffers are flushed so that the final points get to\n     * host (this is important for the case of the target reaching tfinal\n     * while data uploading is in progress).\n     */\n    UploadPrepareForFinalFlush(upInfoIdx);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    UploadServerWork(upInfoIdx, numSampTimes);\n#endif\n\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n\n    if (pktBuf != NULL) {\n        free(pktBuf);\n        pktBuf = NULL;\n    }\n\n} /* end ExtModeShutdown */\n\n/* Function: rt_ExtModeShutdown ================================================\n * Abstract:\n *  Called when target program terminates to enable cleanup of external \n *  mode.\n */\nPUBLIC boolean_T rt_ExtModeShutdown(int_T numSampTimes)\n{\n    int i;\n    boolean_T error = EXT_NO_ERROR;\n\n    for (i=0; i<NUM_UPINFOS; i++) {\n        ExtModeShutdown(i, numSampTimes);\n    }\n\n    if (commInitialized) {\n        error = SendPktToHost(EXT_MODEL_SHUTDOWN, 0, NULL);\n        if (error != EXT_NO_ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF                \n            fprintf(stderr,\n                \"\\nError sending EXT_MODEL_SHUTDOWN packet to host.\\n\");\n#endif\n        }\n        commInitialized = false;\n    }\n    if (connected) {\n        connected = false;\n        modelStatus = TARGET_STATUS_WAITING_TO_START;        \n    }\n\n    ExtShutDown(extUD);\n    ExtUserDataDestroy(extUD);\n    \n    rtExtModeTestingRemoveBatMarker();\n    \n    return(error);\n} /* end rt_ExtModeShutdown */\n\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n/* Function: rt_UploadCheckTrigger =============================================\n * Abstract:\n *  Wrapper function that calls UploadCheckTrigger once for each upInfo\n */\nPUBLIC void rt_UploadCheckTrigger(int_T numSampTimes)\n{\n    int i;\n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadCheckTrigger(i, numSampTimes);\n    }\n} /* end rt_UploadCheckTrigger */\n\n/* Function: rt_UploadCheckEndTrigger ==========================================\n * Abstract:\n *  Wrapper function that calls UploadCheckTrigger once for each upInfo\n */\nPUBLIC void rt_UploadCheckEndTrigger(void)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadCheckEndTrigger(i);\n    }\n} /* end rt_UploadCheckEndTrigger */\n\n/* Function: rt_UploadBufAddTimePoint ==========================================\n * Abstract:\n *  Wrapper function that calls UploadBufAddTimePoint once for each upInfo\n */\nPUBLIC void rt_UploadBufAddTimePoint(int_T tid, real_T taskTime)\n{\n    int i;\n    \n    for (i=0; i<NUM_UPINFOS; i++) {\n        UploadBufAddTimePoint(tid, taskTime, i);\n    }\n} /* end rt_UploadBufAddTimePoint */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* [EOF] ext_svr.c */\n"},{"name":"ext_work.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2021 The MathWorks, Inc.\n *\n * File: ext_work.c     \n *\n * Abstract:\n *   \n */\n\n#if !defined(EXTMODE_DISABLEPRINTF) || !defined(EXTMODE_DISABLE_ARGS_PROCESSING)\n#include <stdio.h>\n#endif\n\n#include <stdlib.h>        /* for exit() */\n#include <string.h>        /* optional for strcmp */\n\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"updown.h\"\n#include \"ext_svr.h\"\n#include \"ext_svr_transport.h\"\n#include \"ext_work.h\" /* includes all VxWorks headers */\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nint_T           volatile startModel  = false;\nTargetSimStatus volatile modelStatus = TARGET_STATUS_WAITING_TO_START;\n\n#ifdef VXWORKS\nSEM_ID volatile uploadSem = NULL;\nSEM_ID volatile commSem   = NULL;\nSEM_ID volatile pktSem    = NULL;\nint_T           extern_pkt_tid;\nint_T           extern_upload_tid;\n\nvoid rtExtModeTornadoStartup(RTWExtModeInfo *ei,\n                             int_T          numSampTimes,\n                             boolean_T      *stopReqPtr,\n                             int_T          priority,\n                             int32_T        stack_size,\n                             SEM_ID         startStopSem)\n{\n    uploadSem = semBCreate(SEM_Q_PRIORITY, SEM_EMPTY);\n    commSem   = semBCreate(SEM_Q_PRIORITY, SEM_FULL);\n    pktSem    = semBCreate(SEM_Q_PRIORITY, SEM_FULL);\n\n    rt_ExtModeInit();\n\n    extern_pkt_tid = taskSpawn(\"tExternPkt\",\n        priority+(numSampTimes), VX_FP_TASK, stack_size, (FUNCPTR)rt_PktServer, \n        (int_T) ei, (int_T) numSampTimes, (int_T) stopReqPtr, 0, 0, 0, 0, 0, 0, 0);\n    if (extern_pkt_tid == ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"handle taskpawn error\");\n#endif\n    }\n\n    extern_upload_tid = taskSpawn(\"tExternUpload\",\n        priority+(numSampTimes)+1,VX_FP_TASK, stack_size,(FUNCPTR)rt_UploadServer,\n        (int_T) numSampTimes, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    if (extern_upload_tid == ERROR) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"handle taskpawn error\");\n#endif\n    }\n\n    /*\n     * Pause until receive model start packet - if external mode.\n     * Make sure the external mode tasks are running so that \n     * we are listening for commands from the host.\n     */\n    if (ExtWaitForStartPkt()) {\n#ifndef EXTMODE_DISABLEPRINTF\n        printf(\"\\nWaiting for start packet from host.\\n\");\n#endif\n        semTake(startStopSem, WAIT_FOREVER);\n    }\n    modelStatus = TARGET_STATUS_RUNNING;\n}\n\nvoid rtExtModeTornadoCleanup(int_T numSampTimes)\n{\n    taskDelete(extern_upload_tid);\n    taskDelete(extern_pkt_tid);\n    rt_ExtModeShutdown(numSampTimes);\n    semDelete(uploadSem);\n    semDelete(commSem);\n    semDelete(pktSem);\n}\n\n/* Function ====================================================================\n *  Used by Tornado/VxWorks to set the port number used by external mode.\n *  Tornado does not parse the port number the same way as the other code\n *  formats.  Instead, the port number is specified as an argument to the\n *  spawn command which passes it into rt_main().  This function is called\n *  by rt_main() to set the port number in the external mode user data\n *  structure.\n */\nvoid rtExtModeTornadoSetPortInExtUD(const int_T port)\n{\n    rt_SetPortInExtUD(port);\n}\n\n#else /* VXWORKS == 0 */\n\n/* Function ====================================================================\n * Pause the process (w/o hogging the cpu) until receive step packet (which\n * means the startModel flag moves to true) or until we are no longer\n * in the paused state.  The packet/upload server must continue to process\n * events (otherwise the host would not be able to communicate with the target).\n */\nvoid rtExtModePauseIfNeeded(RTWExtModeInfo *ei,\n                            int_T          numSampTimes,\n                            boolean_T      *stopReqPtr)\n{\n    while((modelStatus == TARGET_STATUS_PAUSED) && \n          !startModel && !(*stopReqPtr)) {\n        rt_ExtModeSleep(0L, 375000L);\n        rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        rt_UploadServerWork(numSampTimes);\n#endif\n    }\n    startModel = false; /* reset to false - if we were stepped we want to\n                         *                  stop again next time we get\n                         *                  back here.\n                         */\n} /* end rtExtModePauseIfNeeded */\n\n/* Function ====================================================================\n * Pause the process (w/o hogging the cpu) until receive start packet\n * from the host.  The packet/upload server must continue to process\n * events (otherwise the host would not be able to communicate with the target).\n */\nvoid rtExtModeWaitForStartPkt(RTWExtModeInfo *ei,\n                              int_T          numSampTimes,\n                              boolean_T      *stopReqPtr)\n{\n    /*\n     * Pause until receive model start packet.\n     */\n    if (ExtWaitForStartPkt()) {\n        while(!startModel && !(*stopReqPtr)) {\n            rt_ExtModeSleep(0L, 375000L);\n            rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n            rt_UploadServerWork(numSampTimes);\n#endif\n        }\n    }\n    if (modelStatus != TARGET_STATUS_PAUSED) {\n        modelStatus = TARGET_STATUS_RUNNING;\n    } else {\n        /* leave in pause mode */\n    }\n}\n#endif\n\nvoid rtExtModeOneStep(RTWExtModeInfo *ei,\n                      int_T          numSampTimes,\n                      boolean_T      *stopReqPtr)\n{\n    /*\n     * In a multi-tasking environment, this would be removed from the base rate\n     * and called as a \"background\" task.\n     */\n    if (modelStatus != TARGET_STATUS_PAUSED) {\n        rt_PktServerWork(ei,numSampTimes,stopReqPtr);\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n        rt_UploadServerWork(numSampTimes);\n#endif\n    }\n}\n\nvoid rtExtModeUpload(int_T tid, real_T taskTime)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadBufAddTimePoint(tid, taskTime);\n#endif\n}\n\nvoid rtExtModeCheckEndTrigger(void)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadCheckEndTrigger();\n#endif\n}\n\nvoid rtExtModeUploadCheckTrigger(int_T numSampTimes)\n{\n#ifndef EXTMODE_DISABLESIGNALMONITORING\n    rt_UploadCheckTrigger(numSampTimes);\n#endif\n}\n\nvoid rtExtModeCheckInit(int_T numSampTimes)\n{\n    UNUSED_PARAMETER(numSampTimes);\n    if (rt_ExtModeInit() != EXT_NO_ERROR){\n#ifndef EXTMODE_DISABLEPRINTF            \n            printf(\"Error calling rt_ExtModeInit!\\n\");\n            exit(EXIT_FAILURE);         /*Error out if rt_ExtModeInit() returns EXT_ERROR. */\n#endif\n    }\n}\n\nvoid rtExtModeShutdown(int_T numSampTimes)\n{\n    rt_ExtModeShutdown(numSampTimes);\n}\n\nvoid rtExtModeParseArgs(int_T        argc, \n                        const char_T *argv[],\n                        real_T       *unused)\n{\n    UNUSED_PARAMETER(unused);\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args, so bypass the args \n     * processing and directly call into ExtParseArgsAndInitUD.\n     */\n\n    /* initialize external mode */\n    ExtParseArgsAndInitUD(0, NULL);\n\n#else   \n\n    /*\n     * Parse the external mode arguments.\n     */\n    {\n        const char_T *extParseErrorPkt = ExtParseArgsAndInitUD(argc, argv);\n        if (extParseErrorPkt != NULL) {\n#ifndef EXTMODE_DISABLEPRINTF            \n            printf(\n                \"\\nError processing External Mode command line arguments:\\n\");\n            printf(\"\\t%s\",extParseErrorPkt);\n#endif\n            exit(EXIT_FAILURE);\n        }\n    }\n#endif  /* EXTMODE_DISABLE_ARGS_PROCESSING */\n}\n\n/* Start of ERT specific functions and data */\n\n#ifndef EXTMODE_DISABLE_ARGS_PROCESSING\nstatic void displayUsage(void)\n{\n#ifndef EXTMODE_DISABLEPRINTF    \n    (void) printf(\"usage: model_name -tf <finaltime> -w -port <TCPport>\\n\");\n    (void) printf(\"arguments:\\n\");\n    (void) printf(\"  -tf <finaltime> - overrides final time specified in \"\n                  \"Simulink (inf for no limit).\\n\");\n    (void) printf(\"  -w              - waits for Simulink to start model \"\n                  \"in External Mode.\\n\");\n    (void) printf(\"  -port <TCPport> - overrides 17725 default port in \"\n                  \"External Mode, valid range 256 to 65535.\\n\");\n#endif    \n}\n#endif\n\nstatic const real_T RUN_FOREVER = (real_T)-1;\n#if INTEGER_CODE == 0\nstatic real_T finaltime = (real_T)-2; /* default to stop time in Sim Params. */\n#else\nstatic real_T finaltime = (real_T)-1; /* default to stop time inf */\n#endif\n\nvoid rtERTExtModeSetTFinal(real_T *rtmTFinal)\n{\n    if (finaltime >= (real_T)0 || finaltime == RUN_FOREVER) {\n        *rtmTFinal = finaltime;\n    }\n}\n\nvoid rtSetTFinalForExtMode(real_T *rtmTFinal)\n{\n    rtERTExtModeSetTFinal(rtmTFinal);\n}\n\nvoid rtParseArgsForExtMode(int_T        argc, \n                           const char_T *argv[])\n{\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args, so bypass the args \n     * processing and directly call into ExtParseArgsAndInitUD.\n     */\n\n    /* initialize external mode */\n    ExtParseArgsAndInitUD(0, NULL);\n\n#else    \n    /* parse command line args */\n\n    int_T  oldStyle_argc;\n    const char_T *oldStyle_argv[5];\n\n    if ((argc > 1) && (argv[1][0] != '-')) {\n        /* at least one command line argument has been provided without\n           specifying an option with '-', using the old style */\n        if ( argc > 3 ) {\n            displayUsage();\n            exit(EXIT_FAILURE);\n        }\n\n        /* using the old style the first argument is always the final time */\n        oldStyle_argc = 3;\n        oldStyle_argv[0] = argv[0];\n        oldStyle_argv[1] = \"-tf\";\n        oldStyle_argv[2] = argv[1];\n\n        if (argc == 3) {\n            oldStyle_argc = 5;\n\n            oldStyle_argv[3] = \"-port\";\n            oldStyle_argv[4] = argv[2];\n\n        }\n\n        argc = oldStyle_argc;\n        argv = oldStyle_argv;\n\n    }\n\n    {\n        /* new style: */\n        double    tmpDouble;\n        char_T tmpStr2[200];\n        int_T  count      = 1;\n        int_T  parseError = false;\n\n        /*\n         * Parse the standard RTW parameters.  Let all unrecognized parameters\n         * pass through to external mode for parsing.  NULL out all args handled\n         * so that the external mode parsing can ignore them.\n         */\n        while(count < argc) {\n            const char_T *option = argv[count++];\n            \n            /* final time */\n            if ((strcmp(option, \"-tf\") == 0) && (count != argc)) {\n                const char_T *tfStr = argv[count++];\n                \n                sscanf(tfStr, \"%200s\", tmpStr2);\n                if (strcmp(tmpStr2, \"inf\") == 0) {\n                    tmpDouble = RUN_FOREVER;\n                } else {\n                    char_T tmpstr[2];\n\n#if INTEGER_CODE == 0\n                    if ( (sscanf(tmpStr2,\"%lf%1s\", &tmpDouble, tmpstr) != 1) ||\n                         (tmpDouble < (real_T)0) ) {\n    #ifndef EXTMODE_DISABLEPRINTF\n                        (void)printf(\"finaltime must be a positive, real value or inf\\n\");\n    #endif\n                        parseError = true;\n                        break;\n                    }\n#else\n                    if ( (sscanf(tmpStr2,\"%d%1s\", &tmpDouble, tmpstr) != 1) ||\n                         (tmpDouble < (real_T)0) ) {\n    #ifndef EXTMODE_DISABLEPRINTF\n                        (void)printf(\"tmpDouble = %d\\n\", tmpDouble);\n                        (void)printf(\"finaltime must be a positive, integer value or inf\\n\");\n    #endif\n                        parseError = true;\n                        break;\n                    }\n#endif\n                }\n                finaltime = (real_T) tmpDouble;\n\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n            }\n        }\n\n        if (parseError) {\n    #ifndef EXTMODE_DISABLEPRINTF        \n            (void)printf(\"\\nUsage: model_name -option1 val1 -option2 val2 -option3 \"\n                         \"...\\n\\n\");\n            (void)printf(\"\\t-tf 20 - sets final time to 20 seconds\\n\");\n    #endif        \n\n            exit(EXIT_FAILURE);\n        }\n\n        /*\n         * Parse the external mode arguments.\n         */\n        {\n            const char_T *extParseErrorPkt = ExtParseArgsAndInitUD(argc, argv);\n            if (extParseErrorPkt != NULL) {\n    #ifndef EXTMODE_DISABLEPRINTF           \n                printf(\n                    \"\\nError processing External Mode command line arguments:\\n\");\n                printf(\"\\t%s\",extParseErrorPkt);\n    #endif\n                exit(EXIT_FAILURE);\n            }\n        }\n\n        /*\n         * Check for unprocessed (\"unhandled\") args.\n         */\n        {\n            int i;\n            for (i=1; i<argc; i++) {\n                if (argv[i] != NULL) {\n    #ifndef EXTMODE_DISABLEPRINTF                \n                    printf(\"Unexpected command line argument: %s\\n\",argv[i]);\n    #endif\n                    exit(EXIT_FAILURE);\n                }\n            }\n        }\n    }\n\n    if (finaltime == RUN_FOREVER) {\n        #ifndef EXTMODE_DISABLEPRINTF\n                printf (\"\\n**warning: the simulation will run with no stop time due \"\n                \"to external mode with '-tf inf' argument.\\n\");\n        #endif\n    }\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n}\n\nvoid rtERTExtModeStartMsg(void)\n{\n#ifndef EXTMODE_DISABLEPRINTF    \n    (void)printf(\"\\n** starting the model **\\n\");\n#endif\n}\n\n/* End of ERT specific functions and data */\n\n/* [EOF] ext_work.c */\n"},{"name":"grabberCannon.c","type":"source","group":"legacy","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2019 The MathWorks, Inc. */\n#include \"grabberCannon.h\"\n#include <stdio.h>\n\nextern int run_flag;\n        \nuint32_t cannonPendingShots = 1; //\nuint32_t cannonFire = 0;\n\nuint8_t oldClawCommand = -1; \nuint8_t oldCannonCommand = -1;\n\nint8_t clawState = -1;  // Initialize the status to ERROR(-1). Will be updated in the claw_state_cb.\nint8_t cannonState = -1; // Initialize the status to ERROR(-1). Will be updated in the cannon_state_cb.\n\nextern int grabberCannonBusy;\n\nARCOMMANDS_Decoder_t* decoderPointer;\n\nstatic void claw_hold(ARCOMMANDS_Decoder_t *decoder)\n{\n\tuint8_t buffer[COMMANDS_BUFFER_SIZE];\n\tint32_t length;\n\tint res;\n\n\tres = ARCOMMANDS_Generator_GenerateMiniDroneUsbAccessoryClawControl(\n\t\tbuffer, COMMANDS_BUFFER_SIZE, &length,\n\t\t0, ARCOMMANDS_MINIDRONE_USBACCESSORY_CLAWCONTROL_ACTION_CLOSE);\n\tif (res != ARCOMMANDS_GENERATOR_OK) {\n\t\treturn;\n\t}\n\n\tres = ARCOMMANDS_Decoder_DecodeCommand(decoder, buffer, length);\n\tif (res != ARCOMMANDS_DECODER_OK) {\n\t\tchar msg[COMMANDS_MESSAGE_SIZE];\n\t\tARCOMMANDS_Decoder_DescribeBuffer(buffer, length, msg,\n\t\t\t\t\t\t  sizeof(msg));\n\t\t\n\t}\n}\n\nstatic void claw_release(ARCOMMANDS_Decoder_t *decoder)\n{\n\tuint8_t buffer[COMMANDS_BUFFER_SIZE];\n\tint32_t length;\n\tint res;\n\n\tres = ARCOMMANDS_Generator_GenerateMiniDroneUsbAccessoryClawControl(\n\t\tbuffer, COMMANDS_BUFFER_SIZE, &length,\n\t\t0, ARCOMMANDS_MINIDRONE_USBACCESSORY_CLAWCONTROL_ACTION_OPEN);\n\tif (res != ARCOMMANDS_GENERATOR_OK) {\n\t\treturn;\n\t}\n\n\tres = ARCOMMANDS_Decoder_DecodeCommand(decoder, buffer, length);\n\tif (res != ARCOMMANDS_DECODER_OK) {\n\t\tchar msg[COMMANDS_MESSAGE_SIZE];\n\t\tARCOMMANDS_Decoder_DescribeBuffer(buffer, length, msg,\n\t\t\t\t\t\t  sizeof(msg));\n\t\t\n\t}\n}\n\n\nstatic void cannon_fire(ARCOMMANDS_Decoder_t *decoder)\n{\n\tuint8_t buffer[COMMANDS_BUFFER_SIZE];\n\tint32_t length;\n\tint res;\n\n\tres = ARCOMMANDS_Generator_GenerateMiniDroneUsbAccessoryGunControl(\n\t\tbuffer, COMMANDS_BUFFER_SIZE, &length,\n\t\t0, ARCOMMANDS_MINIDRONE_USBACCESSORY_GUNCONTROL_ACTION_FIRE);\n\tif (res != ARCOMMANDS_GENERATOR_OK) {\n\t\treturn;\n\t}\n\n\tres = ARCOMMANDS_Decoder_DecodeCommand(decoder, buffer, length);\n\tif (res != ARCOMMANDS_DECODER_OK) {\n\t\tchar msg[COMMANDS_MESSAGE_SIZE];\n\t\tARCOMMANDS_Decoder_DescribeBuffer(buffer, length, msg,\n\t\t\t\t\t\t  sizeof(msg));\n\t\t\n\t}\n}\n\nstatic void claw_state_cb(\n\tuint8_t id,\n\teARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE state,\n\tuint8_t list_flags, void *custom)\n{\n    if(state == ARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE_OPENED){\n        clawState = 0;\n        grabberCannonBusy = 0;\n    }\n    else if(state == ARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE_CLOSED){\n        clawState = 1;\n        grabberCannonBusy = 0;\n    }\n}\n\nstatic void gun_state_cb(\n\tuint8_t id,\n\teARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE state,\n\tuint8_t list_flags, void *custom)\n{\n    if(state == ARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE_READY){\n        cannonState = 1;\n        grabberCannonBusy = 0;\n        cannonPendingShots--;\n    }\n    else{\n        cannonState = 0;\n    }\n}\n\n\nint RSEDU_initialize(ARCOMMANDS_Decoder_t *decoder)\n{\n    ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateGunStateCb(decoder, gun_state_cb, decoder);\n    ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateClawStateCb(decoder, claw_state_cb, decoder);\n    decoderPointer = decoder;\n    \n    return 0;\n}\n\nint8_t MW_PARROT_Grabber(uint8_t state){ // Issue the command to either close/release the claw\n    if(clawState < 0 || run_flag == 0) // If the run_flag is '0', stop taking commands\n        return -1;\n    \n    if(state == oldClawCommand) \n        return clawState;\n    oldClawCommand = state; \n    grabberCannonBusy = 1;\n    if(state == 0){\n        claw_release(decoderPointer);\n    }\n    else if (state == 1){\n        claw_hold(decoderPointer);\n    }\n    return clawState;\n}\n\nint32_t MW_PARROT_Cannon(uint8_t fire){  // Issue the command to fire a single pellet\n    if(cannonState < 0 || run_flag == 0) // If the run_flag is '0', stop taking commands\n        return -1;\n    \n    if(fire == 1 && oldCannonCommand == 0){ //If the input changes from 0 to 1, fire a single pellet.\n        cannonFire++;\n        cannonPendingShots++;\n    }\n    oldCannonCommand = fire;  \n    if((cannonFire > 0) && (cannonFire == cannonPendingShots)){\n        cannon_fire(decoderPointer);\n        grabberCannonBusy = 1;\n        cannonFire--;\n    }\n    return cannonPendingShots;\n}\n\n"},{"name":"mem_mgr.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2019 The MathWorks, Inc.\n *\n * File: mem_mgr.c     $Revision.2 $\n *\n * Abstract:\n */\n\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef VERBOSE\n#include <stdio.h>\n#endif\n\n#include \"rtwtypes.h\"\n\n#include \"updown_util.h\"\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n\n#include \"mem_mgr.h\"\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nPRIVATE char MemoryBuffer[EXTMODE_STATIC_SIZE];\n\nPRIVATE MemBufHdr *FreeQueue = NULL;\nPRIVATE MemBufHdr InUseQueue = {NULL, NULL, NULL, 0};\n\n#ifdef VERBOSE\nuint32_T numBytesAllocated = 0;\n#endif\n\nPRIVATE void insertMemBufRight(MemBufHdr *buf, MemBufHdr *queue)\n{\n    assert(queue != NULL);\n    assert(buf != NULL);\n\n    buf->memBufPrev = queue;\n    buf->memBufNext = queue->memBufNext;\n\n    if (buf->memBufNext != NULL) {\n\tbuf->memBufNext->memBufPrev = buf;\n    }\n\n    queue->memBufNext = buf;\n}\n\nPRIVATE void removeMemBuf(MemBufHdr *buf)\n{\n    MemBufHdr *rightMemBuf;\n    MemBufHdr *leftMemBuf;\n\n    assert(buf != NULL);\n\n    rightMemBuf = buf->memBufNext;\n    leftMemBuf  = buf->memBufPrev;\n\n    if (rightMemBuf != NULL) {\n\trightMemBuf->memBufPrev = leftMemBuf;\n    }\n    if (leftMemBuf != NULL) {\n\tleftMemBuf->memBufNext = rightMemBuf;\n    }\n\n    buf->memBufNext = NULL;\n    buf->memBufPrev = NULL;\n}\n\nPRIVATE boolean_T moveRight(MemBufHdr *buf)\n{\n    MemBufHdr *buf2;\n\n    assert(buf != NULL);\n\n    if (buf->memBufNext == NULL) {\n\treturn false;\n    } else {\n\tbuf2 = buf->memBufNext;\n\tremoveMemBuf(buf);\n\tinsertMemBufRight(buf,buf2);\n    }\n    return true;    \n}\n\nPRIVATE boolean_T sortRight(MemBufHdr *buf)\n{\n    assert(buf != NULL);\n\n    if ((buf->memBufNext != NULL) && (buf > buf->memBufNext)) {\n\treturn moveRight(buf);\n    }\n    return false;\n}\n\nPRIVATE boolean_T sortLeft(MemBufHdr *buf)\n{\n    assert(buf != NULL);\n\n    if ((buf->memBufPrev != NULL) && (buf < buf->memBufPrev)) {\n\treturn moveRight(buf->memBufPrev);\n    }\n    return false;\n}\n\nPRIVATE boolean_T mergeWithMemBufOnRight(MemBufHdr *buf)\n{\n    assert(buf != NULL);\n\n    /*\n     * If this memory buffer is adjacent to a free memory buffer to its right,\n     * merge the two memory buffers into one contiguous free memory buffer.\n     */\n    if (buf->memBufNext != NULL) {\n\tMemBufHdr *leftMemBuf   = buf;\n\tMemBufHdr *rightMemBuf  = buf->memBufNext;\n\t\n\t/* Assumes data portion of mem buf is contiguous with mem buf header. */\n\tchar *pointer1 = ((char *)leftMemBuf + sizeof(MemBufHdr) + leftMemBuf->size);\n\tchar *pointer2 = (char *)leftMemBuf->memBufNext;\n\n\tif (pointer1 == pointer2)\n        {\n            removeMemBuf(rightMemBuf);\n            leftMemBuf->size += rightMemBuf->size + sizeof(MemBufHdr);\n            return true;\n        }\n    }\n    return false;\n}\n\nPRIVATE boolean_T mergeMemBuf(MemBufHdr *buf)\n{\n    boolean_T statusRight = false;\n    boolean_T statusLeft  = false;\n\n    assert(buf != NULL);\n\n    statusRight = mergeWithMemBufOnRight(buf);\n\n    if (buf->memBufPrev != NULL) {\n        statusLeft = mergeWithMemBufOnRight(buf->memBufPrev);\n    }\n\n    return (statusRight | statusLeft);\n}\n\nPRIVATE MemBufHdr *inUseQueueFindMemBufHdr(void *mem)\n{\n    MemBufHdr *LocalBuf;\n\n    assert(mem != NULL);\n\n    LocalBuf = &InUseQueue;\n\n    if (LocalBuf->MemBuf == mem) return LocalBuf;\n\n    while (LocalBuf->memBufNext != NULL) {\n\tLocalBuf = LocalBuf->memBufNext;\n        if (LocalBuf->MemBuf == mem) return LocalBuf;\n    }\n\n    return NULL;\n}\n\nPRIVATE void inUseQueueInsert(MemBufHdr *buf)\n{\n    MemBufHdr *LocalBuf;\n\n    assert(buf != NULL);\n\n    LocalBuf = &InUseQueue;\n    while (LocalBuf->memBufNext != NULL) {\n\tLocalBuf = LocalBuf->memBufNext;\n\tcontinue;\n    }\n    insertMemBufRight(buf, LocalBuf);\n}\n\nPRIVATE void sortQueue(MemBufHdr *buf)\n{\n    int count = 1;\n\n    assert(buf != NULL);\n\n    /* Bi-directional bubble sort...\n     *\n     * Whatever packet given, move it left until the packet to the\n     * left belongs there, or there is no packet to the left.\n     *\n     * If there is a packet to the left, move it to the left as\n     * above. \n     *\n     * If there is no packet to the left, reverse direction moving\n     * packets to the right.\n     *\n     * Repeat this until no packets are moved.\n     */\n\n    /* While something moves... */\n    while (count > 0) {\n\tcount = 0;\n\n\t/* Bubble left. */\n\twhile (1) {\n\t    /* Move the current packet as far left as it will go. */\n\t    if (sortLeft(buf)) {\n\t\tcount++;\n\t\tcontinue;\n\t    } else {\n\t\t/* Try to merge the packet with its neighbor to the right. */\n\t\tmergeMemBuf(buf);\n\n\t\t/* Move the MemBufHdr to the left, if possible, and\n\t\t * continue bubbling left.\n\t\t */ \n\t\tif (buf->memBufPrev != NULL) {\n\t\t    buf = buf->memBufPrev;\n\t\t    continue;\n\t\t} else {\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\t/* All done bubbling to the left. Now bubble to the right. */\n\n\t/* Bubble right. */\n\twhile (1) {\n\t    /* Move the current packet as far right as it will go. */\n\t    if (sortRight(buf)) {\n\t\tcount++;\n\t\tcontinue;\n\t    } else {\n\t\t/* Try to merge the packet with its neighbor to the right. */\n\t\tmergeMemBuf(buf);\n\n\t\t/* Move the MemBufHdr to the right, if possible, and\n\t\t * continue bubbling right.\n\t\t */ \n\t\tif (buf->memBufNext != NULL) {\n\t\t    buf = buf->memBufNext;\n\t\t    continue;\n\t\t} else {\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n}\n\nPRIVATE void initFreeQueue(void)\n{\n    MemBufHdr *initialFreeMemBuf = NULL;\n\n#ifdef VERBOSE\n    /* There is always at least one header allocated from the buffer. */\n    numBytesAllocated = sizeof(MemBufHdr);\n#endif\n\n    /* The FreeQueue is a pointer to a \"free\" buffer. */\n    FreeQueue = (MemBufHdr *)MemoryBuffer;\n\n    /*\n     * The first free packet describes blocks of free space in the free queue\n     * buffer (initially the whole buffer) and, as space becomes fragmented, is\n     * linked to other \"free\" buffers.\n     */\n    initialFreeMemBuf = FreeQueue;\n\n    /*\n     * The location and size of the initial free buffer describes the whole\n     * memory buffer.\n     */\n    initialFreeMemBuf->MemBuf = (char *)initialFreeMemBuf + sizeof(MemBufHdr);\n    initialFreeMemBuf->size   = sizeof(MemoryBuffer) - sizeof(MemBufHdr);\n\n    /*\n     * When there is only one, contiguous memory buffer, the initial free\n     * buffer is linked to no other free buffers. When there are more than\n     * one, or discontiguous free buffers, these links tie together all free\n     * buffers.\n     */\n    initialFreeMemBuf->memBufPrev = NULL;\n    initialFreeMemBuf->memBufNext = NULL;\n}\n\nPRIVATE MemBufHdr *findFirstFreeMemBuf(const int bufSize)\n{\n    /* Get the first free packet. */\n    MemBufHdr *buf = FreeQueue;\n\n    /*\n     * Loop until we find a free packet big enough for our request or we\n     * run out of free packets.\n     */\n    while (buf != NULL) {\n        /* Take the first free packet that fits. */\n        if (buf->size >= bufSize) {\n            /* Got it. Break out to continue. */\n            break;\n        }\n        /* Get the next free packet. */\n        buf = buf->memBufNext;\n    }\n\n    return buf;\n}\n\nPUBLIC void ExtModeFree(void *mem)\n{\n    MemBufHdr *buf = NULL;\n\n    if (mem == NULL) return;\n\n    /* Find the header associated with the memory pointer. */\n    buf = inUseQueueFindMemBufHdr(mem);\n    assert(buf != NULL);\n\n#ifdef VERBOSE\n    numBytesAllocated -= (buf->size + sizeof(MemBufHdr));\n    printf(\"\\nBytes allocated: %d out of %d.\\n\", numBytesAllocated, EXTMODE_STATIC_SIZE);\n#endif\n\n    /* Remove the buffer from the linked list. */\n    removeMemBuf(buf);\n\n    /* Put the buffer back in the free queue. */\n    insertMemBufRight(buf, FreeQueue);\n    mergeMemBuf(buf);\n}\n\nPUBLIC void *ExtModeCalloc(uint32_T number, uint32_T size)\n{\n    uint32_T numBytes = number*size;\n    void     *mem     = ExtModeMalloc(numBytes);\n\n    if (mem == NULL) goto EXIT_POINT;\n\n    memset(mem, 0, numBytes);\n\n  EXIT_POINT:\n    return mem;\n}\n\nPUBLIC void *ExtModeMalloc(uint32_T size)\n{\n    boolean_T keepTrying = false;\n\n    MemBufHdr *LocalMemBuf = NULL; /* Requested buffer (NULL if none available). */\n    MemBufHdr *FreeMemBuf = NULL;  /* First free buffer big enough for request. */\n\n    /*\n     * Must allocate enough space for the requested number of bytes plus the\n     * size of the memory buffer header.\n     */\n    int sizeToAlloc = size + sizeof(MemBufHdr);\n\n    while (!keepTrying) {\n        keepTrying = true;\n\n        LocalMemBuf = NULL;\n        FreeMemBuf  = NULL;\n\n        /* Initialize the free queue. */\n        if (FreeQueue == NULL) initFreeQueue();\n\n        /* Find first free packet big enough for our request. */\n        FreeMemBuf = findFirstFreeMemBuf(sizeToAlloc);\n\n        if (FreeMemBuf == NULL) {\n            /* We couldn't find a free buffer.  Run garbage collection to merge\n               free buffers together and try again. */\n            sortQueue(FreeQueue);\n\n            FreeMemBuf = findFirstFreeMemBuf(sizeToAlloc);\n        }\n\n        /* No free buffers are available which satisfy the request. */\n        if (FreeMemBuf == NULL) goto EXIT_POINT;\n\n        /*\n         * Found a free buffer with enough space.  Carve out the exact buffer size\n         * needed from the end of the free buffer.\n         */\n        LocalMemBuf = (MemBufHdr *)(FreeMemBuf->MemBuf +\n                                    FreeMemBuf->size -\n                                    sizeToAlloc);\n\n        /*\n         * The pointer to the free memory must be longword aligned.  If it\n         * is not, adjust the size to allocate and try again.\n         */\n        {\n            int alignBytes = (int)((ptrdiff_t)LocalMemBuf % 4);\n            if (alignBytes) {\n                sizeToAlloc += (4-alignBytes);\n                keepTrying = false;\n            }\n        }\n    }\n\n    /* Set up the new packet's info. */\n    LocalMemBuf->memBufPrev = NULL;\n    LocalMemBuf->memBufNext = NULL;\n    LocalMemBuf->MemBuf     = (char *)LocalMemBuf + sizeof(MemBufHdr);\n    LocalMemBuf->size       = size;\n\n    /* Insert the newly created buffer into the InUseQueue. */\n    inUseQueueInsert(LocalMemBuf);\n\n    /* Update the free packet's size to reflect giving up a piece. */\n    FreeMemBuf->size -= sizeToAlloc;\n\n  EXIT_POINT:\n    if (LocalMemBuf) {\n#ifdef VERBOSE\n        numBytesAllocated += sizeToAlloc;\n        printf(\"\\nBytes allocated: %d out of %d.\\n\", numBytesAllocated, EXTMODE_STATIC_SIZE);\n#endif\n        return LocalMemBuf->MemBuf;\n    }\n\n#ifdef VERBOSE\n    printf(\"\\nBytes allocated: %d out of %d.\", numBytesAllocated+sizeToAlloc, EXTMODE_STATIC_SIZE);\n    printf(\"\\nMust increase size of static allocation!\\n\");\n#endif\n    return NULL;\n}\n"},{"name":"mw_extrathreads.c","type":"source","group":"legacy","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2017-2021 The MathWorks, Inc. */\n//File: mw_extrathreads.c\n\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x)  #x\n\n#define MW_StringifyDefineFunction(x,y) MW_StringifyDefineExpandedFunction(x,y)\n#define MW_StringifyDefineExpandedFunction(x,y)  x##y\n\n#define MW_StringifyDefineX(x) MW_StringifyDefineExpandedX(x)\n#define MW_StringifyDefineExpandedX(x)  x.##h\n\n#define MW_StringifyDefineTypesX(x) MW_StringifyDefineExpandedTypesX(x)\n#define MW_StringifyDefineExpandedTypesX(x)  x##_types.h\n\n#define MW_StringifyDefinePrivateX(x) MW_StringifyDefineExpandedPrivateX(x)\n#define MW_StringifyDefineExpandedPrivateX(x)  x##_private.h\n\n//#include MW_StringifyDefine(MW_StringifyDefineX(MODEL))\n#include MW_StringifyDefine(MODEL.h)\n#include MW_StringifyDefine(MW_StringifyDefineTypesX(MODEL))\n#include MW_StringifyDefine(MW_StringifyDefinePrivateX(MODEL))\n\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/fcntl.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <poll.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <pthread.h>\n#include <stdbool.h>\n\n#include \"rtwtypes.h\"\n\n#ifdef EXT_MODE\n#include \"rtwtypes.h\"\n#include <ext_work.h>\n#include <ext_svr.h>\n#include <ext_share.h>\n#include <updown.h>\nvoid create_background_thread(void);\n#endif\n\nextern volatile boolean_T runModel;\nextern int run_flag;\n\npthread_t tid;\n\nint connfd = 0, connfd_GUI;\nstatic int \t  yes = 1;\nint sockfd, sockfd_GUI;\nint buff_size = 38400; // Maximum buffer size of the socket\nstruct sockaddr_in serv_addr;\nint  clientConnect = 0;\n\nvoid* keyboardserver_thread(void* i);\nvoid create_referencevalserver_thread(void);\n\n#ifdef PARROT_XCP_EXT_MODE\n#include \"ext_mode.h\"\n#include \"xcp_ext_classic_trigger.h\"\nuint8_T* baseAddress = 0;\nextern int landDrone;\nchar __executable_start;\n\nuint8_T *xcpAddressGet_parrot(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) (baseAddress + address);\n}\n\nvoid initialize_XCP_baseAddress(){\n    FILE* addressFile = fopen(\"/data/edu/address\", \"r\");\n    unsigned int addressOfLandDrone = 0;\n    if(addressFile < 0){\n        printf(\"Address file missing. Exiting process...\\n\");\n        exit(0);\n    }\n    fscanf(addressFile,\"%d\", &addressOfLandDrone);\n    baseAddress = (uint8_T*) &landDrone - addressOfLandDrone;\n}\n#endif\n\nvoid* keyboardserver_thread(void* i)\n{\n    struct sched_param param;\n    param.sched_priority = 9;\n    pthread_setschedparam(pthread_self(), 2, &param);\n    printf(\"keyboardserver_thread(): Entered the Keyboard Server thread... \\n\");\n    \n    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        printf(\"keyboardserver_thread(): ERROR : Could not create socket \\n\");\n        exit(1);\n    }\n    \n    printf(\"keyboardserver_thread(): Successfully created socket... \\n\");\n    \n    memset(&serv_addr, '0', sizeof(serv_addr));\n    \n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    serv_addr.sin_port = htons(12391);\n    \n    printf(\"keyboardserver_thread(): Bind socket... \\n\");\n    \n    // Fix : We could not run the Spider Flight Continuously. We need to wait for some time before you start the next flight.\n    // To fix the issue we are creating Socket with REUSEADDR.\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) < 0)\n    {\n        printf(\"keyboardserver_thread(): ERROR: Failure in Reusing address.. with error: %d\\n\",errno);\n        exit(1);\n    }\n    \n    \n    if(bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        printf(\"keyboardserver_thread(): ERROR Connection to reference value server failed %d \\n\", errno);\n        exit(1);\n    }\n    else\n    {\n        printf(\"keyboardserver_thread(): Bind completed .. listening to the socket !\\n\");\n        \n        if (listen(sockfd, 10)<0)\n        {\n            printf(\"keyboardserver_thread(): Socket error (listen) %d\\n\",errno);\n            exit(1);\n        }\n        connfd = accept(sockfd, (struct sockaddr*)NULL, NULL);\n        setsockopt(connfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n        setsockopt(connfd, SOL_SOCKET, SO_SNDBUF, &buff_size, sizeof(buff_size));\n        clientConnect = 1;\n        printf(\"keyboardserver_thread(): Received connection from the host! \\n\");\n    }\n    \n   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// \n    \n     if((sockfd_GUI = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n        printf(\"keyboardserver_thread(): ERROR : Could not create GUI socket\\n\");\n        exit(1);\n    }\n    \n    printf(\"keyboardserver_thread(): Successfully created GUI socket... \\n\");\n    \n    memset(&serv_addr, '0', sizeof(serv_addr));\n    \n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    serv_addr.sin_port = htons(24099);\n    \n    printf(\"keyboardserver_thread(): Bind GUI socket...\\n\");\n    \n    // Fix : We could not run the Spider Flight Continuously. We need to wait for some time before you start the next flight.\n    // To fix the issue we are creating Socket with REUSEADDR.\n    if (setsockopt(sockfd_GUI, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) < 0)\n    {\n        printf(\"keyboardserver_thread(): ERROR: Failure in Reusing address in GUI.. with error: %d\\n\",errno);\n        exit(1);\n    }\n    \n    \n    if(bind(sockfd_GUI, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n        printf(\"keyboardserver_thread(): ERROR Connection to GUI server failed %d \\n\", errno);\n        exit(1);\n    }\n    else\n    {\n        printf(\"keyboardserver_thread(): Bind completed .. listening to the GUI socket !\\n\");\n        \n        if (listen(sockfd_GUI, 10)<0)\n        {\n            printf(\"keyboardserver_thread(): GUI Socket error (listen) %d\\n\",errno);\n            exit(1);\n        }\n        connfd_GUI = accept(sockfd_GUI, (struct sockaddr*)NULL, NULL);\n        setsockopt(connfd_GUI, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));\n        setsockopt(connfd_GUI, SOL_SOCKET, SO_SNDBUF, &buff_size, sizeof(buff_size));\n        printf(\"keyboardserver_thread(): Received connection to GUI from the host! \\n\");\n    }\n    \n   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    return NULL;\n}\n\nvoid create_referencevalserver_thread(void)\n{\n    int err;\n    pthread_t img_tid;\n    int policy;\n    struct sched_param param;\n    pthread_attr_t attr;\n    size_t stacksize;\n    \n    pthread_attr_init(&attr);\n    pthread_attr_getstacksize(&attr,&stacksize);\n    err = pthread_attr_setstacksize(&attr,PTHREAD_STACK_MIN);\n    printf(\"create_referencevalserver_thread(): stack size before reference value thread creation %d err=%d\\n\", stacksize,err);\n    \n    img_tid = pthread_self();\n    printf(\"create_referencevalserver_thread(): reference value server thread id = %d \\n\",(int) img_tid);\n    pthread_getschedparam(img_tid, &policy,&param);\n    printf(\"create_referencevalserver_thread(): reference value server  policy = %d pri=%d\\n\", (int)policy,param.sched_priority);\n    \n    // param1.sched_priority = param.sched_priority - 1;\n    // pthread_setschedparam(tid,policy,&param1);\n    err = pthread_create(&tid, &attr, &keyboardserver_thread, NULL);\n    if (err != 0)\n        printf(\"create_referencevalserver_thread(): ERROR: can't create thread :[%s]\", strerror(err));\n    else\n        printf(\"create_referencevalserver_thread(): Reference Server Thread created successfully\\n\");\n    \n    pthread_attr_getstacksize(&attr,&stacksize);\n    printf(\"create_referencevalserver_thread(): stacksize after reference thread creation %d \\n\", stacksize);\n}\n\n#ifdef EXT_MODE\n\nint background_task_completed = false;\npthread_t ext_tid;\n\nvoid* extmode_thread(void* i);\n\n#ifdef PARROT_XCP_EXT_MODE\n    void* extmode_thread(void* i)\n    {\n        static int counter = 0;\n        counter++;\n        \n        if (counter == 1)\n        {\n            int policy;\n            struct sched_param param ;\n            \n            pthread_getschedparam(pthread_self(), &policy,&param);\n            printf(\"extmode_thread(): External mode thread policy = %d and priority=%d\\n\", (int)policy,param.sched_priority);\n            \n            /* initialize external mode */\n            extmodeParseArgs(0, NULL);\n            rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL,_M), 0);\n            MW_StringifyDefineFunction(MODEL,_initialize)();\n            /* External mode */\n            extmodeInit(MW_StringifyDefineFunction(MODEL,_M)->extModeInfo, &rtmGetTFinal(MW_StringifyDefineFunction(MODEL,_M)));\n            \n            { \n                extmodeWaitForHostRequest(EXTMODE_WAIT_FOREVER);\n                if (extmodeStopRequested()) {\n                    rtmSetStopRequested(MW_StringifyDefineFunction(MODEL,_M), true);\n                }\n            }\n            xcpExtModeClassicTriggerEnabled(0);\n        }\n        while(runModel)\n        {\n            boolean_T rtmStopReq = false;\n            extmodeBackgroundRun(); // This is used when the Image processing is enabled along with multitasking. This will upload the step0() and step1() data.\n\n            if (extmodeStopRequested())\n            {\n                printf(\"extmode_thread(): Thread received STOP command \\n\");\n                rtmSetStopRequested(MW_StringifyDefineFunction(MODEL,_M), true);\n                // Reason for the following code:\n                // If the user presses stop button before starting the flight code i.e before starting\n                // the execution step code.\n                extmodeReset();\n                MW_StringifyDefineFunction(MODEL,_terminate)();\n                runModel = 0;\n            }\n            \n            if (run_flag == 0)\n            {\n                extmodeReset();\n                MW_StringifyDefineFunction(MODEL,_terminate)();\n                runModel = 0;\n            }\n        }\n        \n        if (runModel == 0)\n        {\n            extmodeReset();\n            MW_StringifyDefineFunction(MODEL,_terminate)();\n        }\n        \n        background_task_completed = true;\n        return NULL;\n    }\n\n#else\n    void* extmode_thread(void* i)\n    {\n        static int counter = 0;\n        counter++;\n        \n        if (counter == 1)\n        {\n            int policy;\n            struct sched_param param ;\n            \n            pthread_getschedparam(pthread_self(), &policy,&param);\n            printf(\"extmode_thread(): External mode thread policy = %d and priority=%d\\n\", (int)policy,param.sched_priority);\n            \n            /* initialize external mode */\n            rtParseArgsForExtMode(0, NULL);\n            rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL,_M), 0);\n            MW_StringifyDefineFunction(MODEL,_initialize)();\n            /* External mode */\n            rtSetTFinalForExtMode(&rtmGetTFinal(MW_StringifyDefineFunction(MODEL,_M)));\n            rtExtModeCheckInit(1);\n    \n            { \n                boolean_T rtmStopReq = false;\n                rtExtModeWaitForStartPkt(MW_StringifyDefineFunction(MODEL,_M)->extModeInfo, 2,\n                        &rtmStopReq);\n                if (rtmStopReq) {\n                    rtmSetStopRequested(MW_StringifyDefineFunction(MODEL,_M), true);\n                }\n            }\n            rtERTExtModeStartMsg();\n        }\n        while(runModel)\n        {\n            boolean_T rtmStopReq = false;\n            #ifdef MW_HAS_IMAGE_PROCESSING\n                rtExtModeOneStep(MW_StringifyDefineFunction(MODEL,_M->extModeInfo), 2, &rtmStopReq); // This is used when the Image processing is enabled along with multitasking. This will upload the step0() and step1() data.\n            #else\n                rtExtModeOneStep(MW_StringifyDefineFunction(MODEL,_M->extModeInfo), 1, &rtmStopReq); // This is used when only the control code is running. Multitasking is not enabled in this case and only the step() data is required to be uploaded.\n            #endif \n            if (rtmStopReq)\n            {\n                printf(\"extmode_thread(): Thread received STOP command \\n\");\n                rtmSetStopRequested(MW_StringifyDefineFunction(MODEL,_M), true);\n                // Reason for the following code:\n                // If the user presses stop button before starting the flight code i.e before starting\n                // the execution step code.\n                rtExtModeShutdown(1);\n                MW_StringifyDefineFunction(MODEL,_terminate)();\n                runModel = 0;\n            }\n            \n            if (run_flag == 0)\n            {\n                rtExtModeShutdown(1);\n                MW_StringifyDefineFunction(MODEL,_terminate)();\n                runModel = 0;\n            }\n        }\n        \n        if (runModel == 0)\n        {\n            rtExtModeShutdown(1);\n            MW_StringifyDefineFunction(MODEL,_terminate)();\n        }\n        \n        background_task_completed = true;\n        return NULL;\n    }   \n#endif\n\nvoid create_background_thread(void)\n{\n    int err, status;\n    pthread_attr_t attr;\n    size_t stacksize;\n    struct sched_param param;\n    \n    pthread_attr_init(&attr);\n    err = pthread_attr_setinheritsched(&attr,PTHREAD_EXPLICIT_SCHED);\n    printf(\"create_background_thread(): ext thread inherit scheduler option error=%d\\n\", err);\n    \n    status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    printf(\"create_background_thread(): value of detach status=%d\\n\", status);\n    \n    err = pthread_attr_setstacksize(&attr,PTHREAD_STACK_MIN);\n    printf(\"create_background_thread(): stacksize before thread creation err=%d\\n\", err);\n    \n    /* In case of Mambo , the policy of rsedu_control.c is set as 2 (SCHED_RR) and priority 32\n     * In case of Rolling Spider , the policy of rsedu_control.c is set as 0 (SCHED_OTHER) and priority 0\n     * Setting the policy and priority of External Mode thread as 0 (SCHED_OTHER) and priority 0 */\n    \n    status = pthread_attr_setschedpolicy(&attr, SCHED_OTHER);\n    printf(\"create_background_thread(): value of scheduler policy status=%d\\n\", status);\n\n    param.sched_priority = 0;\n    status = pthread_attr_setschedparam(&attr, &param);\n    printf(\"create_background_thread(): value of scheduler param status=%d\\n\", status);\n    \n    err = pthread_create(&ext_tid, &attr, &extmode_thread, NULL);\n    if (err != 0)\n        printf(\"create_background_thread(): can't extmode thread :[%s]\", strerror(err));\n    else\n        printf(\"create_background_thread(): External mode Thread created successfully\\n\");\n    \n    pthread_attr_getstacksize(&attr,&stacksize);\n    printf(\"create_background_thread(): stacksize after ext thread creation %d \\n\", stacksize);\n    \n}\n#endif\n"},{"name":"ptimer.c","type":"source","group":"legacy","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2017-2018 The MathWorks, Inc. */\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <string.h>\n#include \"ptimer.h\"\n#include \"MW_target_hardware_resources.h\"\n\nvoid ptimer_init(const char funname[], FILE **ptfilepntr,int *run_flag)\n{\n    char* fullfile = (char*)(malloc(strlen(\"/tmp/edu/ptimes/pt_%s.txt\") + strlen(funname) + 1));\n    \n    mkdir(\"/tmp/edu\", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n    mkdir(\"/tmp/edu/ptimes\", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n    sprintf(fullfile,\"/tmp/edu/ptimes/pt_%s.txt\",funname);\n    printf(\"In %s; Fullpath for ptimes: %s \\n\",__func__,fullfile);\n    *ptfilepntr = fopen(fullfile,\"wb\");\n    \n    if (*ptfilepntr == NULL)\n    {\n        printf(\"Error opening ptimes file! \\n\");\n        if (run_flag!=NULL)\n        {\n            *run_flag=0;\n        }\n        return;\n    }\n    else\n    {\n        fclose(*ptfilepntr);\n        *ptfilepntr = fopen(fullfile,\"a\");\n    }\n    \n    free(fullfile);\n}\n\nvoid ptimer_start(long long *start)\n{\n    struct timeval tvalBefore;\n    /* set up start time data */\n    gettimeofday (&tvalBefore, NULL);\n    /* Start time in nanoseconds */\n    *start = tvalBefore.tv_sec*MICROS + tvalBefore.tv_usec;\n}\n\nlong long ptimer_stopstore(long long start, FILE *ptfilepntr)\n{\n    struct timeval tvalAfter;\n    long long end, elapsed;\n    \n    //-------------\n    /* get elapsed time */\n    gettimeofday (&tvalAfter, NULL);\n    /* Elapsed time in microseconds */\n    end = tvalAfter.tv_sec*MICROS + tvalAfter.tv_usec;\n    elapsed =  end - start;\n    /* Display/print time in microseconds or something */\n    if ((1 == MW_CONFIG_ENABLEPROFILING) && ptfilepntr != NULL)\n    {\n        fprintf(ptfilepntr,\"%lld, %lld, %lld \\n\",start,end,elapsed);\n    }\n    return elapsed;\n}\n\n"},{"name":"rsedu_control.c","type":"source","group":"legacy","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2017-2021 The MathWorks, Inc. */\n/*  @file: rsedu_control.c\n *\n * @description: This module takes care of fully controlling the drone: Stabilizing based on sensor measurements, crash handling. For this purpose, it also calls the simulink-model.\n *\n */\n\n#include \"rsedu_control.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/fcntl.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <poll.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <pthread.h>\n#include <sched.h>\n#include \"rtwtypes.h\"\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <stdbool.h>\n#include \"ptimer.h\"\n#ifdef EXT_MODE\n#include \"rtwtypes.h\"\n#include <ext_work.h>\n#include <ext_svr.h>\n#include <ext_share.h>\n#include <updown.h>\n#include \"MW_target_hardware_resources.h\"\n\n#ifdef PARROT_XCP_EXT_MODE\n#include \"ext_mode.h\"\n#endif\n\nvoid create_background_thread(void);\n#endif\n\n#include \"controlCommand.h\"\n#include <stdbool.h>\n\nvoid create_referencevalserver_thread(void);\nvolatile boolean_T runModel = true;\n\n//! Flight time cycles @note code runs at 200Hz! So 4000-> 20sec\nint onCycles = 4000;\n//! Amount of calibration cycles\nint calibCycles = 400;\n//! Amount of take off cycles.\nint takeoffCycles       = 200;\n\nextern int clientConnect; // 1 indicates TCP connection established between the drone and host\nextern int connfd, connfd_GUI;\nint run_flag = 1;\nextern int background_task_completed;\n\n/* Received from host*/\nint isMotorOn; // 1 indicates that the drone motors are on\nint isLanding; // 1 indicates drone is in the process of soft landing\nint throttle; // PowerGain of motors (1- 100)\nint flightDuration = 20; // Default flight duration of the drone\nextern int ack; // Acknowledgment flag\nint waitForGrabberCannon = 0;\n#ifdef MW_HAS_IMAGE_PROCESSING\nint runVisionCode= 0;\nextern long long avrgIpTime;\n#endif\n\nint grabberCannonBusy = 0;\nint landDrone = 0;\n\nvoid create_referencevalserver_thread(void);\n\n//--------------------\n// RSEDU_control\n//--------------------\n/**\n * @brief The function RSEDU_control is called at 200Hz to generate reference motor commands based on sensor values\n *\n * @param[in] hal_sensors_data Structure containing sensors current values\n * @param[out] hal_sensors_cmd Structure containing commands to send to motors and LEDs\n */\nvoid RSEDU_control(HAL_acquisition_t* hal_sensors_data, HAL_command_t* hal_sensors_cmd)\n{\n    //flight phases\n    \n    //process control\n    static int counter = 0;\n    static int counter_noOF = 0;\n    // counter to wait for TCP connection request from host\n    static int waitForTCPCounter = 0;\n    \n    // counter to wait for start command from host\n    static int waitForStartCounter = 0;\n    \n    static float MIN_BATTTAKEOFF        = 50.0; // Minimum battery level for take-off\n    static float MIN_BATT               = 30.0; // Minimum battery for continuing flight\n    static int MAX_noOF                 = 50;   // Maximum acceptable numbers of cycles without optical flow\n    \n    //power/usr input\n    static double powerGain = 0;\n    \n    //data handling\n    static double battLevelAvg;\n    \n    //float ofDefined;\n    static bool pressureSensorOk = false;\n    static float ofQuality;\n    \n#if (1 == MW_CONFIG_ENABLEPROFILING)\n    //ptiming - declare and start\n    //------------\n    long long start = 0;\n    static FILE *ptfile;\n#endif\n    \n    //------------\n    \n    // Create shorter aliases for the function arguments\n    HAL_acquisition_t* in = hal_sensors_data;\n    HAL_command_t    * out = hal_sensors_cmd;\n    \n    // Create the necessary Model Specific Buses (data structures) for model run\n    \n    static real32_T calibrationData[8] = {0.0}; // data to be passed to the Model for calib data\n    static CommandBus *keyboardServerCommands = &cmd_inport; // defined in flightControlSystem_types.h\n    static SensorsBus *SensorData = &sensor_inport; // defined in flightControlSystem_types.h\n        \n    if(waitForGrabberCannon){ // This check is active only after the flight is completed. It checks if the cannon/grabber finished executing the current command. \n                              // If this check is not done, and the 'stop' is pressed, the cannon/grabber goes into a bad state.\n        if(grabberCannonBusy) // Check if either the grabber or the cannon is busy executing a command. If true 'return'\n            return;\n        else\n            exit(0); // Else, just exit the program. \n    }   \n    \n    //ABORT FLIGHT and exit if run_flag 0\n    if (run_flag == 0)\n    {\n        stop_flight(out);\n#ifdef EXT_MODE\n        if (background_task_completed == false)\n        {\n            return;\n        }\n#endif\n        \n        if (counter > calibCycles)\n        {\n#ifdef MATFILE_LOGGING\n            printf(\"rsedu_control():Saving logged data after %i cycles... \\n\", counter);\n            rt_StopDataLogging(MATFILE, MW_StringifyDefineFunction(MODEL,_M)->rtwLogInfo);\n            printf(\"rsedu_control(): Saving logged data... DONE \\n\");\n#endif\n        }\n        \n        // Close the optical flow FIFO\n        if (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n        {\n            close(of_fifo);\n        }\n        \n#if (1 == MW_CONFIG_ENABLEPROFILING)\n        fclose(ptfile);\n#endif\n  \n        printf(\"rsedu_control(): Flight Completed after %i cycles ... DONE \\n\", counter);\n        \n#ifdef MW_HAS_IMAGE_PROCESSING\n        printf(\"RSEDU_image_processing: Average image processing time is %lldms \\n\", avrgIpTime);\n#endif\n        MW_StringifyDefineFunction(MODEL,_terminate)();\n        write(connfd_GUI, \"De\", 2);\n        usleep(1000);\n        printf(\"rsedu_control(): Good night! \\n\");\n        \n        waitForGrabberCannon = 1; // This flag is used to check if a fire command or a grab command is active. Only if it is inactive, exit the program.\n        return;\n        //exit(0);\n    }\n    \n    //Process Control\n    counter++;\n#if (1 == MW_CONFIG_ENABLEPROFILING)\n    ptimer_start(&start);\n#endif\n    //==================\n    //Flight Stages s0-4\n    //==================\n    \n    //s0: Initialize (server connection, get user settings)\n    // ----------------------------------------------------\n    if (counter == 1)\n    {\n        pthread_t img_tid;\n        int policy;\n        struct sched_param param;\n        \n#ifdef PARROT_XCP_EXT_MODE\n        initialize_XCP_baseAddress();\n#endif\n        \n        img_tid = pthread_self();\n        printf(\"rsedu_control(): Control processing thread id = %d \\n\",(int) img_tid);\n        pthread_getschedparam(img_tid, &policy,&param);\n        printf(\"rsedu_control(): Control thread policy = %d pri=%d\\n\", (int)policy,param.sched_priority);\n        \n        printf(\"rsedu_control(): Battery output voltage Integrated: %5.2f V - %0d percents\\n\", in->HAL_vbat_SI.vbat_V, (int)in->HAL_vbat_SI.vbat_percentage);\n        printf(\"rsedu_control(): used: %d, users: %d, gyrotemp %f, acctemp %f, presstmp %f \\n\", (int)in->used, (int)in->count_user, in->HAL_gyro_SI.temperature, in->HAL_acc_SI.temperature, in->HAL_pressure_SI.temperature);\n        // Initialize the timer for communicating with the drone\n#if (1 == MW_CONFIG_ENABLEPROFILING)\n        ptimer_init(__func__, &(ptfile), &run_flag);\n#endif\n    }\n    \n    //s0: Comms and Model (Initialize inter-thread communication, model and calibration data)\n    // ----------------------------------------------------\n    else if (counter == 2)\n    {\n#ifdef MAMBO\n        out->HAL_ultrasound_command = ULTRASOUND_CMD_START;\n#endif\n        // Connect to Optical Flow\n        if (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n        {\n            if (open_optical_flow_comm() == RETURN_FAIL)\n            {\n                printf(\"rsedu_control(): WARNING optical flow might not be running, %d!\\n\\n\", of_fifo);\n            }\n            else\n            {\n                printf(\"rsedu_control(): Got optical flow connection, %d!\\n\", of_fifo);\n            }\n        }\n        else\n        {\n            printf(\"rsedu_control(): Optical Flow deactivated! \\n\");\n        }\n    }\n    //s0: Wait for the reference value server connection and also wait for the takeoff command\n    else if (counter == 3)\n    {\n        //keep both fifos empty (Optical Flow and Vision)\n        if (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n        {\n            read(of_fifo, (float*)(&of_data), sizeof(of_data));\n        }\n        \n        if (clientConnect == 0)\n        {\n            if (waitForTCPCounter == 0)\n            {\n                create_referencevalserver_thread();\n            }\n#ifdef EXT_MODE\n            if (waitForTCPCounter == 1)\n            {\n                // Create background thread only when external mode is enabled\n                create_background_thread();\n            }\n#endif\n            /*Print on droneFlightlog every 1 second*/\n            if (waitForTCPCounter % 200 == 0)\n            {\n                printf(\"rsedu_control(): Waiting for connection request from host! \\n\");\n                printf(\"\\n\\n **** Sensor Values **** \\n\");\n                printf(\"rsedu_control(): sonar altitude: %fmeters, pressure: %fpascal, gyrotemp: %fcelsius\\n\", in->HAL_ultrasound_SI.altitude, in->HAL_pressure_SI.pressure,in->HAL_gyro_SI.temperature);\n                printf(\"rsedu_control(): gyro x: %frad/s, y: %frad/s, z: %frad/s\\n\", in->HAL_gyro_SI.x,in->HAL_gyro_SI.y,in->HAL_gyro_SI.z);\n                printf(\"rsedu_control(): accel x: %fm/s2, y: %fm/s2, z: %fm/s2\\n\", in->HAL_acc_SI.x,in->HAL_acc_SI.y,in->HAL_acc_SI.z);\n                printf(\"rsedu_control(): Battery output voltage Integrated: %5.2fV - %0d percents\\n\", in->HAL_vbat_SI.vbat_V, (int)in->HAL_vbat_SI.vbat_percentage);\n            }\n            waitForTCPCounter ++;\n            counter = 2;\n            return;\n        }\n        else if (isMotorOn == 0)\n        {\n            /*Print on droneFlightlog every 1 second*/\n            if (waitForStartCounter % 200 == 0)\n            {\n                printf(\"rsedu_control(): Waiting for takeoff command from host! \\n\");\n            }\n            waitForStartCounter++;\n            /* Wait till start command is received. Do not start counter*/\n            counter = 2;\n            \n            /*Read if start command has been received*/\n            fcntl(connfd, F_SETFL, O_NONBLOCK);\n            memset(recvBuff, '\\0', sizeof(recvBuff));\n            recv(connfd, recvBuff, sizeof(recvBuff), O_NONBLOCK);\n            processRequest(connfd,recvBuff, in, out, keyboardServerCommands, &run_flag); //  function call to process data sent from MATLAB APIs\n            return;\n        }\n        \n        /* Set powerGain and flight duration values received from host */\n        onCycles = flightDuration * 200;\n        powerGain = throttle/100.0;\n        \n        /* Initialize model */\n        printf(\"rsedu_control(): Simulink model init started! \\n\");\n        \n        rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL,_M), 0);\n        MW_StringifyDefineFunction(MODEL,_initialize)();\n        printf(\"rsedu_control(): Simulink model init completed! \\n\");\n        \n        /*Hardcoding MAT-File logging time to Flight time*/\n#ifdef MATFILE_LOGGING\n        rtmSetTFinal(MW_StringifyDefineFunction(MODEL,_M), flightDuration);\n#endif\n        \n        //init sensor calibration measurements\n        printf(\"rsedu_control(): Initializing Calibration Data! \\n\");\n        initialize_calibration_data(calibrationData, &battLevelAvg, in);\n        \n        //Activate motors\n        out->command = BLDC_CMD_START;\n        printf(\"rsedu_control(): Drone Motors Activated! \\n\");\n        \n        //s1: Record calibration data\n        // --------------------------\n    }\n    else if (counter < calibCycles)\n    {\n        \n        if (counter%200 == 0)\n        {\n            printf(\"rsedu_control(): Calibrating Data . . . \\n\");\n        }\n        perform_calibration(counter, calibrationData,&battLevelAvg, in);\n        \n        if (in->HAL_pressure_SI.pressure != 0)\n        {\n            pressureSensorOk = true;\n        }\n        \n        //keep both fifos empty (Optical Flow and Vision)\n        if (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n        {\n            read(of_fifo, (float*)(&of_data), sizeof(of_data));\n        }\n        \n        //Power motors with 0 velocity\n        stop_flight(out);\n        \n        return;\n        \n        //s2: Initialize dynamic model for control\n        // --------------------------------------\n    }\n    else if (counter == calibCycles)\n    {\n        printf(\"rsedu_control(): Batterylevel: %f\\n\", battLevelAvg);\n        \n        // Passing calibration data to Simulink\n        SensorData->SensorCalibration[0] = calibrationData[0];\n        SensorData->SensorCalibration[1] = calibrationData[1];\n        SensorData->SensorCalibration[2] = calibrationData[2];\n        SensorData->SensorCalibration[3] = calibrationData[3];\n        SensorData->SensorCalibration[4] = calibrationData[4];\n        SensorData->SensorCalibration[5] = calibrationData[5];\n        SensorData->SensorCalibration[6] = calibrationData[6];\n        SensorData->SensorCalibration[7] = calibrationData[7];\n        \n        printf(\"rsedu_control(): Sensorcal: %f :: %f :: %f :: %f :: %f :: %f :: %f :: %f \\n\",\n                calibrationData[0],\n                calibrationData[1],\n                calibrationData[2],\n                calibrationData[3],\n                calibrationData[4],\n                calibrationData[5],\n                calibrationData[6],\n                calibrationData[7]);\n        \n        //Stop if angled take-off\n        if ((!MW_CONFIG_NOSAFETY) && fabs(9.81 + calibrationData[2]) > 0.7)\n        {\n            run_flag = 0;\n            printf(\"rsedu_control(): ERROR: Please take off from a level surface! \\n\");\n            return;\n        }\n        \n        if (!pressureSensorOk)\n        {\n            run_flag = 0;\n            printf(\"rsedu_control(): ERROR: Pressure sensor appears damaged! \\n\");\n            return;\n        }\n        \n        //check if optical flow up and running\n        if ((1 == MW_CONFIG_ENABLEOPTICALFLOW) && (of_fifo < 0))\n        {\n            of_fifo = open(\"/tmp/of_fifo\", O_RDONLY); //O_NONBLOCK O_RDONLY\n            fcntl(of_fifo, F_SETFL, fcntl(of_fifo, F_GETFL) | O_NONBLOCK);\n            if (of_fifo < 0)\n            {\n                printf(\"rsedu_control(): ERROR optical flow not running!\\n\");\n                run_flag = 0;\n            }\n        }\n        \n        //Display beginning of relevant data output on screen\n        printf(\" *************************************** Data_block_start *************************************************** \\n\");\n        \n        //Power motors\n        out->command = BLDC_CMD_RUN;\n        printf(\"rsedu_control(): Motors Powered. Ready for Take-Off ! \\n\");\n        \n        //s3: Fly\n        // ------\n    }\n    else if (counter <= onCycles)\n    {\n        if ( counter % 200 == 0)\n        {\n            uint8_t bat;\n            printf(\"\\n **** Sensor Values when counter = %d **** \\n\", counter);\n            printf(\"rsedu_control(): sonar altitude: %fmeters, pressure: %fpascal, gyrotemp: %fcelsius\\n\", in->HAL_ultrasound_SI.altitude, in->HAL_pressure_SI.pressure,in->HAL_gyro_SI.temperature);\n            printf(\"rsedu_control(): gyro x: %frad/s, y: %frad/s, z: %frad/s\\n\", in->HAL_gyro_SI.x,in->HAL_gyro_SI.y,in->HAL_gyro_SI.z);\n            printf(\"rsedu_control(): accel x: %fm/s2, y: %fm/s2, z: %fm/s2\\n\", in->HAL_acc_SI.x,in->HAL_acc_SI.y,in->HAL_acc_SI.z);\n            printf(\"rsedu_control(): Battery output voltage Integrated: %5.2fV - %0d percents\\n\", in->HAL_vbat_SI.vbat_V, (int)in->HAL_vbat_SI.vbat_percentage);\n            bat = (uint8_t) in->HAL_vbat_SI.vbat_percentage;\n            write(connfd_GUI, \"B\", 1);\n            write(connfd_GUI, &bat, 1);\n        }\n        \n        //3.1 take off-setting\n        // +++++++++++++++++++\n        if (counter < calibCycles + takeoffCycles)\n        {\n            keyboardServerCommands->takeoff_flag = 1;  //enables take-off procedure, disables altitude-control\n            keyboardServerCommands->pos_ref[2] = -1.1;\n            \n            //React to possible low battery\n            if (in->HAL_vbat_SI.vbat_percentage < MIN_BATTTAKEOFF)\n            {\n                run_flag = 0;\n                write(connfd_GUI, \"Db\", 2);\n                printf(\"rsedu_control(): Flight aborted due to low voltage (%d %%): shutting down motors now, charge battery!\\n\", in->HAL_vbat_SI.vbat_percentage);\n                return;\n            }\n            \n            //3.2 transition to actual flight: enable altitude-control setting\n            // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n        }\n        else if (counter == calibCycles + takeoffCycles)\n        {\n            keyboardServerCommands->takeoff_flag = 0;  //disable take-off procedure, enables altitude-control\n            keyboardServerCommands->pos_ref[2] = -1.1;\n            \n            //3.3 actual flight setting\n            // ++++++++++++++++++++++++\n        }\n        else if (counter < onCycles)\n        {\n            \n            //Respond to requests from client\n            fcntl(connfd, F_SETFL, O_NONBLOCK);\n            memset(recvBuff, '\\0', sizeof(recvBuff));\n            recv(connfd, recvBuff, sizeof(recvBuff), O_NONBLOCK);\n            processRequest(connfd,recvBuff,in,out,keyboardServerCommands, &run_flag); //  function call to process data sent from MATLAB APIs\n            \n            if (isLanding == 1)\n            {\n                // Soft land the drone upon receiving a take-off command\n                soft_land_minidrone(keyboardServerCommands, out , &run_flag);\n            }\n            \n            if ((keyboardServerCommands->orient_ref[1] == 0.0) && (keyboardServerCommands->orient_ref[2] == 0.0))\n            {\n                //control position + velocity if no specific reference attitude given (yaw angle ok)\n                keyboardServerCommands->controlModePosVSOrient = 1; //1 ; 1 position reference, 0 angle reference\n            }\n            else\n            {\n                //angle control\n                keyboardServerCommands->controlModePosVSOrient = 0; //0 ; 0 position reference, 1 angle reference\n            }\n            \n            //use of position estimate from vision\n            SensorData->VisionSensors.usePosVIS_flag = MW_CONFIG_USEIMAGEVISIONFORPOSITION;\n            \n            //React to possible Flight abort request\n            if (run_flag == 0)\n            {\n                printf(\"rsedu_control(): Flight abort request: shutting down motors now\\n\");\n                return;\n            }\n            \n            //3.4 init to stop flight (because of end of flight duration)\n            // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n        }\n        else\n        {\n            powerGain = 0;\n        }\n        \n        //Actual flight control\n        //---------------------\n        //safety abort for high accelerations or position\n        bool crash_detected;\n        crash_detected = (fabs(in->HAL_acc_SI.x) > MAX_ACCELERATION) || (fabs(in->HAL_acc_SI.y) > MAX_ACCELERATION);\n        \n        bool battery_low = (in->HAL_vbat_SI.vbat_percentage < MIN_BATT) && (in->HAL_vbat_SI.vbat_percentage > 1.0);\n        \n        // log any exit reasons\n        if (crash_detected)\n        {\n            printf(\"rsedu_control(): Flight crash detected (accelerometer): shutting down motors now. accel x: %fm/s2, y: %fm/s2, z: %fm/s2\\n\", in->HAL_acc_SI.x,in->HAL_acc_SI.y,in->HAL_acc_SI.z);\n        }\n        if (battery_low)\n        {\n            printf(\"rsedu_control(): Flight aborted due to low voltage (%d %%): shutting down motors now, charge battery!\\n\", in->HAL_vbat_SI.vbat_percentage);\n        }\n        \n        // and stop the drone\n        if (crash_detected)\n        {\n            run_flag = 0;\n            write(connfd_GUI, \"Dc\", 2);\n            return;\n        }\n        if (battery_low)\n        {\n            run_flag = 0;\n            write(connfd_GUI, \"Db\", 2);\n            return;\n        }\n        \n        //Input to Model: optical flow computations (setup as zero-order hold: no updates on static var when nothing new in fifo)\n        SensorData->VisionSensors.opticalFlow_data[2] = 1; // Set the OF status to true. In case the below line fails (i.e when there is no data),\n                                                           // the OF error in the model increases faster. Hence, set the flag to true and the \n                                                           // model takes the previous value. Only when data is read and the optical flow is error \n                                                           // occurs, set the status to 'error'(-1)\n        if ((1 == MW_CONFIG_ENABLEOPTICALFLOW) && (of_fifo > 0))\n        {\n            if ((read(of_fifo, (float*)(&of_data), sizeof(of_data)) > 0) && ((of_data[0] != 0.0) || (of_data[1] != 0.0)))\n            {\n                ofQuality = of_data[3];\n                //ofDefined = of_data[4];\n                if (ofQuality > 0)\n                {\n                    counter_noOF = 0;\n                    SensorData->VisionSensors.opticalFlow_data[0] = of_data[0];\n                    SensorData->VisionSensors.opticalFlow_data[1] = of_data[1];\n                    if (counter % 200 == 0)\n                    {\n                        printf(\"rsedu_control(): of: %f %f %f \\n\",of_data[0],of_data[1],of_data[2]);\n                    }\n                }\n            }\n            else\n            {\n                 SensorData->VisionSensors.opticalFlow_data[2] = -1;  // Set the OF status to false.\n#ifndef MW_HAS_OPTICAL_FLOW_LOGIC\n                if (counter > (calibCycles + takeoffCycles + 200 * 2)) // This logic is applicable only for 18b and below models. \n                                                                       // Wait for (calibCycles + takeoffCycles) + additional 2 seconds.\n                {\n                    counter_noOF += 1;\n                    if (counter_noOF >= MAX_noOF)\n                    {\n                        run_flag = 0;\n                        printf(\"rsedu_control(): Problem with optical flow, there has been no flow for %d cycles in cycle %d: shutting down motors now\\n\", counter_noOF, counter);\n                        return;\n                    }\n                }\n#endif\n            }\n        }\n        \n        keyboardServerCommands->live_time_ticks = counter;\n        \n#ifdef EXT_MODE\n        runModel = ((rtmGetErrorStatus(MW_StringifyDefineFunction(MODEL,_M))== (NULL)) &&\n                (!rtmGetStopRequested(MW_StringifyDefineFunction(MODEL,_M))));\n#else\n        runModel = rtmGetErrorStatus(MW_StringifyDefineFunction(MODEL,_M))== (NULL);\n#endif\n        if (runModel)\n        {\n            SensorData->HALSensors = *in;\n#ifdef MW_HAS_LAND_DRONE\n            keyboardServerCommands->land_drone = landDrone;\n            keyboardServerCommands->time_remaining = (onCycles - counter) * 0.005; \n#endif\n            \n           \n#ifdef PARROT_XCP_EXT_MODE\n            extmodeSimulationTime_T currentTime = (extmodeSimulationTime_T) 0;\n            currentTime = (extmodeSimulationTime_T) MW_StringifyDefineFunction(MODEL,_M)->Timing.taskTime0;\n#endif\n\n#ifdef MW_HAS_IMAGE_PROCESSING\n            MW_StringifyDefineFunction(MODEL,_step0)(); /*If the Image Processing blocks are present,\n             * the step0() has the Flight Control code. */\n                \n                runVisionCode = 1; /* This flag is polled in the Vision Thread \n                                    * to start the image processing code. \n                                    * This flag is initially set to '0'. */\n            #else\n                MW_StringifyDefineFunction(MODEL,_step)();/*If the Image Processing blocks are not present, \n                                                           * the step() has the Flight Control code.*/\n            #endif\n#ifdef EXT_MODE\n            #ifdef PARROT_XCP_EXT_MODE \n                extmodeEvent(0, currentTime);\n            #else\n                rtExtModeCheckEndTrigger();\n            #endif\n#endif\n        }\n        else\n        {\n            runModel = 0;\n            run_flag = 0;\n#ifdef EXT_MODE\n            if (rtmGetStopRequested(MW_StringifyDefineFunction(MODEL,_M)) == true)\n            {\n                rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL,_M), \"Simulation finished\");\n                return;\n            }\n#endif\n            write(connfd_GUI, \"Dm\", 2);\n            printf(\"rsedu_control(): ERROR: Error from simulink model @ counter=%i !\\n\\t%s\", counter,  rtmGetErrorStatus(MW_StringifyDefineFunction(MODEL,_M)));\n            return;\n        }\n        \n        //Currently using the 'flag_outport==99' condition along with #def 'stateEstimator_MDLREF_HIDE_CHILD_' to\n        //ensure this condition is evaluated only for the demo asbQuadcopter model.\n#ifdef stateEstimator_MDLREF_HIDE_CHILD_\n        //safety abort for high mismatch OF vs state velocities\n        if (99 == flag_outport)\n        {\n            if (ofQuality > 0 &&\n                    (counter > (calibCycles + takeoffCycles)) &&\n                    (flag_outport)\n                    )\n            {\n                run_flag = 0;\n                printf(\"rsedu_control(): Flight crash about to happen, mismatch optical flow (%f, %f) and state estimate (%f, %f): shutting down motors now\\n\",\n                        20 * of_data[0],\n                        20 * of_data[1],\n                        100.0,\n                        100.1);\n                return;\n            }\n        }\n#endif\n        \n        if (flag_outport) {\n            run_flag = 0;\n            write(connfd_GUI, \"F\", 1);\n            write(connfd_GUI, &flag_outport, 1);\n            printf(\"rsedu_control(): Flight aborted due to error condition %d !\\n\\t\",flag_outport);\n            return;\n        }\n        \n        \n        //power engines\n        if (counter < onCycles)\n        {\n            out->command = BLDC_CMD_RUN;\n        }\n        else\n        {\n            out->command = BLDC_CMD_STOP;\n            return;\n        }\n        \n        if ( counter % 200 == 0)\n        {\n            printf(\"rsedu_control(): motor values : %f %f %f %f\\n\",motors_outport[0],motors_outport[1],motors_outport[2],motors_outport[3]);\n        }\n        \n        // update motor commands with control commands\n        out->motors_speed[0] = (int)(powerGain * (fabs(motors_outport[0])));\n        out->motors_speed[1] = (int)(powerGain * (fabs(motors_outport[1])));\n        out->motors_speed[2] = (int)(powerGain * (fabs(motors_outport[2])));\n        out->motors_speed[3] = (int)(powerGain * (fabs(motors_outport[3])));\n        usleep(100);\n        \n        //s4.0 End flight: log data and close program\n        //-------------------------------------------\n    }\n    else\n    {\n        run_flag = 0;\n        stop_flight(out);\n#ifdef EXT_MODE\n        if (background_task_completed == false)\n        {\n            return;\n        }\n#endif\n#ifdef MATFILE_LOGGING\n        /* Matfile logging save*/\n        printf(\"rsedu_control(): Saving logged data at end of flight... \\n\");\n        rt_StopDataLogging(MATFILE, MW_StringifyDefineFunction(MODEL,_M)->rtwLogInfo);\n        printf(\"rsedu_control(): Saving logged data... DONE \\n\");\n#endif\n        if (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n        {\n            close(of_fifo);\n        }\n        \n#if(1 == MW_CONFIG_ENABLEPROFILING)\n            fclose(ptfile);\n#endif\n        printf(\"rsedu_control(): Flight Completed after %i cycles ... DONE \\n\", counter - 1); /*Counter value is currently onCycles + 1*/\n\n#ifdef MW_HAS_IMAGE_PROCESSING\n        printf(\"RSEDU_image_processing: Average image processing time is %lldms \\n\", avrgIpTime);\n#endif\n        printf(\"rsedu_control(): Good night! \\n\");\n        write(connfd_GUI, \"De\", 2);\n        MW_StringifyDefineFunction(MODEL,_terminate)();\n        \n        waitForGrabberCannon = 1;// This flag is used to check if a fire command or a grab command is active. Only if it is inactive, exit the program.\n        return;\n        //exit(0);\n    }\n    \n    usleep(200);\n    \n    //ptiming - store\n    //----------\n#if(1 == MW_CONFIG_ENABLEPROFILING)\n    ptimer_stopstore(start, ptfile);\n#endif\n    //----------\n}\n\n/**\n * @brief This function stops all motors and sets to command to stop\n *\n * @param[out] out Motor commands to be set\n *\n * @see HAL.h\n */\nvoid stop_flight(HAL_command_t *out)\n{\n    out->motors_speed[0] = 0;\n    out->motors_speed[1] = 0;\n    out->motors_speed[2] = 0;\n    out->motors_speed[3] = 0;\n    out->command = BLDC_CMD_STOP;\n}\n\n/**\n * @brief This function soft lands the minidrone by reducing height slowly. It is dependent on controller logic to work fully.\n *\n * @param[out] void\n *\n */\nvoid soft_land_minidrone(CommandBus *keyboardServerCommands , HAL_command_t *out, int *run_flag)\n{\n    keyboardServerCommands->orient_ref[1] = 0.0 ;\n    keyboardServerCommands->orient_ref[2] = 0.0 ;\n    keyboardServerCommands->pos_ref[2] += 0.002;\n    if (keyboardServerCommands->pos_ref[2]  > -0.2) {\n        printf(\"rsedu_control(): Stopping Motors after Land Command\\n\");\n        stop_flight(out);\n        // Resetting counter to wait for next take-off command\n        //counter = 2;\n        isLanding = 0;\n        isMotorOn = 0;\n        wrStatus = write(connfd,&(ack),sizeof(ack));\n        *run_flag = 0 ;\n    }\n}\n\n/** @brief Performs a running average on the sensor readings.\n *\n * @param[in]   ctr       The current tick counter\n * @param[out]  calibData The calibration data to be updated\n * @param[out]  battLevelAvg The battery level average to be updated\n * @param[in]   in        Current sensor reading to be used to update the running average\n */\nvoid perform_calibration(int ctr, real32_T* calibData, double* battLevelAvg, HAL_acquisition_t* in)\n{\n    \n    int counterCalib = ctr - 3;\n    \n    calibData[0] = calibData[0] * (counterCalib - 1) / counterCalib + in->HAL_acc_SI.x / counterCalib;\n    calibData[1] = calibData[1] * (counterCalib - 1) / counterCalib + in->HAL_acc_SI.y / counterCalib;\n    calibData[2] = calibData[2] * (counterCalib - 1) / counterCalib + in->HAL_acc_SI.z / counterCalib;\n    calibData[3] = calibData[3] * (counterCalib - 1) / counterCalib + in->HAL_gyro_SI.x / counterCalib;\n    calibData[4] = calibData[4] * (counterCalib - 1) / counterCalib + in->HAL_gyro_SI.y / counterCalib;\n    calibData[5] = calibData[5] * (counterCalib - 1) / counterCalib + in->HAL_gyro_SI.z / counterCalib;\n    calibData[6] = calibData[6] * (counterCalib - 1) / counterCalib + in->HAL_pressure_SI.pressure / counterCalib;\n    calibData[7] = calibData[7] * (counterCalib - 1) / counterCalib + in->HAL_ultrasound_SI.altitude / counterCalib;\n    \n    *battLevelAvg = *battLevelAvg * (counterCalib - 1) / counterCalib + (double)(in->HAL_vbat_SI.vbat_percentage) / counterCalib;\n}\n\n/**\n * @brief Initialization of the sensor/battery calibration data\n *\n * @param[out]  calibData The calibration data to be initialized\n * @param[out]  battLevelAvg The battery level average to be initialized\n * @param[in]   in        Current sensor reading to be used to seed the running average\n */\nvoid initialize_calibration_data(real32_T* calibData, double* battLevelAvg, HAL_acquisition_t* in)\n{\n    //init sensor calibration measurements\n    calibData[0] = in->HAL_acc_SI.x;\n    calibData[1] = in->HAL_acc_SI.y;\n    calibData[2] = in->HAL_acc_SI.z;\n    calibData[3] = in->HAL_gyro_SI.x;\n    calibData[4] = in->HAL_gyro_SI.y;\n    calibData[5] = in->HAL_gyro_SI.z;\n    calibData[6] = in->HAL_pressure_SI.pressure;\n    calibData[7] = in->HAL_ultrasound_SI.altitude;\n    \n    *battLevelAvg = (double)((int)in->HAL_vbat_SI.vbat_percentage);\n}\n\n/**\n * @brief Opens the optical flow FIFO\n *\n * @return RETURN_SUCCESS indicating the process was successful, RETURN_FAIL otherwise\n */\nReturn_flag_t open_optical_flow_comm(void)\n{\n    \n    int file_access_flags;\n    \n    // Initialize communication with optical flow thread\n    printf(\"rsedu_control(): Waiting for optical flow connection...\\n\");\n    usleep(100);\n    \n    of_fifo = open(\"/tmp/of_fifo\", O_RDONLY | O_NONBLOCK);  //O_NONBLOCK O_RDONLY\n    if (of_fifo == ERROR) {\n        return RETURN_FAIL;\n    }\n    \n    file_access_flags = fcntl(of_fifo, F_GETFL);\n    if (file_access_flags == ERROR) {\n        return RETURN_FAIL;\n    }\n    \n    if (fcntl(of_fifo, F_SETFL, file_access_flags | O_NONBLOCK) == ERROR) {\n        return RETURN_FAIL;\n    }\n    \n    if (read(of_fifo, (float*)(&of_data), sizeof(of_data)) == ERROR) {\n        return RETURN_FAIL;\n    }\n    \n    return RETURN_SUCCESS;\n}\n"},{"name":"rsedu_image.c","type":"source","group":"legacy","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"#include \"rsedu_image.h\"\n#include <stdint.h>\n\n/**\n * @brief Fill the YUV data to the buffers\n *\n * @param[in]  imBuff Pointer to the image exposed by PARROT\n * @param[out]  buff1 Pointer to the Y-channel buffer\n * @param[out]  buff2 Pointer to the U-channel buffer\n * @param[out]  buff3 Pointer to the V-channel buffer\n */\n\nvoid MW_Build_YUV(const void* imBuff, uint8_t* buff1, uint8_t* buff2, uint8_t* buff3){\n    uint32_t yIndex = 0;\n    uint32_t vIndex = 0;\n    uint32_t uIndex = 0;\n    uint32_t col,row;\n    pixel2_t* imageBuffer;\n\n    imageBuffer = (pixel2_t*) imBuff;\n\n    for(col = 0; col < 160/2; col++){\n        for(row = 0; row < 120; row++){\n#ifdef Y_CHANNEL  // Macro is defined in onAfterCodeGenHook, iff the Parrot Image Conversion is present and the Y-channel output is selected\n            buff1[yIndex] = imageBuffer[(row*160/2) + col].y1;  // Fill the Y-channel buffer with Y1 and Y2 data for two consecutive columns\n            buff1[yIndex + 120] = imageBuffer[(row*160/2) + col].y2;\n            yIndex++;\n#endif\n            \n#ifdef U_CHANNEL // Macro is defined in onAfterCodeGenHook, iff the Parrot Image Conversion is present and the U-channel output is selected\n            buff2[uIndex] = buff2[uIndex + 120] = imageBuffer[(row*160/2) + col].u; // Fill the U-channel buffer with the same U data for two consecutive columns, since the U value for two consecutive pixels are the same.\n            uIndex++;\n#endif\n            \n#ifdef V_CHANNEL // Macro is defined in onAfterCodeGenHook, iff the Parrot Image Conversion is present and the V-channel output is selected\n            buff3[vIndex] = buff3[vIndex + 120] = imageBuffer[(row*160/2) + col].v; // Fill the U-channel buffer with the same V data for two consecutive columns, since the V value for two consecutive pixels are the same.\n            vIndex++;\n#endif\n        }\n        yIndex += 120; //In one loop, two columns of pixels are written, hence skip the index by 120.\n        uIndex += 120;\n        vIndex += 120;\n    }\n}\n\n\n/**\n * @brief Fill the RGB data to the buffers\n *\n * @param[in]  imBuff Pointer to the image exposed by PARROT\n * @param[out]  buff1 Pointer to the R-channel buffer\n * @param[out]  buff2 Pointer to the G-channel buffer\n * @param[out]  buff3 Pointer to the B-channel buffer\n */\n\n/*In this function, pixels from two consecutive columns are written in one loop. \n *In the first part the pixel from the first columns of R, G and B are written. \n * In the second part, the pixel from the second columns of R, G and B are written \n * and finally the index is incremented by 120 to skip the second column.\n * The code for the YUV to RGB conversions was created with the help of the 'Color Space Conversion' block in Image Precessing Toolbox.\n * The C code for the conversion was first generated using the block and then optimized for the Y1UY2V data.\n */\nvoid MW_Build_RGB(const void* imBuff, uint8_t* buff1, uint8_t* buff2, uint8_t* buff3){\n    uint32_t pixelIndex = 0;\n    uint32_t col,row;\n\n    int32_t i=0;\n    uint32_t cc1;\n    uint32_t pos;\n    uint32_t neg;\n    uint32_t yDiff;\n    pixel2_t* imageBuffer;\n    \n    imageBuffer = (pixel2_t*) imBuff;\n\n    for(col = 0; col < 160/2; col++){\n        for(row = 0; row < 120; row++, i++){\n            pixelIndex = (row*160/2) + col;\n\n            yDiff = imageBuffer[pixelIndex].y1 - 16U;\n// RGB conversion for the pixels in the first column\n#ifdef R_CHANNEL // Macro is defined in onAfterCodeGenHook, iff the Parrot Image Conversion is present and the R-channel output is selected\n\n            /* Red; 8192 in this equations is 0.5*2^14 or 2^13; adding 0.5  */\n            /* before truncation will result in rounding */\n            pos = (imageBuffer[pixelIndex].v * 26149U + yDiff * 19077U) + 8192U;\n            if (pos > 3347072U) {\n                pos -= 3347072U;\n            } else {\n                pos = 0U;\n            }\n\n            cc1 = pos >> 14;\n\n            /* limit to avoid wrapping */\n            if (cc1 > 255U) {\n                cc1 = 255U;\n            }\n\n            buff1[i] = (uint8_t)cc1; //ccl has the R value of the pixel\n#endif\n            \n#ifdef G_CHANNEL // Macro is defined in onAfterCodeGenHook, iff the Parrot Image Conversion is present and the G-channel output is selected\n            /* Compute green channel */\n            pos = yDiff * 19077U + 2534784U;\n            neg = imageBuffer[pixelIndex].u * 6419U + imageBuffer[pixelIndex].v * 13320U;\n\n            /* scale back */\n            if (pos > neg) {\n                pos -= neg;\n            } else {\n                pos = 0U;\n            }\n\n            neg = pos >> 14;\n            if (neg > 255U) {\n                neg = 255U;\n            }\n            buff2[i] = (uint8_t)neg; //neg has the G value of the pixel\n#endif\n            \n#ifdef B_CHANNEL // Macro is defined in onAfterCodeGenHook, iff the Parrot Image Conversion is present and the B-channel output is selected\n            /* Compute blue channel */\n            pos = (imageBuffer[pixelIndex].u * 33050U + yDiff * 19077U) + 8192U;\n\n            /* scale back */\n            if (pos > 4230400U) {\n                pos -= 4230400U;\n            } else {\n                pos = 0U;\n            }\n\n            yDiff = pos >> 14;\n            if (yDiff > 255U) {\n                yDiff = 255U;\n            }\n            buff3[i] = (uint8_t)yDiff; //yDiff has the B value of the pixel\n\n#endif\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n            yDiff = imageBuffer[pixelIndex].y2 - 16U;\n// RGB conversion for the pixels in the second column\n#ifdef R_CHANNEL\n            /* Red; 8192 in this equations is 0.5*2^14 or 2^13; adding 0.5  */\n            /* before truncation will result in rounding */\n            pos = (imageBuffer[pixelIndex].v * 26149U + yDiff * 19077U) + 8192U;\n            if (pos > 3347072U) {\n                pos -= 3347072U;\n            } else {\n                pos = 0U;\n            }\n            \n            cc1 = pos >> 14;\n            \n            /* limit to avoid wrapping */\n            if (cc1 > 255U) {\n                cc1 = 255U;\n            }\n            buff1[i + 120] = (uint8_t)cc1; //cc1 has the R value of the pixel\n#endif\n            \n#ifdef G_CHANNEL\n            \n            /* Compute green channel */\n            pos = yDiff * 19077U + 2534784U;\n            neg = imageBuffer[pixelIndex].u * 6419U + imageBuffer[pixelIndex].v * 13320U;\n            \n            /* scale back */\n            if (pos > neg) {\n                pos -= neg;\n            } else {\n                pos = 0U;\n            }\n            \n            neg = pos >> 14;\n            if (neg > 255U) {\n                neg = 255U;\n            }\n            buff2[i + 120] = (uint8_t)neg; //neg has the G value of the pixel\n#endif\n            \n#ifdef B_CHANNEL\n            \n            /* Compute blue channel */\n            pos = (imageBuffer[pixelIndex].u * 33050U + yDiff * 19077U) + 8192U;\n            \n            /* scale back */\n            if (pos > 4230400U) {\n                pos -= 4230400U;\n            } else {\n                pos = 0U;\n            }\n            \n            yDiff = pos >> 14;\n            if (yDiff > 255U) {\n                yDiff = 255U;\n            }\n            buff3[i + 120] = (uint8_t)yDiff; //yDiff has the B value of the pixel\n#endif\n            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        }\n        i += 120;  //Increment the index by 120 since the pixels in the next column were already written.\n    }\n}\n"},{"name":"rsedu_of.c","type":"source","group":"legacy","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"//File: rsedu_of.c\n\n#include \"rsedu_of.h\"\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include \"MW_target_hardware_resources.h\"\n#include \"ptimer.h\"\n//----------------------------------\n// OPTICAL FLOW\n//----------------------------------\n\n/*\n * @input is the result of optical flow computations, this functions then dumps these into a fifo to make them available to the control code\n *\n * Called 60 times per second.\n */\nvoid RSEDU_optical_flow(float vx, float vy, float vz, int defined, float qualityIndicator)\n{\n    \n#if defined(MW_CONFIG_ENABLEOPTICALFLOW) && (1 == MW_CONFIG_ENABLEOPTICALFLOW)\n    \n    //process control\n    static int counter = 0;\n    \n    //communication\n    static float of_data[5];\n    static int of_fifo;\n    \n    /*\n     * PROGRAM\n     */\n    \n#if (1 == MW_CONFIG_ENABLEPROFILING)\n    //ptiming - declare and start\n    //------------\n    long long start;\n    static FILE *ptfile;\n    //------------\n#endif\n    \n    //process control\n    counter++;\n    \n#if(1 == MW_CONFIG_ENABLEPROFILING)\n    ptimer_start(&start);\n#endif\n    \n    //Compile data\n    of_data[0] = vx;\n    of_data[1] = vy;\n    of_data[2] = vz;\n    of_data[3] = (float)(defined * 1.0);\n    of_data[4] = qualityIndicator;\n    \n    \n    if (counter % 60 == 0)\n    {\n        printf(\"rsedu_of(): flow: (%f, %f, %f, %f, %f)\\n\",of_data[0],of_data[1],of_data[2],of_data[3],of_data[4]);\n    }\n    \n    //Setup thread communication\n    if (counter == 1)\n    {\n        \n        \n        if (access(\"/tmp/of_fifo\", F_OK) != -1)\n        {\n            printf(\"rsedu_of(): SUCCESS optical flow FIFO exists! \\n\");\n        } else\n        {\n            printf(\"rsedu_of(): ERROR opening optical flow-fifo!\\n\");\n        }\n        \n        //ptiming - init file\n        //------------\n#if(1 == MW_CONFIG_ENABLEPROFILING)\n        ptimer_init(__func__, &(ptfile), NULL);\n#endif\n        //------------\n        \n        //usleep(10000);\n        \n    }\n    \n    //FIFO handling and writing\n    of_fifo = open(\"/tmp/of_fifo\", O_WRONLY);\n    if (of_fifo)\n    {\n        int ok = write(of_fifo, (float*)(&of_data), sizeof(of_data));\n        if (ok == -1)\n        {\n            printf(\"rsedu_of(): ERROR writing to optical flow-fifo: %s!\\n\", strerror(errno));\n        }\n        close(of_fifo);\n    }\n    else\n    {\n        printf(\"rsedu_of(): ERROR  opening optical flow-fifo: %s!\\n\", strerror(errno));\n    }\n    \n    usleep(4000);\n    \n#if(1 == MW_CONFIG_ENABLEPROFILING)\n    //ptiming - store\n    //----------\n    ptimer_stopstore(start, ptfile);\n    //----------\n#endif\n    \n#endif\n    \n}\n"},{"name":"rsedu_vis.c","type":"source","group":"legacy","path":"C:\\Users\\jakub\\MATLAB\\Projects\\examples\\asbQuadcopter2\\work\\flightControlSystem_ert_rtw\\..\\..\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\parrot\\src","tag":"","groupDisplay":"Other files","code":"//File: rsedu_vis.c\n\n#include \"rsedu_vis.h\"\n#include <stdbool.h>\n\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/fcntl.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <stdio.h>\n#include <poll.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <limits.h>\n#include \"rsedu_control.h\"\n#include <pthread.h>\n#include <semaphore.h>\n#include \"MW_target_hardware_resources.h\"\n\n#ifdef MW_HAS_IMAGE_PROCESSING\n#include \"ptimer.h\"\n#include <string.h>\n#endif\n\n#ifdef PARROT_XCP_EXT_MODE\n#include \"ext_mode.h\"\n#endif\n\n\nextern int capture;\nextern int connfd;\n\n//----------------------------------\n// Image processing / Vision-based pose estimation\n//----------------------------------\n\n/*\n * @input buffer Pointer to the current picture seen by the vertical camera\n * Picture is 160x120(width x height) pixels in YUYV format, ie 80x120 elements\n * of type 'pixel2_t'\n *\n * Called 60 times per second.\n */\n\n#ifdef MW_HAS_IMAGE_PROCESSING\nextern int runVisionCode;\n/* This is flag to start the Vision code once the\n * Control code has started. This variable is\n * updated in the Control Thread once the \"Start\"\n * button is clicked on the Flight Control UI. */\n\nuint8_T *imRGB;\n/* This is the pointer used by step code for vision. This\n * is created in Simulink by declaring the signal.*/\n\nextern int run_flag;\n/* This flag is used in the control thread to indicate\n *the \"Stop\" button is pressed on the Flight Control UI.\n * Here, it is used to stop the generated Image Processing code.*/\n\nsem_t imageCopied;\n/*Semaphore to signal when the image is obtained in the\n * RSEDU_image_processing function. Once the image is obtained,\n * the imRGB buffer is filled with the pointer to the image.\n * Then a sem_post is called, which releases the semaphore.*/\n\nint imageProcFinish = 1;\n/*This is a flag to indicate the image processing was finished.\n * This is used in the RSEDU_image_processing function to copy the image,\n * if the current image processing was complete*/\n\nlong long avrgIpTime = 0;\n/*This variable contains the average time taken for the image processing to\n * run*/\n\n/* Simple function to get the time elapsed. The start time is passed, and\n * the same variable is updated in the function. After the function returns,\n * the time gap is recorded in the start variable passed.\n */\n\nvoid* MW_image_processing(void* a)\n{\n#if (1 == MW_CONFIG_ENABLEPROFILING)\n    long long start = 0 ; // variable to store the start and stop times for profiling.\n    static FILE *ptfile; // File to which the profiling data is written to.\n#endif\n    static int counter = 2; //set the counter to get the timing data.\n    long long ipTime = 0;\n    static long long ipTimeSum = 0;\n    \n    //ptiming - init file\n    //------------\n#if (1 == MW_CONFIG_ENABLEPROFILING)\n    ptimer_init(__func__, &(ptfile), NULL);\n#endif\n        while(1){\n        sem_wait(&imageCopied); //wait until the image is obtained.\n        printf(\"rsedu_vision(): Entered... \\n\");\n        \n        ptimer_start(&ipTime);\n        /* This line is added to get the image processing time for each\n         * cycle, regardless of whether the MW_CONFIG_ENABLEPROFILING is defined\n         * or not.\n         */\n        \n#if (1 == MW_CONFIG_ENABLEPROFILING)\n        \n            //Start the profiling (Basically takes a note of the time stamp)\n            ptimer_start(&start);\n#endif\n            \n#ifdef PARROT_XCP_EXT_MODE\n            extmodeSimulationTime_T currentTime = (extmodeSimulationTime_T) 0;\n            currentTime = (extmodeSimulationTime_T) ((MW_StringifyDefineFunction(MODEL,_M)->Timing.clockTick0) *\n                                                     0.005);\n#endif\n        /* This is the step function for the Image Processing Subsystem.\n         * When the image processing is enabled,\n         * step1() contains the image processing code*/\n        MW_StringifyDefineFunction(MODEL,_step1)();\n        \n#ifdef PARROT_XCP_EXT_MODE\n            extmodeEvent(1, currentTime);\n#endif\n            \n        ipTime = ptimer_stopstore(ipTime, NULL)/1000; \n        /*Get the time consumed by the image processing and convert it to milliseconds.*/\n        ipTimeSum = ipTimeSum + ipTime;\n        /*accumulate the values, which will be used to get the average time of\n         *image processing.\n         */\n        \n        avrgIpTime = ipTimeSum / (counter - 1);\n        /*get the average Image processing time*/\n        \n        printf(\"rsedu_vision(): Exited. Time taken to process the image = %lldms\\n\", ipTime);\n        \n#if(1 == MW_CONFIG_ENABLEPROFILING)\n        //Stop the profiling (Basically takes a note of the time stamp and writes it to a file)\n        ptimer_stopstore(start, ptfile);\n#endif\n        imageProcFinish = 1;\n        \n        if (run_flag == 0)\n        {              \n            break;  //break the loop once the flight is over.\n        }\n        counter++;\n    }\n    return NULL;\n}\n\nvoid create_image_thread(void)\n{\n    int err, status;\n    pthread_attr_t attr;\n    struct sched_param param;\n    pthread_t imageThreadHandle;\n    \n    int policy;\n    pthread_getschedparam(pthread_self(), &policy,&param);\n    printf(\"create_image_thread(): Image thread policy = %d and priority=%d\\n\", (int)policy,param.sched_priority);\n    \n    pthread_attr_init(&attr);\n    \n    err = pthread_attr_setinheritsched(&attr,PTHREAD_EXPLICIT_SCHED);\n    printf(\"create_image_thread(): Image thread inherit scheduler option error=%d\\n\", err);\n    \n    status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n    printf(\"create_image_thread(): value of detach status=%d\\n\", status);\n    \n    err = pthread_attr_setstacksize(&attr,PTHREAD_STACK_MIN);\n    printf(\"create_image_thread(): stacksize before thread creation err=%d\\n\", err);\n    \n    status = pthread_attr_setschedpolicy(&attr, SCHED_OTHER);\n    printf(\"create_image_thread(): value of scheduler policy status=%d\\n\", status);\n    \n    param.sched_priority = 0;\n    status = pthread_attr_setschedparam(&attr, &param);\n    printf(\"create_image_thread(): value of scheduler param status=%d\\n\", status);\n    \n    err = pthread_create(&imageThreadHandle, &attr, &MW_image_processing, NULL);\n    if (err != 0)\n        printf(\"create_image_thread(): can't create Image thread :[%s]\", strerror(err));\n    else\n        printf(\"create_image_thread(): Image Thread created successfully\\n\");\n}\n\n#endif\n\nvoid RSEDU_image_processing(void * buffer)\n{\n#ifdef MW_HAS_IMAGE_PROCESSING\n    static int counter = 0;\n    counter++;\n    \n    if(counter == 1)\n    {\n        sem_init(&imageCopied, 0, 0);\n        create_image_thread();\n    }\n    \n    if (runVisionCode == 1 && run_flag == 1 && imageProcFinish == 1)\n    {\n        imRGB = buffer;\n        /* Fill the pointer of the image used by Simulink,\n         * with the address of the image exposed by Parrot.*/\n        sem_post(&imageCopied); //Post the semaphore to start the image processing.\n        \n        imageProcFinish = 0;\n        /*clear the flag, which will be updated from the\n         * image processing thread.*/\n    }\n    usleep(50000);\n    /*This sleep is required to make the Vision thread sleep so that the\n     * newly created image processing thread and the external mode thread\n     * gets time to run. Without this sleep, new images are captured and\n     * dropped and consumes CPU without any purpose. Since a new image is \n     * obtained only after this sleep, this can be considered to be the \n     * sample time of the image processing. The sample time is 50ms.\n     */\n#endif\n    \n    /*  Image capture logic */\n    if (1 == capture) {\n        write(connfd,buffer,sizeof(pixel2_t)*80*120);   // Write YUV422 pixel values into socket\n        printf(\"rsedu_vis(): Image capture successful. \\n\");\n        capture  = 0; //Reset the image capture flag\n    }\n    \n}"},{"name":"rt_logging.c","type":"source","group":"other","path":"C:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2022 The MathWorks, Inc.\n *\n * File: rt_logging.c\n *\n * Abstract:\n *\tReal-Time Workshop data logging routines using circular buffers of\n *      fixed size.  The buffers are allocated at start, filled in at each\n *      major time step and finally written to a MAT-file at the end of the\n *      simulation.\n *\n *      This file handles redefining the following standard MathWorks types\n *      (see tmwtypes.h):\n *         [u]int8_T     to be int32_T (logged as Matlab [u]int32)\n *         [u]int16_T    to be int32_T (logged as Matlab [u]int32)\n *         real_T        to be real32_T (logged as Matlab single)\n *\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rt_logging.h\"\n#ifndef IS_RAPID_ACCEL\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging.h\"\n\n#include \"rtwtypes.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n#define matLOGICAL_BIT          0x200\n#define matCOMPLEX_BIT          0x800\n\n#define matKEY                 0x4D49\n#define matVERSION             0x0100\n#define matVERSION_INFO_OFFSET   124L\n\n#define matINT64_ALIGN(e)      ( ( ((unsigned)(e))+7 ) & (~7) )\n#define matTAG_SIZE            (sizeof(int32_T) << 1)\n\n#ifndef DEFAULT_BUFFER_SIZE\n#define DEFAULT_BUFFER_SIZE      1024  /* used if maxRows=0 and Tfinal=0.0    */\n#endif\n\n#define FREE(m) if (m != NULL) free(m)\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/*==========*\n * typedefs *\n *==========*/\n\ntypedef struct LogInfo_Tag {\n    LogVar       *t;                   /* Time log variable                   */\n    void         *x;                   /* State log variable                  */\n    int_T        ny;                   /* Length of \"y\" log variables         */\n    void         **y;                  /* Output log vars                     */\n    void         *xFinal;              /* Final state log variable            */\n\n    LogVar       *logVarsList;         /* Linked list of all LogVars          */\n    StructLogVar *structLogVarsList;   /* Linked list of all StructLogVars    */\n\n    boolean_T   haveLogVars;           /* Are logging one or more vars?       */\n} LogInfo;\n\ntypedef struct MatItem_tag {\n  int32_T    type;\n  uint32_T    nbytes;\n  const void *data;\n} MatItem;\n\ntypedef enum {\n    DATA_ITEM,\n    MATRIX_ITEM,\n    STRUCT_LOG_VAR_ITEM,\n    SIGNALS_STRUCT_ITEM\n} ItemDataKind;\n\n/*===========*\n * Constants *\n *===========*/\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n\n#define ZEROS32 \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\n#if mxMAXNAM==32\n\n#define ZERO_PAD\n\n#elif mxMAXNAM==64\n\n#define ZERO_PAD ZEROS32\n\n#elif mxMAXNAM==128\n\n#define ZERO_PAD   ZEROS32  ZEROS32  ZEROS32\n\n#else\n\n#error \"Cannot Handle mxMAXNAM other than 32,64, and 128\"\n\n#endif\n/* field names: for variable-size signal logging */\nstatic const char_T rtStructLogVarFieldNames[] =\n                  \"time\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"signals\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtLocalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n                  \n\n#define TIME_FIELD_NAME      (rtStructLogVarFieldNames[0*mxMAXNAM])\n#define SIGNALS_FIELD_NAME   (rtStructLogVarFieldNames[1*mxMAXNAM])\n#define BLOCKNAME_FIELD_NAME (rtStructLogVarFieldNames[2*mxMAXNAM])\n\n#define VALUES_FIELD_NAME    (rtLocalLoggingSignalsStructFieldNames[0*mxMAXNAM])\n#define VALUEDIMENSIONS_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[1*mxMAXNAM])\n#define DIMENSION_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[2*mxMAXNAM])\n#define LABEL_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[3*mxMAXNAM])\n#define TITLE_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[4*mxMAXNAM])\n#define PLOTSTYLE_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n\n#define STATENAME_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n#define CROSS_MDL_REF_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[6*mxMAXNAM])\n\n/* field names: for fixed-size signal logging */\nstatic const char_T rtLocalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nextern real_T rtInf; /* declared by rt_nonfinite.c */\nextern real_T rtNaN;\nextern real32_T rtNaNF;\n\n/*================*\n * Local routines *\n *================*/\n\n/* Function: rt_GetSizeofDataType ==============================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofDataType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 0; /* unknown */\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        elSz = sizeof(real_T);\n        break;\n      case SS_SINGLE:\n        elSz = sizeof(real32_T);\n        break;\n      case SS_INT8:\n        elSz = sizeof(int8_T);\n        break;\n      case SS_UINT8:\n        elSz = sizeof(uint8_T);\n        break;\n      case SS_INT16:\n        elSz = sizeof(int16_T);\n        break;\n      case SS_UINT16:\n        elSz = sizeof(uint16_T);\n        break;\n      case SS_INT32:\n        elSz = sizeof(int32_T);\n        break;\n      case SS_UINT32:\n        elSz = sizeof(uint32_T);\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n    return(elSz);\n\n} /* end rt_GetSizeofDataType */\n\n\n/* Function: rt_GetSizeofComplexType ===========================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofComplexType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 2*rt_GetSizeofDataType(dTypeID);\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal_T);\n      #endif\n        break;\n      case SS_SINGLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal32_T);\n      #endif\n        break;\n      case SS_INT8:\n      #ifdef CINT8_T\n        elSz = sizeof(cint8_T);\n      #endif\n        break;\n      case SS_UINT8:\n      #ifdef CUINT8_T\n        elSz = sizeof(cuint8_T);\n      #endif\n        break;\n      case SS_INT16:\n      #ifdef CINT16_T\n        elSz = sizeof(cint16_T);\n      #endif\n        break;\n      case SS_UINT16:\n      #ifdef CUINT16_T\n        elSz = sizeof(cuint16_T);\n      #endif\n        break;\n      case SS_INT32:\n      #ifdef CINT32_T\n        elSz = sizeof(cint32_T);\n      #endif\n        break;\n      case SS_UINT32:\n      #ifdef CUINT32_T\n        elSz = sizeof(cuint32_T);\n      #endif\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n\n    return(elSz);\n\n} /* end rt_GetSizeofComplexType */\n\n\n/* Function: rt_GetDataTypeConvertInfo =========================================\n * Abstract:\n *      Directly copy if pointer to structure is non-NULL, otherwise set to\n *      default.\n */\nstatic RTWLogDataTypeConvert rt_GetDataTypeConvertInfo(\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    BuiltInDTypeId dTypeID\n    )\n{\n    RTWLogDataTypeConvert dataTypeConvertInfoCopy;\n\n    if (pDataTypeConvertInfo == NULL) {\n        dataTypeConvertInfoCopy.conversionNeeded = 0;\n        dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;\n        dataTypeConvertInfoCopy.dataTypeIdOriginal  = (DTypeId)dTypeID;\n        dataTypeConvertInfoCopy.bitsPerChunk = 0;\n        dataTypeConvertInfoCopy.numOfChunk = 0;\n        dataTypeConvertInfoCopy.isSigned = 0;\n        dataTypeConvertInfoCopy.fracSlope = 1.0;\n        dataTypeConvertInfoCopy.fixedExp = 0;\n        dataTypeConvertInfoCopy.bias = 0.0;\n    } else {\n        dataTypeConvertInfoCopy = *pDataTypeConvertInfo;\n    }\n\n    return dataTypeConvertInfoCopy;\n\n} /* end rt_GetDataTypeConvertInfo */\n\n\n/* Function: rt_GetDblValueFromOverSizedData ===================================\n * Abstract:\n */\nstatic double rt_GetDblValueFromOverSizedData(\n    const void *pVoid, \n    int bitsPerChunk, \n    int numOfChunk,\n    unsigned int isSigned, \n    double fracSlope, \n    int fixedExp, \n    double bias)\n{\n    double retValue = 0;\n\n    double *dblValue = (double *) calloc(numOfChunk, sizeof(double));\n\n    int i;    \n    double isSignedNeg;\n\n    if(isSigned) {\n        const chunk_T *pData = (const chunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    } else  {\n        const uchunk_T *pData = (const uchunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    }\n\n    /* \n       Assuming multi chunks b_n ... b_2 b_1 b_0, and the length of each chunk is N.\n       Suppose b_i is the i-th chunk's value.\n       Then for unsigned data or data with one chunk: we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0;\n       But for signed data, we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0+ (b_0<0) * 2^N + \n       ... (b_(n-1) <0) * 2^(n*N) \n       = (b_n + (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + (b_0<0)) * 2^N + b_0 * 2^0;\n       Together:\n       retValue = \n       (b_n + isSigned * (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + isSigned * (b_0<0)) * 2^N + b_0 * 2^0;\n    */\n\n    retValue = dblValue[numOfChunk - 1];\n    \n    for(i = numOfChunk - 1; i > 0; i--) {\n        isSignedNeg = dblValue[i - 1] < 0 ? (double)isSigned : 0;\n        retValue = retValue + isSignedNeg;\n\n        retValue = ldexp(retValue, bitsPerChunk)+ dblValue[i-1];\n    }\n    retValue = ldexp( fracSlope * retValue, fixedExp ) + bias;\n\n    FREE(dblValue);\n    return (retValue);\n\n} /* end rt_GetDblValueFromOverSizedData */\n\n\n/* Function: rt_GetNonBoolMxIdFromDTypeId ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nstatic mxClassID rt_GetNonBoolMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        mxID = (sizeof(real_T)==4? mxSINGLE_CLASS: mxDOUBLE_CLASS);\n        break;\n      case SS_SINGLE:\n        mxID = mxSINGLE_CLASS;\n        break;\n      case SS_INT8:\n        switch (sizeof(int8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 32-bits\" */\n            mxID = mxINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 16-bits\" */\n            mxID = mxINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_UINT8:\n        switch (sizeof(uint8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxUINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_INT16:\n        mxID = (sizeof(int16_T)==4? mxINT32_CLASS: mxINT16_CLASS);\n        break;\n      case SS_UINT16:\n        mxID = (sizeof(uint16_T)==4? mxUINT32_CLASS: mxUINT16_CLASS);\n        break;\n      case SS_INT32:\n        mxID = mxINT32_CLASS;\n        break;\n      case SS_UINT32:\n        mxID = mxUINT32_CLASS;\n        break;\n        /*case SS_BOOLEAN:\n          mxID = (sizeof(boolean_T)==4? mxUINT32_CLASS: mxLOGICAL_CLASS);\n          break;*/\n      default:\n        mxID = mxUNKNOWN_CLASS;\n        break;\n    }\n\n    return(mxID);\n\n} /* end rt_GetNonBoolMxIdFromDTypeId */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeIdForRSim ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxLOGICAL_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeIdForRSim */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeId =============================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxUINT8_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeId */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n/* Function: rt_GetMatIdFromMxId ===============================================\n * Abstract:\n *      Get the MatId given the mxClassID.\n */\nstatic int_T rt_GetMatIdFromMxId(mxClassID mxID)\n{\n    int_T matID;\n\n    switch (mxID) {\n      case mxCELL_CLASS:\n      case mxSTRUCT_CLASS:\n      case mxOBJECT_CLASS:\n        matID = -1;\n        break;\n      case mxCHAR_CLASS:\n        matID = matUINT16;\n        break;\n      case mxDOUBLE_CLASS:\n        matID = matDOUBLE;\n        break;\n      case mxSINGLE_CLASS:\n        matID = matFLOAT;\n        break;\n      case mxINT8_CLASS:\n        matID = matINT8;\n        break;\n      case mxUINT8_CLASS:\n        matID = matUINT8;\n        break;\n      case mxINT16_CLASS:\n        matID = matINT16;\n        break;\n      case mxUINT16_CLASS:\n        matID = matUINT16;\n        break;\n      case mxINT32_CLASS:\n        matID = matINT32;\n        break;\n      case mxUINT32_CLASS:\n        matID = matUINT32;\n        break;\n      case mxINT64_CLASS:\n        matID = matINT64;\n        break;\n      case mxUINT64_CLASS:\n        matID = matUINT64;\n        break;\n      default:\n        matID = matUNKNOWN;\n        break;\n    }\n    return(matID);\n\n} /* end rt_GetMatIdFromMxId */\n\n\n/* Forward declaration */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind dataKind);\n\n\n/* Function: rt_ProcessMatItem =================================================\n * Abstract:\n *      This routine along with rt_WriteItemToMatFile() write out a specified\n *      mat-item the .mat file. Note that if the input argument\n *          cmd == 0, then this function just calculates the size of the item.\n *          cmd <> 0, this function writes the mat-item to the file.\n *      Return values is\n *           -1 : coding/logic error\n *            0 : upon success\n *          > 0 : upon write failure (1)\n */\nstatic int_T rt_ProcessMatItem(FILE         *fp,\n                               MatItem      *pItem,\n                               ItemDataKind itemKind,\n                               int_T        cmd)\n{\n    mxClassID    mxID          = mxUNKNOWN_CLASS;\n    uint32_T     arrayFlags[2] = {0, 0};\n    int32_T      *dims         = NULL;\n    int32_T      _dims[3]      = {0, 0, 0};\n    int32_T      nDims         = 2;\n    int32_T      nBytesInItem  = 0;\n    const char_T *itemName;\n    MatItem      item;\n    int_T        retStat       = 0;\n\n    switch (itemKind) {\n      case DATA_ITEM: {\n          (void)fprintf(stderr,\"Unexpected itemKind = DATA_ITEM in \"\n                               \"rt_ProcessMatItem @A\\n\");\n          retStat = -1;\n          goto EXIT_POINT;\n      }\n      case MATRIX_ITEM: {\n          const MatrixData *var = (const MatrixData *) pItem->data;\n\n          mxID           = var->mxID;\n          arrayFlags[0]  = mxID;\n          arrayFlags[0] |= var->logical;\n          arrayFlags[0] |= var->complex;\n          if (var->nDims < 2) {\n              dims         = _dims;\n              dims[0]      = var->nRows;\n              dims[1]      = var->nCols;\n              nDims        = 2;\n          } else {\n              int32_T k;\n              dims = (int32_T*)malloc(sizeof(int32_T)*(var->nDims+1));\n              for (k = 0; k < var->nDims; k++) {\n                  dims[k] = var->dims[k];\n              }\n              dims[var->nDims] = var->nRows;\n              nDims = var->nDims + 1;\n          }\n          itemName = var->name;\n          break;\n      }\n      case STRUCT_LOG_VAR_ITEM: {\n          const StructLogVar *var = (const StructLogVar *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = 1;\n          itemName      = var->name;\n          break;\n      }\n      case SIGNALS_STRUCT_ITEM: {\n          const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = var->numSignals;\n          itemName      = &SIGNALS_FIELD_NAME;\n          break;\n      }\n      default:\n        (void)fprintf(stderr,\"Unexpected itemKind=%d in rt_ProcessMatItem @B\\n\",\n                      itemKind);\n        retStat = -1;\n        goto EXIT_POINT;\n    }\n\n    /* array flags */\n    item.nbytes = 2*sizeof(uint32_T);\n    if (cmd) {\n        item.type = matUINT32;\n        item.data = arrayFlags;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* dimensions */\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    item.nbytes = nDims*sizeof(int32_T);\n    if (cmd) {\n        item.type = matINT32;\n        item.data = dims;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;            \n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* name */\n    item.nbytes = (int32_T)strlen(itemName);\n    if (cmd) {\n        item.type = matINT8;\n        item.data = (const char_T*) itemName;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        nBytesInItem += (item.nbytes <= 4) ? /*LINTED E_CAST_INT_TO_SMALL_INT*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n\n    if (itemKind == MATRIX_ITEM) {\n        const MatrixData *var   = (const MatrixData*) pItem->data;\n        int_T            matID  = rt_GetMatIdFromMxId(mxID);\n        size_t           elSize = var->elSize;\n\n        /* data */\n        item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n        if (cmd) {\n            item.type = matID;\n            item.data = var->re;\n            if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n        }\n        /* imaginary part */\n        if (var->complex) {\n            item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n            if (cmd) {\n                item.type = matID;\n                item.data = var->im;\n                if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                    retStat = 1;\n                    goto EXIT_POINT;\n                }\n            } else {\n                nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n            }\n        }\n    } else {  /* some type of structure item */\n        const char_T *fieldNames;\n        int_T        sizeofFieldNames;\n\n        /* field names */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = (const StructLogVar *) pItem->data;\n              fieldNames        = rtStructLogVarFieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n              fieldNames        = var->fieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @C\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n\n        /* write field names */\n        if (cmd) {\n            int32_T tmpInt = mxMAXNAM;\n\n            item.nbytes = sizeof(int32_T);\n            item.type   = matINT32;\n            item.data   = &tmpInt;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n\n            item.nbytes = sizeofFieldNames;\n            item.type   = matINT8;\n            item.data   = (const char_T*) fieldNames;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            /*LINTED E_CAST_INT_TO_SMALL_INT*/\n            nBytesInItem += matINT64_ALIGN( matTAG_SIZE + matTAG_SIZE +\n                                            sizeofFieldNames );\n        }\n\n        /* process each field of the structure */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = pItem->data;\n\n              /* time */\n              {\n                  const void *data = var->time;\n\n                  if (var->logTime) { /* time is a LogVar, get the MatrixData */\n                      data = &(((const LogVar*) (var->time))->data);\n                  }\n\n                  item.type = matMATRIX;\n                  item.data = data;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp,&item,MATRIX_ITEM)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM,0)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n\n              /* signals */\n              item.type = matMATRIX;\n              item.data = &(var->signals);\n              if (cmd) {\n                  if (rt_WriteItemToMatFile(fp,&item,SIGNALS_STRUCT_ITEM)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n              } else {\n                  if (rt_ProcessMatItem(fp, &item, SIGNALS_STRUCT_ITEM,0)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n                  nBytesInItem += item.nbytes + matTAG_SIZE;\n              }\n\n              /* block name */\n              if (var->blockName != NULL) {\n                  item.type = matMATRIX;\n                  item.data = var->blockName;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var        = pItem->data;\n              const LogVar        *values     = var->values;\n              const MatrixData    *dimensions = var->dimensions;\n              const MatrixData    *labels     = var->labels;\n              const MatrixData    *plotStyles = var->plotStyles;\n              const MatrixData    *titles     = var->titles;\n              const MatrixData    *blockNames = var->blockNames;\n              const MatrixData    *stateNames = var->stateNames;\n              const MatrixData    *crossMdlRef = var->crossMdlRef;\n              const boolean_T logValueDimensions = var->logValueDimensions;\n              int_T               i;\n\n              for (i = 0; i < var->numSignals; i++) {\n                  /* values */\n                  item.type = matMATRIX;\n                  item.data = &(values->data);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n\n                  if(logValueDimensions)\n                  {\n                      /* valueDimensions */\n                      /* Since the functions rt_WriteItemToMatFile and \n                         rt_ProcessMatItem deal with MatrixData, \n                         convert valDims to tempData, and fill up the\n                         necessary fields.\n                      */\n                      MatrixData  tempData;\n                      (void)memcpy(tempData.name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n                      tempData.nRows = values->valDims->nRows;\n                      tempData.nCols = values->valDims->nCols;\n                      tempData.nDims = 1;\n                      tempData._dims[0] = values->valDims->nCols;\n                      tempData.re = values->valDims->dimsData;\n                      tempData.im = NULL;\n                      tempData.dTypeID = SS_DOUBLE;\n                      tempData.elSize =  sizeof(real_T);\n                      tempData.mxID = mxDOUBLE_CLASS;\n                      tempData.logical = 0;\n                      tempData.complex = 0;\n                      tempData.frameData = 0;\n                      tempData.frameSize = 1;\n\n                      item.type = matMATRIX;                    \n                      item.data = &tempData; /*values->valDims;*/\n\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  values = values->next;\n\n                  /* dimensions */\n                  if (dimensions != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(dimensions[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n\n                  /* label */\n                  item.type = matMATRIX;\n                  item.data = &(labels[i]);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n                  /* title */\n                  if (titles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(titles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* plot style */\n                  if (plotStyles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(plotStyles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* block name */\n                  if (blockNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(blockNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* state name */\n                  if (stateNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* crossMdlRef */\n                  if (crossMdlRef != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(crossMdlRef[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n              } /* for i=1:numSignals */\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @D\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n    } /* end struct item */\n\n    if (!cmd) {\n        pItem->nbytes = nBytesInItem;\n    }\n\n  EXIT_POINT:\n    if (dims != _dims) {\n        FREE(dims);\n    }\n    return(retStat);\n\n} /* end rt_ProcessMatItem */\n\n\n/* Function: rt_WriteItemToMatFile =============================================\n * Abstract:\n *      Entry function for writing out a mat item to the mat file.\n *\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind itemKind)\n{\n    /* Determine the item size */\n    if (pItem->type == matMATRIX) {\n        if (rt_ProcessMatItem(fp, pItem, itemKind, 0)) return(1);\n    }\n\n    /* Write the item tag and data */\n    if (pItem->nbytes > 4) {\n        int32_T nAlignBytes;\n\n        if (fwrite(pItem, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n\n        if (pItem->type == matMATRIX) {\n            if (rt_ProcessMatItem(fp, pItem, itemKind, 1)) return(1);\n        } else {\n            if ( fwrite(pItem->data, 1, pItem->nbytes, fp) !=\n                                                    ((size_t) pItem->nbytes) ) {\n                return(1);\n            }\n        }\n\n        /* Add offset for 8-byte alignment */\n        nAlignBytes = matINT64_ALIGN(pItem->nbytes) - pItem->nbytes;\n        if (nAlignBytes > 0) {\n            int pad[2] = {0, 0};\n            if ( fwrite(pad,1,nAlignBytes,fp) != ((size_t) nAlignBytes) ) {\n                return(1);\n            }\n        }\n    } else {\n        MatItem item = {0, 0, NULL};\n        item.type = ((uint32_T)(pItem->type))|(((uint32_T)(pItem->nbytes))<<16);\n        (void)memcpy(&item.nbytes, pItem->data, pItem->nbytes);\n        if (fwrite(&item, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n    }\n\n    return(0);\n\n} /* end rt_WriteItemToMatFile */\n\n\n/* Function: rt_WriteMat5FileHeader ============================================\n * Abstract:\n *      Function to write the mat file header.\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteMat5FileHeader(FILE *fp)\n{\n    int_T        nbytes;\n    int_T        nspaces;\n    int_T        i, n;\n    unsigned short ver[2];\n    char_T       spaces[16];\n    const char_T *matversion = \"MATLAB 5.0 MAT-file\";\n\n    (void)memset(spaces, ' ', sizeof(spaces));\n\n    n = (int_T)strlen(matversion);\n    nbytes = (int_T)fwrite(matversion, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    nspaces = matVERSION_INFO_OFFSET - nbytes;\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces % sizeof(spaces);\n    nbytes += (int_T)fwrite(spaces, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces / sizeof(spaces);\n    for (i = 0; i < n; ++i) {\n        nbytes += (int_T)fwrite(spaces, 1, sizeof(spaces), fp);\n    }\n    if (nbytes == matVERSION_INFO_OFFSET) {\n        ver[0] = matVERSION;\n        ver[1] = matKEY;\n        nbytes += (int_T)fwrite(ver, 1, sizeof(ver), fp);\n    }\n    return(nbytes != matVERSION_INFO_OFFSET + sizeof(ver));\n\n} /* end rt_WriteMat5FileHeader */\n\n\n/* Function: rt_FixupLogVar ====================================================\n * Abstract:\n *\tMake the logged variable suitable for MATLAB.\n */\nstatic const char_T *rt_FixupLogVar(LogVar *var,int verbose)\n{\n    int_T  nCols   = var->data.nCols;\n    int_T  maxRows = var->data.nRows;\n    int_T  nDims   = var->data.nDims;\n    size_t elSize  = var->data.elSize;\n    int_T  nRows   = (var->wrapped ?  maxRows : var->rowIdx);\n\n    var->nDataPoints = var->rowIdx + var->wrapped * maxRows;\n\n    if (var->wrapped > 1 || (var->wrapped == 1 && var->rowIdx != 0)) {\n        /*\n         * Warn the user the circular buffer has wrapped, implying that\n         * some data has been lost.\n         */\n        if( verbose) {\n            (void)fprintf(stdout,\n                          \"*** Log variable %s has wrapped %d times\\n\"\n                          \"    using a circular buffer of size %d\\n\",\n                          var->data.name, var->wrapped, var->data.nRows);\n        }\n        if (var->usingDefaultBufSize) {\n            /*\n             * If wrapping occurred using the default buffer size,\n             * let the user know what size buffer to use in the\n             * future to avoid wrapping.  If the default buffer\n             * size was not used, the user has no control to specify\n             * the correct value.  Wrapping may occur when not using\n             * the default buffer if we allocated too small a buffer\n             * size for this logvar.  One common case is a toWorkspace\n             * block inside of an iterative subsystem - we can not take\n             * the number of iterations into account (they may be\n             * variable) when allocating the buffer.  In this case,\n             * just warn the buffer wrapped and don't tell user they\n             * can override the buffer size.\n             */\n            if( verbose ) {\n                (void)fprintf(stdout,\n                              \"*** To avoid wrapping, explicitly specify a\\n\"\n                              \"    buffer size of %d in your Simulink model\\n\"\n                              \"    by adding OPTS=\\\"-DDEFAULT_BUFFER_SIZE=%d\\\"\\n\"\n                              \"    as an argument to the ConfigSet MakeCommand\\n\"\n                              \"    parameter\\n\",\n                              var->nDataPoints, var->nDataPoints);\n            }\n        }\n    }\n\n    if (nDims < 2 && nCols > 1) {  /* Transpose? */\n        /* Don't need to transpose valueDimensions */\n        int_T  nEl    = nRows*nCols;\n        char   *src   = var->data.re;\n        char   *pmT;\n        int_T  k;\n\n        /**********************************\n         * If memory cannot be allocated, *\n         * write to a temporary buffer    *\n         **********************************/\n        if ((pmT = malloc(nEl*elSize)) == NULL) {\n            FILE  *fptr;\n            char  fName[mxMAXNAM+13];\n\n            (void)sprintf(fName, \"%s%s\", var->data.name, \"_rtw_tmw.tmw\");\n            if ((fptr=fopen(fName,\"w+b\")) == NULL) {\n                (void)fprintf(stderr,\"*** Error opening %s\",fName);\n                return(\"unable to open data file\\n\");\n            }\n\n            /****************************\n             * Write the data to a file *\n             ****************************/\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nCols*(k%nRows) + (k/nRows);\n                char  *dst = src + kT*elSize;\n                (void)fwrite(dst, elSize, 1, fptr);\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n\n            /*******************************\n             * Read the data from the file *\n             *******************************/\n            (void)rewind(fptr);\n            (void)fread(var->data.re, elSize, nEl, fptr);\n            (void)fclose(fptr);\n            (void)remove(fName);\n        } else {\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nRows*(k%nCols) + (k/nCols);\n                char  *dst = pmT + kT*elSize;\n                (void)memcpy(dst, src, elSize);\n                src += elSize;\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n            FREE(var->data.re);\n            var->data.re = pmT;\n        }\n    } /* Transpose? */\n\n    if (var->wrapped > 0 && var->rowIdx != 0 ) {  /* Rotate? */\n        char_T *buffer    = var->data.re;\n        int_T  done       = 0; /* done: 0 (1) rotate real (imag) part. */\n\n        do {\n            char_T *col       = buffer;\n            int_T  rowOffset  = (int_T)((nDims == 1) ? (elSize) : (elSize * nCols));\n            int_T  colOffset  = (int_T)((nDims == 1)?  (nRows*elSize) : elSize);\n            int_T  zeroIdx    = var->rowIdx;\n            int_T  j;\n\n            for (j = 0 ; j < nCols; ++j, col += colOffset) {\n                int_T   swapCount;\n                int_T   srcIdx;\n                int_T   dstIdx;\n                int_T   tmpIdx;\n                MatReal tmp;\n\n                for (tmpIdx=0, swapCount=0; swapCount < nRows; tmpIdx++) {\n                    (void)memcpy(&tmp, col + tmpIdx*rowOffset, elSize);\n\n                    dstIdx=tmpIdx; \n                    srcIdx = ((dstIdx + zeroIdx) % nRows);\n                    while (srcIdx != tmpIdx) {\n                        (void)memcpy(col + dstIdx*rowOffset,\n                                     col + srcIdx*rowOffset,\n                                     elSize);\n                        ++swapCount;\n                        dstIdx = srcIdx;\n                        srcIdx = ((dstIdx + zeroIdx) % nRows);\n                        \n                    }\n                    (void)memcpy(col + dstIdx*rowOffset, &tmp, elSize);\n                    ++swapCount;\n                }\n            }\n            done ++;\n            /* need to rotate the imaginary part */\n        } while ((done == 1) && ((buffer = var->data.im) != NULL));\n\n        var->rowIdx = 0;\n    } /* Rotate? */\n\n    /*\n     * We might have allocated more number of rows than the number of data\n     * points that have been logged, in which case set nRows to nDataPoints\n     * so that only these values get saved.\n     */\n    if (var->nDataPoints < var->data.nRows) {\n        var->data.nRows = var->nDataPoints;\n        if(var->valDims != NULL){\n            size_t elSizeValDims = sizeof(real_T);\n            int_T  k;\n            real_T *dimsData = var->valDims->dimsData + nRows;\n            /* \n               Keep nRows of values and that of valueDimensions consistent \n               for variable-size signals.\n            */\n            var->valDims->nRows = var->data.nRows;\n            /*\n               Also need to move data when shrinking the array size,\n               because valueDimensions data is stored in array format. \n               e.g. maxRows = 4; nRows = 2; nDims = 3;\n               Before fixing up the logVar, the locations of data are as below:\n               (x, y, z -- useful data / o -- junk)\n               a[0] = x    a[4] = y    a[8] = z\n               a[1] = x    a[5] = y    a[9] = z\n               a[2] = o    a[6] = o    a[10]= o\n               a[3] = o    a[7] = o    a[11]= o\n               After fixing up the logVar, we want the data to be stored as:\n               a[0] = x    a[4] = z    a[8] = o\n               a[1] = x    a[5] = z    a[9] = o\n               a[2] = y    a[6] = o    a[10]= o\n               a[3] = y    a[7] = o    a[11]= o\n            */\n            for(k = 1; k < nDims; k++){\n                (void) memmove(dimsData, \n                              var->valDims->dimsData + k*maxRows,\n                              elSizeValDims * nRows);\n                dimsData += nRows;\n            }\n        }\n    }\n    return(NULL);\n\n} /* end rt_FixupLogVar */\n\n\n/* Function: rt_LoadModifiedLogVarName =========================================\n * Abstract:\n *      The name of the logged variable is obtained from the input argument\n *      varName and the nameModifier which is obtained from the simstruct. If\n *      the nameModifier begins with an '_', then nameModifier is post-pended to\n *      varName to obtain the name of the logged variable. If the first\n *      character does not begin with an '_', then the nameModifier is\n *      pre-pended to varName.\n *\n * Examples:\n *     a)  varName = \"tout\" & nameModifier = \"_rt\"  => logVarName = \"tout_rt\"\n *     b)  varName = \"tout\" & nameModifier = \"rt_\"  => logVarName = \"rt_tout\"\n *     c)  varName = \"tout\" & nameModifier = \"none\" => logVarName = \"tout\"\n */\nstatic void rt_LoadModifiedLogVarName(const RTWLogInfo *li,         /* in  */\n                                      const char       *varName,    /* in  */\n                                      char             *logVarName) /* out */\n{\n    int_T        nameLen;\n    const char_T *nameModifier = rtliGetLogVarNameModifier(li);\n\n    if (nameModifier != NULL && strcmp(nameModifier,\"none\")==0) {\n        nameModifier = NULL;\n    }\n\n    logVarName[mxMAXNAM-1] = '\\0';\n    if (nameModifier == NULL) {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n    } else if (nameModifier[0] == '_') {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, nameModifier, (size_t)mxMAXNAM-1-nameLen);\n    } else {\n        (void)strncpy(logVarName, nameModifier, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, varName, (size_t)mxMAXNAM-1-nameLen);\n    }\n\n} /* end rt_LoadModifiedLogVarName */\n\n\n/* Function: rt_GetActualDTypeID ===============================================\n * Abstract:\n *\tGiven a built-in data type id, return the actual data type id.\n *\tThe only time these are different is when real_T has been mapped\n *\tto a single.\n */\n#if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable: 4127)\n#endif\nstatic BuiltInDTypeId rt_GetActualDTypeID(BuiltInDTypeId dTypeID)\n{\n    /*LINTED E_FALSE_LOGICAL_EXPR*/\n    if (dTypeID == SS_DOUBLE && sizeof(real_T) != 8) {     /* polyspace DEFECT:DEAD_CODE \n                                                              [Not a defect:Unset] \n                                                              \"Needed for when real_T has been \n                                                              mapped to a single\" */\n        return(SS_SINGLE);\n    } else {\n        return(dTypeID);\n    }\n\n} /* end rt_GetActualDTypeID */\n#if defined(_MSC_VER)\n #pragma warning(pop)\n#endif\n\n\n/* Function: rt_DestroyLogVar ==================================================\n * Abstract:\n *      Destroy the log var linked list.\n */\nstatic void rt_DestroyLogVar(LogVar *head)\n{\n    while(head) {\n        LogVar *var = head;\n        head = var->next;\n        FREE(var->data.re);\n        FREE(var->data.im);\n        if (var->data.dims != var->data._dims) {\n            FREE(var->data.dims);\n        }\n        /* free valDims if necessary */\n        if(var->valDims != NULL) {\n            FREE(var->valDims->dimsData);\n            FREE(var->valDims);\n        }\n        /* free coords, strides and currStrides if necessary */\n        FREE(var->coords);\n        FREE(var->strides);\n        FREE(var->currStrides);\n\n        FREE(var);\n    }\n\n} /* end rt_DestroyLogVar */\n\n\n/* Function: rt_DestroyStructLogVar ============================================\n * Abstract:\n *      Destroy the struct log var linked list.\n */\nstatic void rt_DestroyStructLogVar(StructLogVar *head)\n{\n    while(head) {\n        StructLogVar *var = head;\n\n        head = var->next;\n\n        if (var->logTime) { /* time is LogVar */\n            rt_DestroyLogVar(var->time);\n        } else {        /* time is MatrixData */\n            FREE(var->time);\n        }\n        rt_DestroyLogVar(var->signals.values);\n        FREE(var->signals.labels);\n        FREE(var->signals.plotStyles);\n        FREE(var->signals.dimensions);\n        FREE(var->signals.titles);\n        FREE(var->signals.blockNames);\n        FREE(var->signals.stateNames);\n        FREE(var->signals.crossMdlRef);\n        FREE(var->blockName);\n        FREE(var);\n    }\n\n} /* end rt_DestroyStructLogVar */\n\n\n/* Function: rt_InitSignalsStruct ==============================================\n * Abstract:\n *      Initialize the signals structure in the struct log variable.\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nstatic const char_T *rt_InitSignalsStruct(RTWLogInfo             *li,\n                                          const real_T           startTime,\n                                          const real_T           finalTime,\n                                          const real_T           inStepSize,\n                                          const char_T           **errStatus,\n                                          StructLogVar           *var,\n                                          int_T                  maxRows,\n                                          int_T                  decimation,\n                                          real_T                 sampleTime,\n                                          const RTWLogSignalInfo *sigInfo)\n{\n    int_T                i, sigIdx;\n    SignalsStruct        *sig          = &(var->signals);\n    int_T                nSignals      = sigInfo->numSignals;\n    const int_T          *numCols      = sigInfo->numCols;\n    const int_T          *numDims      = sigInfo->numDims;\n    const int_T          *dims         = sigInfo->dims;\n    const BuiltInDTypeId *dTypes       = sigInfo->dataTypes;\n    const int_T          *cSgnls       = sigInfo->complexSignals;\n    const int_T          *fData        = sigInfo->frameData;\n    const char_T         **labels      = sigInfo->labels.cptr;\n    const int_T          *plotStyles   = sigInfo->plotStyles;\n    const char_T         *titles       = sigInfo->titles;\n    const int_T          *titleLen     = sigInfo->titleLengths;\n    const char_T         **blockNames  = sigInfo->blockNames.cptr;\n    const char_T         **stateNames  = sigInfo->stateNames.cptr;\n    const boolean_T      *crossMdlRef  = sigInfo->crossMdlRef;\n    void                 **currSigDims = sigInfo->currSigDims;\n    int_T                *currSigDimsSize = sigInfo->currSigDimsSize;\n    LogVar               *prevValues   = NULL;\n    int_T                dimsOffset    = 0;\n    boolean_T            *isVarDims    = sigInfo->isVarDims;\n    /* if any signal is variable-size, the field 'valueDimensions' is needed */\n    boolean_T            logValueDimensions = false;\n    const RTWLogDataTypeConvert *pDTConvInfo = sigInfo->dataTypeConvert;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    sig->numActiveFields = 1;\n    sig->numSignals      = nSignals;\n\n    sig->isVarDims = isVarDims;\n    /* check whether we need valueDimensions field*/\n    for (i=0; i<nSignals; i++){\n        if(isVarDims[i]){\n            logValueDimensions = true;\n            break;\n        }\n    }\n\n    /* values */\n    dimsOffset = 0;\n    for (i = 0; i < nSignals; i++) {\n        BuiltInDTypeId dt = (dTypes) ? dTypes[i] : SS_DOUBLE;\n        int_T          cs = (cSgnls) ? cSgnls[i] : 0;\n        int_T          fd = (fData)  ? fData[i]  : 0;\n        int_T          nd = (numDims) ? numDims[i] : 1;\n\n        const RTWLogDataTypeConvert *pDTConvInfoCur =\n                       (pDTConvInfo)  ? (pDTConvInfo+i)  : 0;\n\n        LogVar *values = NULL;\n        LogValDimsStat logValDimsStat;\n\n        if(!logValueDimensions){\n            logValDimsStat = NO_LOGVALDIMS;\n        }\n        else{\n            logValDimsStat = isVarDims[i] ? LOGVALDIMS_VARDIMS :  \n                                            LOGVALDIMS_EMPTYMX;\n        }\n\n        values = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                            inStepSize, errStatus,\n                                            &VALUES_FIELD_NAME,\n                                            dt, \n                                            pDTConvInfoCur,\n                                            0, cs, fd,\n                                            numCols[i],nd,\n                                            dims + dimsOffset,\n                                            logValDimsStat,\n                                            currSigDims + dimsOffset,\n                                            currSigDimsSize + dimsOffset,\n                                            maxRows,decimation,sampleTime, 0);\n\n        if (values == NULL) goto ERROR_EXIT;\n\n        if (sig->values == NULL) {\n            sig->values = values;\n        } else {\n            if (prevValues == NULL) goto ERROR_EXIT;\n            prevValues->next = values;\n        }\n        prevValues = values;\n        dimsOffset += nd;\n    }\n\n    if(logValueDimensions){\n        ++sig->numActiveFields;\n        sig->logValueDimensions = true;\n    }\n    else{\n        sig->logValueDimensions = false;\n    }\n\n    /* Dimensions */\n    {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            int_T nd = (numDims) ? numDims[i] : 1;\n            dataLen += nd;\n        }\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->dimensions = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->dimensions)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n          data[i] = dims[i]; /* cannot memcpy double <- int */\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->dimensions[i]);\n            int_T nd = (numDims) ? numDims[i] : 1;\n\n            (void)memcpy(mtxData->name, &DIMENSION_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = 1;\n            mtxData->nCols   = nd;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += nd;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* labels */\n    if (labels != NULL) {\n        unsigned short   *data;\n        size_t  nbytes;\n        int_T   dataLen    = 0;\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (labels[i] != NULL){\n                dataLen = dataLen + (int_T)strlen(labels[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->labels = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->labels)) + dataOffset);\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T labelLen = (labels[sigIdx]==NULL) ? 0 : (int_T)strlen(labels[sigIdx]);\n            for (i = 0; i < labelLen; i++) {\n                data[dataIdx++] = (uint8_T)labels[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->labels[i]);\n            int_T labelLen = (int_T)strlen(labels[i]);\n\n            (void)memcpy(mtxData->name, &LABEL_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (labelLen) ? 1 : 0;\n            mtxData->nCols   = labelLen;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += labelLen;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* plot styles */\n    if (plotStyles != NULL) {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            dataLen += numCols[i];\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->plotStyles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (real_T*) (((char_T*) (sig->plotStyles)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n            data[i] = plotStyles[i];\n        }\n\n        dimsOffset = 0;\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->plotStyles[i]);\n            \n            (void)memcpy(mtxData->name, &PLOTSTYLE_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = (numCols[i]) ? 1 : 0;\n            mtxData->nCols   = numCols[i];\n\n            mtxData->nDims   = numDims[i];\n            \n            if(mtxData->nDims > 2) {\n                if ((mtxData->dims = calloc(mtxData->nDims, sizeof(int_T))) == NULL) goto ERROR_EXIT;\n            } else {\n                mtxData->dims    = mtxData->_dims;\n            }\n            \n            mtxData->dims[0] = *(dims + dimsOffset);\n            if(mtxData->nDims >= 2) {\n                int32_T j;\n                for (j=1; j<mtxData->nDims; j++) {\n                    mtxData->dims[j] = *(dims + dimsOffset + j);\n                }\n            }\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data       += numCols[i];\n            dimsOffset += numDims[i];\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* titles */\n    if (titles != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen    = (int_T)strlen(titles);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->titles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (unsigned short*) (((char_T*) (sig->titles)) + dataOffset);\n        for (i = 0; i < dataLen; i++) {\n            data[i] = titles[i];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->titles[i]);\n\n            (void)memcpy(mtxData->name, &TITLE_FIELD_NAME, mxMAXNAM);\n            if (titleLen) {\n                mtxData->nRows   = (titleLen[i]) ? 1 : 0;\n                mtxData->nCols   = titleLen[i];\n            } else {\n                mtxData->nRows   = (dataLen) ? 1 : 0;\n                mtxData->nCols   = dataLen;\n            }\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += ((titleLen) ? titleLen[i] : dataLen);\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* block names */\n    if (blockNames != NULL)     {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (blockNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(blockNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->blockNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->blockNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (blockNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(blockNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)blockNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->blockNames[i]);\n            int_T blockNameLen = (int_T)strlen(blockNames[i]);\n\n            (void)memcpy(mtxData->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (blockNameLen) ? 1 : 0;\n            mtxData->nCols   = blockNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += blockNameLen;\n        }\n        ++sig->numActiveFields;\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    } else {\n        if(logValueDimensions){\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* state names */\n    if (stateNames != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (stateNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(stateNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->stateNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->stateNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (stateNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(stateNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)stateNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateNames[i]);\n            int_T stateNameLen = (int_T)strlen(stateNames[i]);\n\n            (void)memcpy(mtxData->name, &STATENAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (stateNameLen) ? 1 : 0;\n            mtxData->nCols   = stateNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += stateNameLen;\n        }\n        ++sig->numActiveFields;\n\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* CrossMdlRef */\n    if (crossMdlRef != NULL) {\n        real_T  *data;\n        size_t nbytes;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->crossMdlRef = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->crossMdlRef)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = crossMdlRef[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->crossMdlRef[i]);\n\n            (void)memcpy(mtxData->name, &CROSS_MDL_REF_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_DOUBLE;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(SS_DOUBLE);\n            mtxData->elSize  = sizeof(real_T);\n            mtxData->logical = matLOGICAL_BIT;\n            mtxData->complex = 0U;\n            mtxData->frameData = 0;\n            mtxData->frameSize = 1;\n        }\n        ++sig->numActiveFields;\n    }\n    \n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n\n    (void)fprintf(stderr, \"*** Error creating signals structure \"\n                  \"in the struct log variable %s\\n\", var->name);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyLogVar(sig->values);\n    FREE(sig->labels);\n    FREE(sig->plotStyles);\n    FREE(sig->dimensions);\n    FREE(sig->titles);\n    FREE(sig->blockNames);\n    FREE(sig->stateNames);\n    FREE(sig->crossMdlRef);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\n\n/* Function: local_CreateStructLogVar ==========================================\n * Abstract:\n *      Create a logging variable in the structure format.\n *\n * Returns:\n *      ~= NULL  => success, returns the log variable created.\n *      == NULL  => failure, error message set in the simstruct.\n */\nstatic StructLogVar *local_CreateStructLogVar(\n    RTWLogInfo              *li,\n    const real_T            startTime,\n    const real_T            finalTime,\n    const real_T            inStepSize,\n    const char_T            **errStatus,\n    const char_T            *varName,\n    boolean_T               logTime,\n    int_T                   maxRows,\n    int_T                   decimation,\n    real_T                  sampleTime,\n    const RTWLogSignalInfo  *sigInfo,\n    const char_T            *blockName)\n{\n    StructLogVar *var;\n    LogInfo      *logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ( (var = calloc(1, sizeof(StructLogVar))) == NULL ) goto ERROR_EXIT;\n\n    var->numActiveFields = 2;\n\n    /* Setup the structure name using varName and nameModifier */\n    rt_LoadModifiedLogVarName(li,varName,var->name);\n\n    /* time field */\n    if (logTime) {\n        /* need to create a LogVar to log time */\n        int_T dims = 1;\n        var->time = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                               inStepSize, errStatus,\n                                               &TIME_FIELD_NAME, SS_DOUBLE, \n                                               NULL,\n                                               0, 0, 0, 1,\n                                               1, &dims, NO_LOGVALDIMS, \n                                               NULL, NULL, maxRows,\n                                               decimation, sampleTime, 0);\n        if (var->time == NULL) goto ERROR_EXIT;\n    } else {\n        /* create a dummy MatrixData to write out time as an empty matrix */\n        BuiltInDTypeId dt     = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         nbytes = sizeof(MatrixData);\n        MatrixData     *time;\n\n        if ( (var->time = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n        time = var->time;\n\n        (void)memcpy(time->name, &TIME_FIELD_NAME, mxMAXNAM);\n        time->nRows   = 0;\n        time->nCols   = 0;\n        time->nDims   = 0;\n        time->re      = NULL;\n        time->im      = NULL;\n        time->dTypeID = dt;\n        time->mxID    = rt_GetMxIdFromDTypeId(dt);\n        time->elSize  = rt_GetSizeofDataType(dt);\n        time->logical = 0U;\n        time->complex = 0U;\n    }\n    var->logTime = logTime;\n\n    /* signals field */\n    if (sigInfo) {\n        if (rt_InitSignalsStruct(li,startTime,finalTime,inStepSize,errStatus,\n                                 var,maxRows,decimation,sampleTime,sigInfo)) {\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* blockName Field */\n    if (blockName != NULL) {\n        int_T  dataLen = (int_T)strlen(blockName);\n        size_t nbytes;\n        size_t dataOffset = sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (var->blockName = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        (void)memcpy(var->blockName->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n        var->blockName->nRows   = (dataLen) ? 1 : 0;\n        var->blockName->nCols   = dataLen;\n\n        var->blockName->nDims   = 1;\n        var->blockName->dims    = var->blockName->_dims;\n        var->blockName->dims[0] = dataLen;\n        {\n            /*LINTED E_BAD_PTR_CAST_ALIGN*/\n            unsigned short *data = (unsigned short*)(((char_T*) (var->blockName))+dataOffset);\n            int_T   i;\n\n            for (i=0; i<dataLen; i++) {\n                data[i] = (uint8_T)blockName[i];\n            }\n            var->blockName->re  = data;\n        }\n        var->blockName->im      = NULL;\n        var->blockName->dTypeID = SS_INT16;\n        var->blockName->mxID    = mxCHAR_CLASS;\n        var->blockName->elSize  = sizeof(short);\n        var->blockName->logical = 0U;\n        var->blockName->complex = 0U;\n\n        ++var->numActiveFields;\n    }\n\n    /* Add this struct log var to the linked list in log info */\n    {\n        StructLogVar *list = logInfo->structLogVarsList;\n\n        if (list != NULL) {\n            while (list->next != NULL) {\n                list = list->next;\n            }\n            list->next = var;\n        } else {\n            logInfo->structLogVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Error creating log variable %s\\n\", varName);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyStructLogVar(var);\n    return(NULL);\n\n} /* end local_CreateStructLogVar */\n\n\n/* Function: rt_StartDataLoggingForOutput ======================================\n * Abstract:\n */\nstatic const char_T *rt_StartDataLoggingForOutput(RTWLogInfo   *li,\n                                                  const real_T startTime,\n                                                  const real_T finalTime,\n                                                  const real_T stepSize,\n                                                  const char_T **errStatus)\n{\n    const char_T   *varName;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    LogInfo *       logInfo;\n    logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    /* outputs */\n    varName = rtliGetLogY(li);\n    if (varName[0] != '\\0') {\n        int_T                  i;\n        int_T                  ny;\n        int_T                  yIdx;\n        char_T                 name[mxMAXNAM];\n        const char_T           *cp        = strchr(varName,',');\n        LogSignalPtrsType      ySigPtrs   = rtliGetLogYSignalPtrs(li);\n        const RTWLogSignalInfo *yInfo     = rtliGetLogYSignalInfo(li);\n\n        /* count the number of variables (matrices or structures) to create */\n        for (ny=1; cp != NULL; ny++) {\n            cp = strchr(cp+1,',');\n        }\n        logInfo->ny = ny;\n\n        if (logFormat==0) {\n            if ( (logInfo->y = calloc(ny,sizeof(LogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        } else {\n            if ( (logInfo->y = calloc(ny,sizeof(StructLogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        }\n\n        for (i = yIdx = 0, cp = varName; i < ny; i++) {\n            int_T        len;\n            const char_T *cp1 = strchr(cp+1,',');\n\n            if (cp1 != NULL) {\n                /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n                len = (int_T)(cp1 - cp);\n                if (len >= mxMAXNAM) len = mxMAXNAM - 1;\n            } else {\n                len = mxMAXNAM - 1;\n            }\n            (void)strncpy(name, cp, len);\n            name[len] = '\\0';\n\n            if (ny > 1 && ySigPtrs[i] == NULL) {\n                goto NEXT_NAME;\n            }\n\n            if (logFormat == 0) {\n                int            numCols;\n                int            nDims;\n                const int      *dims;\n                BuiltInDTypeId dataType;\n                int            isComplex;\n\n                if (ny == 1) {\n                    int_T op;\n\n                    numCols = yInfo[0].numCols[0];\n                    for (op = 1; op < yInfo[0].numSignals; op++) {\n                        numCols += yInfo[0].numCols[op];\n                    }\n                    /*\n                     * If we have only one \"matrix\" outport,\n                     * we can still log it as a matrix\n                     */\n                    if (yInfo[0].numSignals == 1) {\n                        nDims = yInfo[0].numDims ? yInfo[0].numDims[0] : 1;\n                        dims  = yInfo[0].dims;\n                    } else {\n                        nDims = 1;\n                        dims  = &numCols;\n                    }\n\n                    dataType  = yInfo[0].dataTypes[0];\n                    isComplex = yInfo[0].complexSignals[0];\n                } else {\n                    numCols   = yInfo[yIdx].numCols[0];\n                    nDims     = yInfo[yIdx].numDims ? yInfo[yIdx].numDims[0] : 1;\n                    dims      = yInfo[yIdx].dims;\n                    dataType  = yInfo[yIdx].dataTypes[0];\n                    isComplex = yInfo[yIdx].complexSignals[0];\n                }\n\n                logInfo->y[yIdx] = rt_CreateLogVarWithConvert(\n                    li, startTime, finalTime,\n                    stepSize, errStatus,\n                    name,\n                    dataType,\n                    yInfo[yIdx].dataTypeConvert,\n                    0,isComplex,\n                    0,numCols,nDims,dims,\n                    NO_LOGVALDIMS, NULL, NULL,\n                    maxRows,decimation,\n                    sampleTime,1);\n                if (logInfo->y[yIdx] == NULL)  goto ERROR_EXIT;\n            } else {\n                logInfo->y[yIdx] = local_CreateStructLogVar(li, startTime,\n                                                            finalTime, stepSize,\n                                                            errStatus, name,\n                                                            logTime, maxRows,\n                                                            decimation, sampleTime,\n                                                            &yInfo[yIdx], NULL);\n                if (logInfo->y[yIdx] == NULL) goto ERROR_EXIT;\n            }\n            ++yIdx;\n        NEXT_NAME:\n            cp = cp1;\n            if (cp != NULL && *cp == ',') cp++;\n        }\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) { /* polyspace DEFECT:USELESS_IF [No action planned:Unset] \n                     \"Defense coding.\" */\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingForOutput */\n\n\n/* Function: rt_ReallocLogVar ==================================================\n * Abstract:\n *   Allocate more memory for the data buffers in the log variable.\n *   Exit if unable to allocate more memory.\n */\nstatic void rt_ReallocLogVar(LogVar *var, boolean_T isVarDims)\n{\n    void *tmp;\n    int_T nCols = var->data.nCols;\n    int_T nRows;\n    size_t elSize = var->data.elSize;\n\n    if (isVarDims)\n    {\n        nRows = var->data.nRows + DEFAULT_BUFFER_SIZE;\n    }\n    else\n    {\n        nRows = var->data.nRows == 0 ? 1 : 2*var->data.nRows;\n    }\n    \n    tmp = realloc(var->data.re, nRows*nCols*elSize);\n    if (tmp == NULL) {\n        (void)fprintf(stderr,\n                      \"*** Memory allocation error.\\n\");\n        (void)fprintf(stderr, \"\"\n                      \"    varName          = %s%s\\n\"\n                      \"    nRows            = %d\\n\"\n                      \"    nCols            = %d\\n\"\n                      \"    elementSize      = %lu\\n\"\n                      \"    Current Size     = %.16g\\n\"\n                      \"    Failed resize    = %.16g\\n\\n\",\n                      var->data.name,\n                      var->data.complex ? \" (real part)\" : \"\",\n                      var->data.nRows,\n                      var->data.nCols,\n                      (unsigned long)  var->data.elSize,\n                      (double)nRows*nCols*elSize,\n                      (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n        exit(1);\n    }\n    var->data.re = tmp;\n\n    if (var->data.complex) {\n        tmp = realloc(var->data.im, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s (complex part)\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->data.name,\n                          var->data.nRows,\n                          var->data.nCols,\n                          (unsigned long)  var->data.elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n        var->data.im = tmp;\n    }\n    var->data.nRows = nRows;\n\n    /* Also reallocate memory for \"valueDimensions\" \n       when logging the variable-size signal\n    */\n    if(isVarDims){\n        int_T k;\n        \n        nCols = var->valDims->nCols;\n        nRows = var->valDims->nRows + DEFAULT_BUFFER_SIZE;\n        elSize = sizeof(real_T);\n        tmp = realloc(var->valDims->dimsData, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->valDims->name,\n                          var->valDims->nRows,\n                          var->valDims->nCols,\n                          (unsigned long)  elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n\n        /*\n         * valueDimensions data is stored in array format and must be\n         * adjusted after reallocation (see also rt_FixupLogVar())\n         *\n         * Example: maxRows = 4; nRows = 4; nDims = 3;\n         * Before realloc of the logVar, the locations of data are as below:\n         * (x, y, z -- useful data / o -- junk, don't care)\n         * a[0] = x    a[4] = y    a[8] = z\n         * a[1] = x    a[5] = y    a[9] = z\n         * a[2] = x    a[6] = y    a[10]= z\n         * a[3] = x    a[7] = y    a[11]= z\n         *\n         * After realloc of the logVar (suppose 2 extra rows are added),\n         * the locations of data are as below:\n         * a[0] = x    a[6] = y    a[12]= o\n         * a[1] = x    a[7] = y    a[13]= o\n         * a[2] = x    a[8] = z    a[14]= o\n         * a[3] = x    a[9] = z    a[15]= o\n         * a[4] = y    a[10]= z    a[16]= o\n         * a[5] = y    a[11]= z    a[17]= o\n         *\n         * The data must be adjusted as below:\n         * a[0] = x    a[6] = y    a[12]= z\n         * a[1] = x    a[7] = y    a[13]= z\n         * a[2] = x    a[8] = y    a[14]= z\n         * a[3] = x    a[9] = y    a[15]= z\n         * a[4] = o    a[10]= o    a[16]= o\n         * a[5] = o    a[11]= o    a[17]= o\n         */\n        for(k = var->data.nDims-1; k > 0; k--){\n            (void) memcpy((real_T*)tmp + k*nRows, \n                          (real_T*)tmp + k*var->valDims->nRows,\n                          elSize * var->valDims->nRows);\n        }\n\n        var->valDims->dimsData = tmp;\n        var->valDims->nRows = nRows;\n    }\n\n} /* end rt_ReallocLogVar */\n\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs);\n                                             \n/* Function: rt_UpdateLogVarWithDiscontinuousData ==============================\n * Abstract:\n *      Log one row of the LogVar with data that is not contiguous.\n */\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs)\n{\n    size_t elSize = 0;\n    size_t offset = 0;\n    int    segIdx = 0;\n\n    if (++var->numHits % var->decimation) return(NULL);\n    var->numHits = 0;\n\n    /*\n     * Reallocate or wrap the LogVar\n     */\n    if (var->rowIdx == var->data.nRows) {\n        if (var->okayToRealloc == 1) {\n            rt_ReallocLogVar(var, false);\n        } else {\n            /* Circular buffer */\n            var->rowIdx = 0;\n            ++(var->wrapped); /* increment the wrap around counter */\n        }\n    }\n\n    /* This function is only used to log states, there's no var-dims issue. */\n    elSize = var->data.elSize;\n    offset = (size_t)(elSize * var->rowIdx * var->data.nCols);\n\n    if (var->data.complex) {\n        char_T *dstRe = (char_T*)(var->data.re) + offset;\n        char_T *dstIm = (char_T*)(var->data.im) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            int_T         nEl  = segmentLengths[segIdx];\n            char_T *src        = (char_T *)data[segIdx];\n            int_T         el;\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(elSize * nEl * 2);\n                preprocessingPtr(src, (void *)data[segIdx]);\n            }\n\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);\n            }\n            else {\n                for (el = 0; el < nEl; el++) {\n                    (void)memcpy(dstRe, src, elSize);\n                    dstRe += elSize;   src += elSize;\n                    (void)memcpy(dstIm, src, elSize);\n                    dstIm += elSize;   src += elSize;\n                }\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    } else {\n        char_T *dst = (char_T*)(var->data.re) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            size_t      segSize = elSize*segmentLengths[segIdx];\n            char_T *src         = (void *) data[segIdx];\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(segSize);\n                preprocessingPtr(src, data[segIdx]);\n            }\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);            }\n            else {\n                (void)memcpy(dst, src, segSize);\n                dst += segSize;\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    }\n\n    ++var->rowIdx;\n    return(NULL);\n\n} /* end rt_UpdateLogVarWithDiscontinuousData */\n\n\n/*==================*\n * Visible routines *\n *==================*/\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_CreateLogVarWithConvert ========================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList)\n{\n    int_T          usingDefaultBufSize = 0;\n#ifdef NO_LOGGING_REALLOC\n    int_T          okayToRealloc       = 0;\n#else\n    int_T          okayToRealloc       = 1;\n#endif\n    LogVar         *var                = NULL;\n    /*inpDataTypeID is the rt_LoggedOutputDataTypeId*/\n    BuiltInDTypeId dTypeID             = (BuiltInDTypeId)inpDataTypeID; \n    size_t         elementSize         = rt_GetSizeofDataType(dTypeID);\n    int_T          frameSize;\n    int_T          nRows;\n    int_T          nColumns;\n\n    /*===================================================================*\n     * Determine the frame size if the data is frame based               *\n     *===================================================================*/\n    frameSize = frameData ? dims[0] : 1;\n\n    /*===================================================================*\n     * Calculate maximum number of rows needed in the buffer             *\n     *===================================================================*/\n\n    if (finalTime > startTime && finalTime != rtInf) {\n        real_T nPoints;            /* Tfinal is finite  ===>  nRows can be  */\n        real_T stepSize;           /* computed since the StepSize is fixed  */\n\n        if (sampleTime == -2.0) {  /* The signal being logged is constant,  *\n                                    * Hence, only one data point is logged. */\n            stepSize = finalTime;\n        } else if (sampleTime == -1.0 || sampleTime == 0.0) {\n                                /* Signal being logged is either inside a    *\n                                 * triggered sub-system or it is continuous. */\n            stepSize = inStepSize;\n        } else {                /* Discrete signal */\n            stepSize = sampleTime;\n        }\n\n        if (stepSize == 0.0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {\n            nPoints = 1.0 + floor((finalTime-startTime)/stepSize);\n\n            /*\n             * Add one more data point if needed.\n             */\n            if ( stepSize*(nPoints-1.0) < (finalTime-startTime) ) {\n                nPoints += 1.0;\n            }\n\n            /*\n             * Actual number of points to log = nPoints * size of\n             * each frame if data is frame-based\n             */\n            nPoints = frameData ? (nPoints * frameSize) : nPoints;\n\n            nPoints /= decimation;\n            if (nPoints != floor(nPoints)) {\n                nPoints += 1.0;\n            }\n            nRows = (nPoints <= INT_MAX) ? ((int_T) nPoints) : INT_MAX;\n        }\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (finalTime == startTime) {\n        /*\n         * Number of rows to log is equal to 1 if not frame-based and\n         * equal to frame size if frame-based\n         */\n        nRows = frameData ? frameSize : 1;\n\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (maxRows > 0) {     /* maxRows is specified => nRows=maxRows  */\n        nRows = maxRows;\n        okayToRealloc = 0;\n    } else {\n\n        if (inStepSize == 0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {                    /* Use a default value for nRows          */\n            usingDefaultBufSize = 1;\n            nRows = DEFAULT_BUFFER_SIZE;\n            okayToRealloc = 0;  /* No realloc with infinite stop time */\n            (void)fprintf(stdout, \"*** Using a default buffer of size %d for \"\n                          \"logging variable %s\\n\", nRows, varName);\n        }\n    }\n\n    /*\n     * Figure out the number of columns that the log variable should have.\n     * If the data is not frame based, then number of columns should equal\n     * nCols that is provided as input to the function. If the data is\n     * frame-based, then the number of columns should be equal to the\n     * number of channels = nCols/frameSize = dims[1];\n     */\n    nColumns = frameData ? dims[1] : nCols;\n\n    /*\n     * Error out if the size of the circular buffer is absurdly large, this\n     * error message is more informative than the one we get when we try to\n     * malloc this many number of bytes in one fell swoop.\n     */\n    {\n        double tmpDbl = ((double)elementSize)*((double)nRows)*\n                                              ((double)nColumns);\n\n        if (tmpDbl >= UINT_MAX) {\n            (void)fprintf(stderr,\n                          \"\\n*** Memory required to log variable '%s' is too\"\n                          \"\\n    big. Use the 'Limit rows to last:' and (or)\"\n                          \"\\n    'Decimation:' options to reduce the required\"\n                          \"\\n    memory size.\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Required  = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long)\n                          elementSize, tmpDbl);\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* Allocate memory for the log variable */\n    if ( (var = calloc(1, sizeof(LogVar))) == NULL ) {\n        (void)fprintf(stderr, \"*** Error allocating memory for logging %s\\n\",\n                      varName);\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer (real part) */\n    if ( (var->data.re = malloc(nRows*nColumns*elementSize)) == NULL ) {\n        (void)fprintf(stderr,\n                      \"*** Error allocating memory for the circular buffer\\n\");\n        (void)fprintf(stderr, \"*** Details:\\n\"\n                      \"       varName         = %s\\n\"\n                      \"       nRows           = %d\\n\"\n                      \"       nCols           = %d\\n\"\n                      \"       elementSize     = %lu\\n\"\n                      \"       Bytes Requested = %.16g\\n\\n\",\n                      varName, nRows, nColumns, (unsigned long) elementSize,\n                      ((double)elementSize)*((double)nRows)*((double)nColumns));\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer for the imaginary part */\n    if (complex) {\n        if ( (var->data.im = malloc(nRows*nColumns*elementSize)) == NULL ) {\n            (void)fprintf(stderr,\n                          \"*** Error allocating memory for the circular buffer \"\n                          \"for logging the imaginary part of %s\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Requested = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long) elementSize,\n                          ((double)elementSize)*((double)nRows)*\n                                                 ((double)nColumns));\n            goto ERROR_EXIT;\n        }\n    }\n    /*\n     * Initialize the fields in LogVar structure.\n     */\n    if (appendToLogVarsList) {\n        rt_LoadModifiedLogVarName(li,varName,var->data.name);\n    } else {\n        var->data.name[mxMAXNAM-1] = '\\0';\n        (void)strncpy(var->data.name,varName,mxMAXNAM-1);\n    }\n    var->data.nCols           = nColumns;\n    var->data.nRows           = nRows;\n\n    var->data.nDims           = frameData ? 1 : nDims;\n    if (var->data.nDims > 2) {\n        var->data.dims = (int_T*)malloc(sizeof(int_T)*var->data.nDims);\n    } else {\n        var->data.dims = var->data._dims;\n    }\n    if (frameData) {\n        var->data.dims[0] = nColumns;\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        (void)memcpy(var->data.dims, dims, (size_t)(nDims*sizeof(int_T)));\n    }\n\n    var->data.dTypeID         = dTypeID;\n    var->data.elSize          = elementSize;\n\n    var->data.dataTypeConvertInfo = rt_GetDataTypeConvertInfo(\n        pDataTypeConvertInfo, dTypeID);\n\n    var->data.mxID            = rt_GetMxIdFromDTypeId(dTypeID);\n    /* over-ride logical bit if data type is boolean */\n    logical = dTypeID == SS_BOOLEAN ? 1 : 0;\n    var->data.logical         = (logical)   ? matLOGICAL_BIT : 0x0;\n    var->data.complex         = (complex)   ? matCOMPLEX_BIT : 0x0;\n    var->data.frameData       = frameData;\n    var->data.frameSize       = (frameData) ? frameSize : 1;\n\n    /* fill up valDims field */\n    if(logValDimsStat == NO_LOGVALDIMS){\n        /* All signals are fixed-size, no need to log valueDimensions field */\n        var->valDims     = NULL;\n        /* Set these pointers to NULLs in this case */\n        var->coords      = NULL;\n        var->strides     = NULL;\n        var->currStrides = NULL;\n    }\n    else{\n        if ( (var->valDims = calloc(1, sizeof(ValDimsData))) == NULL ) {\n            goto ERROR_EXIT;\n        }\n\n        (void)memcpy(var->valDims->name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n\n        if (logValDimsStat == LOGVALDIMS_EMPTYMX) {\n            /* At least one signal is variable-size, \n               but the current signal is fixed-size. \n               Therefore, create a dummy MatrixData to write out valueDimensions \n               as an empty matrix. \n            */\n            var->valDims->nRows = 0;\n            var->valDims->nCols = 0;\n            var->valDims->currSigDims = NULL;\n            var->valDims->currSigDimsSize = NULL;\n            var->valDims->dimsData = NULL;\n            /* Set these pointers to NULLs in this case */\n            var->coords      = NULL;\n            var->strides     = NULL;\n            var->currStrides = NULL;\n        } else { /* The current signal is a variable-size signal. */\n            /* The \"valueDimensions\" must be double, so re-assign element size */\n            elementSize = sizeof(real_T);\n\n            /* When signals are frame-based, 'valueDimensions' has 1 column */\n            if(frameData){\n                /* When signal is frame-based, the first dimension is always fixed, \n                   so we only need to record the second dimension.\n                   e.g. Two frame-based signals [10x4] and [10x3], \n                   'valueDimensions' and 'currSigDims'\n                   only record 4 or 3.\n                */\n                nColumns = 1;\n                var->valDims->currSigDims = (void**) (currSigDims + 1);\n                var->valDims->currSigDimsSize = (int_T*) (currSigDimsSize + 1);\n            } else { /* non-frame based */\n                nColumns = nDims;\n                var->valDims->currSigDims = (void**) currSigDims;\n                var->valDims->currSigDimsSize = (int_T*) currSigDimsSize;\n            }\n            \n            /* Allocate memory for the circular buffer */\n            if ( (var->valDims->dimsData = malloc(nRows*nColumns*elementSize)) == NULL ) {\n                (void)fprintf(stderr,\n                              \"*** Error allocating memory for the circular buffer\\n\");\n                (void)fprintf(stderr, \"*** Details:\\n\"\n                              \"       varName         = %s\\n\"\n                              \"       nRows           = %d\\n\"\n                              \"       nCols           = %d\\n\"\n                              \"       elementSize     = %lu\\n\"\n                              \"       Bytes Requested = %.16g\\n\\n\",\n                              var->valDims->name, nRows, nColumns, (unsigned long) elementSize,\n                              ((double)elementSize)*((double)nRows)*((double)nColumns));\n                goto ERROR_EXIT;\n            }\n            var->valDims->nRows = nRows;\n            var->valDims->nCols = nColumns;\n\n            /* Allocate memory for these dynamic arrays */\n            {\n                size_t nbytes = var->data.nDims*sizeof(int_T);\n                if( ((var->coords = calloc(nbytes, 1)) == NULL)\n                    ||((var->strides = calloc(nbytes, 1)) == NULL)\n                    ||((var->currStrides = calloc(nbytes, 1)) == NULL) )\n                    goto ERROR_EXIT;\n            }\n        }\n    }\n\n    var->rowIdx               = 0;\n    var->wrapped              = 0;\n    var->nDataPoints          = 0;\n    var->usingDefaultBufSize  = usingDefaultBufSize;\n    var->okayToRealloc        = okayToRealloc;\n    var->decimation           = decimation;\n    var->numHits              = -1;  /* so first point gets logged */\n\n    /* Add this log var to list in log info, if necessary */\n    if (appendToLogVarsList) {\n        LogInfo *logInfo = (LogInfo*) rtliGetLogInfo(li);\n        LogVar  *varList = logInfo->logVarsList;\n\n        if (varList != NULL) {\n            while (varList->next != NULL) {\n                varList = varList->next;\n            }\n            varList->next = var;\n        } else {\n            logInfo->logVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    \n    *errStatus = rtMemAllocError;\n    rt_DestroyLogVar(var);\n    return(NULL);\n\n} /* end rt_CreateLogVarWithConvert */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVar ===================================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList)\n{\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo = NULL;\n\n    return rt_CreateLogVarWithConvert(li,\n                                      startTime,\n                                      finalTime,\n                                      inStepSize,\n                                      errStatus,\n                                      varName,\n                                      inpDataTypeID,\n                                      pDataTypeConvertInfo,\n                                      logical,\n                                      complex,\n                                      frameData,\n                                      nCols,\n                                      nDims,\n                                      dims,\n                                      logValDimsStat,\n                                      currSigDims,\n                                      currSigDimsSize,\n                                      maxRows,\n                                      decimation,\n                                      sampleTime,\n                                      appendToLogVarsList);\n\n} /* end rt_CreateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateStructLogVar =============================================\n * Abstract:\n *\tCreate a logging variable in the structure format.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nStructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName)\n{\n\n    return( local_CreateStructLogVar(li,\n                                     startTime,\n                                     finalTime,\n                                     inStepSize,\n                                     errStatus,\n                                     varName,\n                                     logTime,\n                                     maxRows,\n                                     decimation,\n                                     sampleTime,\n                                     sigInfo,\n                                     blockName));\n\n} /* end rt_CreateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_StartDataLoggingWithStartTime ==================================\n * Abstract:\n *      Initialize data logging info based upon the following settings cached\n *      in the RTWLogging data structure of the SimStruct.\n *\n * Return value is:\n *\t== NULL  => success\n *\t!= NULL  => failure (the return value is a pointer that points to the\n *                           error message, which is also set in the simstruct)\n */\nconst char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus)\n{\n    const char_T   *varName;\n    LogInfo        *logInfo;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ((logInfo=calloc(1,sizeof(LogInfo))) == NULL) {\n        *errStatus = rtMemAllocError;\n        goto ERROR_EXIT;\n    }\n    rtliSetLogInfo(li, (void*)logInfo);\n\n    /* time */\n    varName = rtliGetLogT(li);\n    if (varName[0] != '\\0') {\n        int_T dims = 1;\n        logInfo->t = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                stepSize, errStatus,\n                                                varName,SS_DOUBLE,\n                                                NULL,\n                                                0,0,0,1,1,\n                                                &dims, NO_LOGVALDIMS, NULL, NULL,\n                                                maxRows,decimation,\n                                                sampleTime,1);\n        if (logInfo->t == NULL) goto ERROR_EXIT;\n    }\n\n    /* states */\n    if ( rtliGetLogX(li)[0] != '\\0' ||  rtliGetLogXFinal(li)[0] != '\\0' ) {\n        const RTWLogSignalInfo  *xInfo = rtliGetLogXSignalInfo(li);\n\n        if (logFormat == 0) {                                /* Matrix Format */\n            int            numCols;\n            int            nDims;\n            const int      *dims;\n            BuiltInDTypeId dataType;\n            int            isComplex;\n            int_T          sIdx;\n\n            const RTWLogDataTypeConvert *pDTConvInfo;\n\n            numCols = xInfo[0].numCols ? xInfo[0].numCols[0] : 0;\n            for (sIdx = 1; sIdx < xInfo[0].numSignals; sIdx++) {\n                numCols += xInfo[0].numCols[sIdx];\n            }\n            /* If we have only one \"matrix\" state, we can log as a matrix */\n            if (xInfo[0].numSignals == 1) {\n                nDims     = xInfo[0].numDims ? xInfo[0].numDims[0] : 1;\n                dims      = xInfo[0].dims;\n            } else {\n                nDims     = 1;\n                dims      = &numCols;\n            }\n            dataType  = xInfo[0].dataTypes ? xInfo[0].dataTypes[0] : 0;\n            isComplex = xInfo[0].complexSignals ? xInfo[0].complexSignals[0] : 0;\n\n            pDTConvInfo = xInfo[0].dataTypeConvert;\n\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                        stepSize, errStatus,\n                                                        rtliGetLogX(li),dataType,\n                                                        pDTConvInfo,\n                                                        0,\n                                                        isComplex,0,numCols,nDims,dims,\n                                                        NO_LOGVALDIMS, NULL, NULL,\n                                                        maxRows,decimation,sampleTime,1);\n                if (logInfo->x == NULL)  goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                             stepSize, errStatus,\n                                                             rtliGetLogXFinal(li),dataType,\n                                                             pDTConvInfo,\n                                                             0,isComplex,0,numCols,nDims,\n                                                             dims, NO_LOGVALDIMS, NULL, \n                                                             NULL, 1,decimation,\n                                                             sampleTime,1);\n                if (logInfo->xFinal == NULL)  goto ERROR_EXIT;\n            }\n        } else {                                          /* Structure Format */\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = local_CreateStructLogVar(li, startTime, finalTime,\n                                                      stepSize, errStatus,\n                                                      rtliGetLogX(li), logTime,\n                                                      maxRows, decimation,\n                                                      sampleTime, xInfo, NULL);\n                if (logInfo->x == NULL) goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = local_CreateStructLogVar(li, startTime, finalTime,\n                                                           stepSize, errStatus,\n                                                           rtliGetLogXFinal(li),\n                                                           logTime,1,decimation,\n                                                           sampleTime,xInfo,NULL);\n                if (logInfo->xFinal == NULL) goto ERROR_EXIT;\n            }\n        }\n    }\n\n    /* outputs */\n    *errStatus = rt_StartDataLoggingForOutput(li,startTime,finalTime,\n                                              stepSize,errStatus);\n    if (*errStatus != NULL)  goto ERROR_EXIT;\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingWithStartTime */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLogging ===============================================\n * Abstract:\n */\nconst char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus)\n{\n    return rt_StartDataLoggingWithStartTime(li,\n                                            0.0,\n                                            finalTime,\n                                            stepSize,\n                                            errStatus);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_UpdateLogVar ===================================================\n * Abstract:\n *\tCalled to log data for a log variable.\n */\nvoid rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims)\n{\n    size_t        elSize    = var->data.elSize;\n    const  char_T *cData    = data;\n    const  int_T  frameData = var->data.frameData;\n    const  int_T  frameSize = frameData ? (var->data.frameSize) : 1;\n    const  int_T  logWidth  = var->data.nCols;\n    BuiltInDTypeId dTypeID  = var->data.dTypeID;\n\n    size_t offset        = 0;\n    char_T *currRealRow  = NULL;\n    char_T *currImagRow  = NULL;\n    int_T  pointSize     = (int_T)((var->data.complex) ? rt_GetSizeofComplexType(dTypeID) : elSize);\n\n    int    i, j, k;\n\n    /* The following variables will be used for \n       logging variable-size signals */\n    const  int_T  nDims = var->data.nDims;\n    const  int_T  *dims = var->data.dims;\n    const  void   * const *currDimsPtr = NULL;\n    const  int_T  *currDimsSizePtr = NULL;\n\n    /* The following variables will be used for \n       logging \"valueDimensions\" field */\n    size_t offset_valDims   = 0;\n    char_T *currValDimsRow  = NULL;\n    size_t elSize_valDims   = sizeof(real_T);\n    real_T currentSigDims   = 0;\n    int_T  nRows_valDims    = 0;\n    int_T  logWidth_valDims = 0;\n\n    for (i = 0; i < frameSize; i++) {\n        if (++var->numHits % var->decimation) continue;\n        var->numHits = 0;\n\n        if (var->rowIdx == var->data.nRows) {\n            if (var->okayToRealloc == 1) {\n                rt_ReallocLogVar(var, isVarDims);\n            } else {\n                /* Circular buffer */\n                var->rowIdx = 0;\n                ++(var->wrapped); /* increment the wrap around counter */\n            }\n        }\n\n        if(isVarDims){\n            currDimsPtr = (const void * const *) var->valDims->currSigDims;\n            currDimsSizePtr = (const int_T*) var->valDims->currSigDimsSize;\n            logWidth_valDims = frameData ? 1 : var->valDims->nCols;\n            nRows_valDims = var->valDims->nRows;\n\n            var->strides[0] = 1;\n            var->currStrides[0] = 1;\n\n            for (k = 1; k < nDims; k++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[k-1]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                }\n                var->strides[k] = var->strides[k-1] * dims[k-1];\n                var->currStrides[k] = var->currStrides[k-1] * currDimsVal;\n            }\n        }\n\n        offset       = (size_t)(elSize * var->rowIdx * logWidth);\n        currRealRow  = ((char_T*) (var->data.re)) + offset;\n        currImagRow  = (var->data.complex) ?\n                       ((char_T*) (var->data.im)) + offset :  NULL;\n\n        /* update logging data */\n        for (j = 0; j < logWidth; j++) {\n\n            boolean_T inRange = true;\n            int idx = j;\n\n            /* Check whether the currently logged value is in range or not.\n               For fixed-size signal logging, always inRange = true; idx = j;\n               For variable-size signal logging, use strides, coordinates\n               and current strides to decide whether the currently logged\n               data is in range or not and its location in the logging \n               matrix.\n             */\n            if(isVarDims){\n                int rem = j;\n                idx = 0;\n                for(k = nDims-1; k>=0; k--){\n                    int32_T currDimsVal=0;\n                    switch (currDimsSizePtr[k]) {\n                      case 1:\n                        currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+k));\n                        break;\n                      case 2:\n                        currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+k));\n                        break;\n                      case 4:\n                        currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+k));\n                        break;\n                    }\n                    var->coords[k] = rem / var->strides[k];\n                    if( var->coords[k] >= currDimsVal ){\n                        inRange = false;\n                        break;\n                    }\n                    rem = rem - var->coords[k] * var->strides[k];\n                }\n                if(inRange){\n                    idx = var->coords[0];\n                    for (k = 1; k < nDims; k++){\n                        idx += var->coords[k] * var->currStrides[k];\n                    }\n                }\n            }\n            \n            if (!var->data.dataTypeConvertInfo.conversionNeeded) {\n                /* NO  conversion needed\n                 */ \n                if (inRange) {\n                    /* If in range, fill in data */\n                    const char *cDataPoint = cData + (i+frameSize*idx) * pointSize;\n\n                    (void) memcpy(currRealRow, cDataPoint, elSize);\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        (void) memcpy(currImagRow, cDataPoint + pointSize/2, elSize);\n                        currImagRow += elSize;\n                    }\n                } else {\n                    /* If out of range, fill in NaN or 0:\n                       1) For bool, int32, uint32, int16, uint16, etc,\n                          memset to zeros;\n                       2) For fixed-point data type, NaN conversion is not\n                          allowed, memset to zeros.\n                    */\n                    if (dTypeID == SS_DOUBLE) {\n                       ((real_T*)(currRealRow))[0] = rtNaN;\n                    } else if (dTypeID == SS_SINGLE){\n                        ((real32_T*)(currRealRow))[0] = rtNaNF;\n                    } else {\n                        (void) memset(currRealRow, 0, elSize);\n                    }\n                    \n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        /* For imaginary part, fill in 0 */\n                        (void) memset(currImagRow, 0, elSize);\n                        currImagRow += elSize;\n                    }\n                }\n            }\n            else\n            {\n                /* YES conversion needed\n                 */ \n                DTypeId dataTypeIdOriginal = \n                    var->data.dataTypeConvertInfo.dataTypeIdOriginal;\n                int_T DpSize = (int_T)((var->data.complex) ? \n                                       rt_GetSizeofComplexType(dataTypeIdOriginal) : \n                                       rt_GetSizeofDataType(dataTypeIdOriginal));\n\n                DTypeId dataTypeIdLoggingTo = \n                    var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;\n\n                int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;\n                int numOfChunk =  var->data.dataTypeConvertInfo.numOfChunk;\n                unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;\n\n                double fracSlope = var->data.dataTypeConvertInfo.fracSlope;\n                int    fixedExp  = var->data.dataTypeConvertInfo.fixedExp;\n                double bias      = var->data.dataTypeConvertInfo.bias;\n\n                double curRealValue = -0.12345678987654;\n                double curImagValue = -0.12345678987654;\n\n                int_T adjIndexIfComplex = (var->data.complex) ? 2 : 1;\n\n                if(inRange){\n                    if(numOfChunk > 1)\n                    {\n                        /* For multiword */\n                        const char *pInData = (const char *)(cData);\n                        int dtSize = bitsPerChunk*numOfChunk/8;\n                        pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                        \n                        curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                       isSigned, fracSlope, fixedExp, bias);\n                        if (var->data.complex) {\n                            curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                           isSigned, fracSlope, fixedExp, bias);\n                        }\n                    }\n                    else\n                    {\n                        /* if in range, fill in data that is converted first */\n                        switch ( dataTypeIdOriginal )\n                        {\n                          case SS_DOUBLE:\n                            {\n                                const real_T *pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_SINGLE:\n                            {\n                                const real32_T *pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT8:\n                            {\n                                const int8_T *pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT8:\n                            {\n                                const uint8_T *pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT16:\n                            {\n                                const int16_T *pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT16:\n                            {\n                                const uint16_T *pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT32:\n                            {\n                                const int32_T *pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT32:\n                            {\n                                const uint32_T *pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_BOOLEAN:\n                            {\n                                const boolean_T *pInData = ((const boolean_T *)(cData));\n                                \n                                pInData += (i+frameSize*idx) * adjIndexIfComplex;\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          default: \n                            {\n                                /* For biglong */\n                                const char *pInData = (const char *)(cData);\n                                int dtSize = bitsPerChunk*numOfChunk/8;\n                                pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                                \n                                curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                               isSigned, fracSlope, fixedExp, bias);\n                                if (var->data.complex) {\n                                    curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                                   isSigned, fracSlope, fixedExp, bias);\n                                }\n                            }\n                            break;\n                        } /* -- end of switch -- */\n                    }\n                } else {\n                    /* if out of range, just fill NaN or 0 */\n                    if(dTypeID == SS_DOUBLE || dTypeID == SS_SINGLE){\n                        /* vijay 4/11/2013: DO NOT CALL ldexp() with NaN below as it causes \n                         * lcc-win64 to generate inf instead of NaN as output. \n                         * Just use rtNaN directly */\n                        curRealValue = rtNaN;\n                    }\n                    else{\n                        curRealValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                    if (var->data.complex) {\n                        /* fill 0 in imaginary part*/\n                        curImagValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                }\n\n                switch ( dataTypeIdLoggingTo )\n                {\n                  case SS_DOUBLE:\n                    {\n                        *((real_T *)currRealRow) = (real_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real_T *)currImagRow) = (real_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_SINGLE:\n                    {\n                        *((real32_T *)currRealRow) = (real32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real32_T *)currImagRow) = (real32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT8:\n                    {\n                        *((int8_T *)currRealRow) = (int8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int8_T *)currImagRow) = (int8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT8:\n                    {\n                        *((uint8_T *)currRealRow) = (uint8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint8_T *)currImagRow) = (uint8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT16:\n                    {\n                        *((int16_T *)currRealRow) = (int16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int16_T *)currImagRow) = (int16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT16:\n                    {\n                        *((uint16_T *)currRealRow) = (uint16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint16_T *)currImagRow) = (uint16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT32:\n                    {\n                        *((int32_T *)currRealRow) = (int32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int32_T *)currImagRow) = (int32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT32:\n                    {\n                        *((uint32_T *)currRealRow) = (uint32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint32_T *)currImagRow) = (uint32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_BOOLEAN:\n                    {\n                        *((boolean_T *)currRealRow) = (boolean_T)(curRealValue != 0.0);\n\n                        if (var->data.complex) {\n\n                            *((boolean_T *)currImagRow) = (boolean_T)(curImagValue != 0.0);\n                        }\n                    }\n                    break;\n                } /* -- end of switch -- */\n\n                currRealRow += elSize;\n                if (var->data.complex) {\n                    currImagRow += elSize;\n                }\n            }\n        }\n\n        if(isVarDims){ /* update \"valueDimensions\" field */\n            for(j = 0; j < logWidth_valDims; j ++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[j]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+j));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+j));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+j));\n                    break;\n                }\n                offset_valDims  = (size_t)(elSize_valDims *( var->rowIdx + nRows_valDims * j));\n                currValDimsRow  = ((char_T*) (var->valDims->dimsData)) + offset_valDims;\n\n                /* convert int_T to real_T */\n                currentSigDims = (real_T) currDimsVal;\n                (void) memcpy(currValDimsRow, &currentSigDims, elSize_valDims);\n                currValDimsRow += elSize_valDims;\n            }\n        }\n        \n        ++var->rowIdx;\n    }\n\n    return;\n\n} /* end rt_UpdateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n \n \n/* Function: rt_UpdateStructLogVar =============================================\n * Abstract:\n *      Called to log data for a structure log variable.\n */\nvoid rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data)\n{\n    LogVar       *values = var->signals.values;\n    const char_T *signal = data;\n    boolean_T *isVarDims = var->signals.isVarDims;\n    int i = 0;\n\n    /* time */\n    if (var->logTime) {\n        rt_UpdateLogVar(var->time, t, false);\n    }\n\n    /* signals */\n    while (values) {\n        size_t elSz = values->data.elSize;\n\n        rt_UpdateLogVar(values, signal, isVarDims[i]);\n\n        if (values->data.complex) elSz *= 2;\n        signal += elSz * values->data.nCols;\n\n        values = values->next;\n        i++;\n    }\n\n} /* end rt_UpdateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * g1614989:Refactoring this function to accept number of elements\n *          instead of accepting signalInfo and index.\n */\nvoid* rt_getTempMemory(LogVar* var, int_T numEls);\n\nvoid* rt_getTempMemory(LogVar* var, int_T numEls)\n{\n    size_t elSize  = var->data.elSize;\n    size_t cmplxMult = var->data.complex ? 2 : 1;\n    /*\n     * g1689750: With multiword support for mat file logging in row major array layout, we need to allocate more space to\n     * store the data when the transpose operation is being performed. The additional space is required to store multiple\n     * chunks that each multi word contains.\n     */\n    size_t numOfChunks = var->data.dataTypeConvertInfo.conversionNeeded ? var->data.dataTypeConvertInfo.numOfChunk : 1;\n    void* tempMemory = malloc(elSize * numEls * cmplxMult * numOfChunks);\n    return tempMemory;\n}\n\n/*\n* g1614989:This function processes the signal data if a function pointer is available and then logs the data.\n*          If a function pointer is not present, signal data is logged without any processing.\n*          The idx parameter specifies which information from the SignalInfo to be used for processing and logging.\n*          When idx is -1, the provided signal info is to be used for processing and logging the data.\n*/\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    RTWPreprocessingFcnPtr preprocessingPtr = NULL;\n    int_T numEls = -1;\n    if (idx == -1) {\n        preprocessingPtr = *(signalInfo->preprocessingPtrs);\n        numEls = *(signalInfo->numCols);\n    }\n    else {\n        preprocessingPtr = signalInfo->preprocessingPtrs[idx];\n        numEls = signalInfo->numCols[idx];\n    }\n\n    if (preprocessingPtr != NULL) {\n        void* curData = rt_getTempMemory(val, numEls);\n        preprocessingPtr(curData, data);\n        rt_UpdateLogVar(val, curData, isVarDims);\n        free(curData);\n    }\n    else {\n        rt_UpdateLogVar(val, data, isVarDims);\n    }\n}\n\n/*\n* g1614989:This function is called when each signal has a specific RTWLogSignalInfo structure defined.\n*/\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    rt_preProcessAndLogDataWithIndex(&signalInfo, -1, val, data, isVarDims);\n}\n \n/* Function: rt_UpdateTXYLogVars ===============================================\n * Abstract:\n *\tUpdate the xFinal,T,X,Y variables that are being logged.\n */\nconst char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr)\n{\n    return rt_UpdateTXXFYLogVars(li, tPtr, true);\n}\n \n/* Function: rt_UpdateTXXFYLogVars =============================================\n * Abstract:\n *\tUpdate xFinal and/or the T,X,Y variables that are being logged\n */\nconst char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY)\n{\n    LogInfo *logInfo     = rtliGetLogInfo(li);\n    int_T   matrixFormat = (rtliGetLogFormat(li) == 0);\n    const RTWLogSignalInfo* yInfo = rtliGetLogYSignalInfo(li);\n    const RTWLogSignalInfo* xInfo = rtliGetLogXSignalInfo(li);\n\n    /* time */\n    if (logInfo->t != NULL && updateTXY) {\n        rt_UpdateLogVar(logInfo->t, tPtr, false);\n    }\n\n    if (matrixFormat) {                                      /* MATRIX_FORMAT */\n        /* states */\n        if (logInfo->x != NULL || logInfo->xFinal != NULL) {\n            int8_T**               segAddr     = _rtliGetLogXSignalPtrs(li);\n            const int_T            *segLengths = xInfo->numCols;\n            int_T                  nSegments   = xInfo->numSignals;\n            RTWPreprocessingFcnPtr* preprocessingPtrs = xInfo->preprocessingPtrs;\n\n            if (logInfo->x != NULL && updateTXY) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->x, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n            if (logInfo->xFinal != NULL) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->xFinal, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n        }\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            LogVar **var = (LogVar**) (logInfo->y);\n            int_T  ny    = logInfo->ny;\n            int_T  i;\n            int    yIdx;\n            LogSignalPtrsType data = rtliGetLogYSignalPtrs(li);\n\n            for (i = 0, yIdx = 0; i < ny; i++) {\n                if (data[i] != NULL) {\n                    /* \n                       When outputs are logged in Matrix format, \n                       no variable-size signal logging is allowed.\n                    */\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *          Function pointer is now identified by using \n                     *          Y Signal Info instead of iterating over pre-processing \n                     *          function pointers.\n                    */ \n                    rt_preProcessAndLogData(yInfo[yIdx], var[yIdx], data[i], false);\n                    yIdx++;\n                }\n            }\n        }\n    } else {                                              /* STRUCTURE_FORMAT */\n        /* states */\n        if (logInfo->x != NULL && updateTXY) {\n            int_T             i;\n            StructLogVar      *var = logInfo->x;\n            LogVar            *val = var->signals.values;\n            int_T             nsig = var->signals.numSignals;\n            LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n\n            /* time */\n            if (var->logTime) {\n                rt_UpdateLogVar(var->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            int_T             ny      = logInfo->ny;\n            LogSignalPtrsType data    = rtliGetLogYSignalPtrs(li);\n            StructLogVar      **var   = (StructLogVar**) (logInfo->y);\n\n            if (ny == 1) {\n                int_T  i;\n                int_T  dataIdx;\n                LogVar *val = var[0]->signals.values;\n                int_T  nsig = var[0]->signals.numSignals;\n                boolean_T   *isVarDims = var[0]->signals.isVarDims;\n\n                /* time */\n                if (var[0]->logTime) {\n                    rt_UpdateLogVar(var[0]->time, tPtr, false);\n                }\n\n                /* signals */\n                for (i = 0, dataIdx = 0; i < nsig; i++) {                    \n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogDataWithIndex(yInfo, i, val, data[dataIdx], isVarDims[i]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            } else {\n                int_T  i;\n                int_T  dataIdx;\n\n                for (i = 0, dataIdx = 0; i < ny && var[i] != NULL; i++) {\n                    LogVar *val = var[i]->signals.values;\n                    boolean_T   *isVarDims = var[i]->signals.isVarDims;\n\n                    /* time */\n                    if (var[i]->logTime) {\n                        rt_UpdateLogVar(var[i]->time, tPtr, false);\n                    }\n\n                    /* signals */\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogData(yInfo[i], val, data[dataIdx], isVarDims[0]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            }\n        }\n        /* final state */\n        if (logInfo->xFinal != NULL) {\n            StructLogVar *xf  = logInfo->xFinal;\n            LogVar       *val = xf->signals.values;\n            int_T        nsig = xf->signals.numSignals;\n            int_T        i;\n\n            /* time */\n            if (xf->logTime) {\n                rt_UpdateLogVar(xf->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n    }\n    return(NULL);\n} /* end rt_UpdateTXXFYLogVars */\n\n\n#ifdef __cplusplus\n}\n#endif\n          \n\n          \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLoggingImpl =======================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel)\n{\n    FILE          *fptr;\n    LogInfo       *logInfo     = (LogInfo*) rtliGetLogInfo(li);\n    LogVar        *var         = logInfo->logVarsList;\n    StructLogVar  *svar        = logInfo->structLogVarsList;\n    /* At this time, verbose is only needed if running rapid accelerator\n     * simulations. */\n    int           verbose      = isRaccel ? 0: 1;\n\n    boolean_T     emptyFile    = 1; /* assume */\n    boolean_T     errFlag      = 0;\n    const char_T  *msg;\n\n    /*******************************\n     * Create MAT file with header *\n     *******************************/\n    if ((fptr=fopen(file,\"w+b\")) == NULL) {\n        (void)fprintf(stderr,\"*** Error opening %s\",file);\n        goto EXIT_POINT;\n    }\n    if (rt_WriteMat5FileHeader(fptr)) {\n        (void)fprintf(stderr,\"*** Error writing to %s\",file);\n        goto EXIT_POINT;\n    }\n\n    /**************************************************\n     * First log all the variables in the LogVar list *\n     **************************************************/\n    while (var != NULL) {\n        if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n            (void)fprintf(stderr,\"*** Error writing %s due to: %s\\n\",file,msg);\n            errFlag = 1;\n            break;\n        }\n        if (var->nDataPoints > 0 || isRaccel) {\n            MatItem item;\n\n            item.type   = matMATRIX;\n            item.nbytes = 0; /* not yet known */\n            item.data   = &(var->data);\n            if (rt_WriteItemToMatFile(fptr, &item, MATRIX_ITEM)) {\n                (void)fprintf(stderr,\"*** Error writing log variable %s to \"\n                              \"file %s\",var->data.name, file);\n                errFlag = 1;\n                break;\n            }\n            emptyFile = 0;\n        }\n        var = var->next;\n    }\n    /* free up some memory by destroying the log var list here */\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n\n    /*******************************************************\n     * Next log all the variables in the StructLogVar list *\n     *******************************************************/\n    while (svar != NULL) {\n        MatItem item;\n\n        if (svar->logTime) {\n            var = svar->time;\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n        }\n\n        var = svar->signals.values;\n        while (var) {\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n            var = var->next;\n        }\n\n        item.type   = matMATRIX;\n        item.nbytes = 0; /* not yet known */\n        item.data   = svar;\n\n        if (rt_WriteItemToMatFile(fptr, &item, STRUCT_LOG_VAR_ITEM)) {\n            (void)fprintf(stderr,\"*** Error writing structure log variable \"\n                          \"%s to file %s\",svar->name, file);\n            errFlag = 1;\n            break;\n        }\n        emptyFile = 0;\n\n        svar = svar->next;\n    }\n\n    /******************\n     * Close the file *\n     ******************/\n    (void)fclose(fptr);\n    if (emptyFile || errFlag) {\n        (void)remove(file);\n    } else {\n        if( verbose ) {\n            (void)printf(\"** created %s **\\n\\n\", file);\n        }\n    }\n\n EXIT_POINT:\n\n    /****************\n     * free logInfo *\n     ****************/\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n    rt_DestroyStructLogVar(logInfo->structLogVarsList);\n    logInfo->structLogVarsList = NULL;\n    FREE(logInfo->y);\n    logInfo->y = NULL;\n    FREE(logInfo);\n    rtliSetLogInfo(li,NULL);\n\n} /* end rt_StopDataLoggingImpl */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLogging ================================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLogging(const char_T *file, RTWLogInfo *li)\n{\n    rt_StopDataLoggingImpl(file,li,false);\n\n} /* end rt_StopDataLogging */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li) { (void(file)); } /* use file quiet unused macro warning */ /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n\n\n/* [eof] rt_logging.c */\n\n/* LocalWords:  Tfinal MAXNAM nonfinite DType PWS RSim Fixup logvar DDEFAULT th\n * LocalWords:  curr Realloc realloc inp biglong vijay ldexp TXY eof XFinal th\n * LocalWords:  TXXFY NULL typedefs ret polyspace NUL\n */\n"},{"name":"rtiostream_interface.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2018 The MathWorks, Inc.\n *\n * File: rtiostream_interface.c     \n *\n * Abstract: \n * Provide a target-side communications driver interface for Simulink external\n * mode.\n */\n\n\n/***************** TRANSPORT-INDEPENDENT INCLUDES *****************************/\n\n#ifndef EXTMODE_DISABLEPRINTF  \n#include <stdio.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"updown_util.h\"\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n\n/* include rtIOStream interface to use */\n#include \"rtiostream.h\"\n\n/* include Target-side rtIOStream utility APIs */\n#include \"rtiostream_utils.h\"\n\n#ifdef VXWORKS\n# include <sockLib.h>\n# include <inetLib.h>\n# include <selectLib.h>\nextern SEM_ID commSem;\n#endif\n\n#ifdef LEGO\n#include \"ecrobot_interface.h\"\n#endif\n\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/* \n * ExtCloseConnection() sets this to FALSE (to signal the low layer rtiostream)\n * on an external mode disconnection.\n * \n * rtIOStreamRecv() reads a few spurious bytes before receiving valid data on its\n * first call during external mode start or connect. Setting receivedSyncByteE\n * to FALSE forces rtIOStreamRecv() to look for the first character 'e' in 'ext-mode',\n * which is the first valid external mode packet. All preceding bytes are rejected and\n * subsequent bytes including the string 'ext-mode' are forwarded.\n * \n * For a more detailed description refer to the\n * comments in the associated rtiostream_serial_daemon.c/cpp file.\n */\n#if (defined(ARDUINO_ARCH_AVR) || defined(ARDUINO_SAM_DUE)) && !defined(_ROTH_LEONARDO_)\nextern volatile boolean_T receivedSyncByteE;\n#endif\n\ntypedef struct ExtUserData_tag {\n    boolean_T waitForStartPkt;\n    int streamID;\n#ifdef VXWORKS \n    int_T processArgsArgc;\n    const char_T ** processArgsArgv;\n#endif\n} ExtUserData;\n\n\n/* Function: ExtProcessArgs ====================================================\n * Abstract:\n *  Process the arguments specified by the user when invoking the target\n *  program.  In the case of this TCPIP example the args handled by external\n *  mode are:\n *      o -port #\n *          specify tcpip port number\n *      \n *      o -w\n *          wait for a start packet from the target before starting to execute\n *          the real-time model code\n *\n *  If any unrecognized options are encountered, ignore them.\n *\n * NOTES:\n *  o An error string is returned on failure, NULL is returned on success.\n *\n *  o IMPORTANT!!!\n *    As the arguments are processed, their strings must be NULL'd out in\n *    the argv array.  ext_svr will search argv when this function returns,\n *    and if any non-NULL entries are encountered an \"unrecognized option\" \n *    packet will be displayed.\n */\nPUBLIC const char_T *ExtProcessArgs(\n    ExtUserData   *UD,\n    const int_T   argc,\n    const char_T  *argv[])\n{\n    const char_T *error          = NULL;\n    int_T        count           = 1;\n\n#if defined(ON_TARGET_WAIT_FOR_START) && ON_TARGET_WAIT_FOR_START == 1\n    boolean_T    waitForStartPkt = true;\n#else\n    boolean_T    waitForStartPkt = false;\n#endif\n\n    while(count < argc) {\n        const char_T *option = argv[count++];\n        \n        if (option == NULL) continue;\n\n        if (strcmp(option, \"-w\") == 0) {\n            /* \n             * -w (wait for packet from host) option\n             */\n            waitForStartPkt = true;\n            \n            argv[count-1] = NULL;\n        } else if (strcmp(option, \"-ignore-arg\") == 0 && (count != argc)) {\n            /*\n             * Special argument used by sbruntests to mark an executable\n             * with a particular ID allowing the executable to be killed\n             * when the sbruntests session is killed.\n             *\n             * -ignore-arg SBRUNTESTS_SESSION_ID#\n             */\n            count++;     \n            argv[count-2] = NULL;\n            argv[count-1] = NULL;\n        }\n    }\n\n    assert(UD != NULL);\n    UD->waitForStartPkt = waitForStartPkt;\n\n#ifdef VXWORKS\n    /* Store argv and argc for processing in ExtUserDataSetPort. \n     * rtIOStreamOpen will be called in ExtUserDataSetPort */\n    UD->processArgsArgc = argc;\n    UD->processArgsArgv = (const char_T **) argv;\n#else\n    /* rtIOStreamOpen combines argument processing and opening the stream */\n    UD->streamID = rtIOStreamOpen(argc, (void **) (void *) argv);\n#endif    \n    return(error);\n} /* end ExtProcessArgs */\n\n\n/* Function: ExtUserDataCreate =================================================\n * Abstract:\n *  Create the user data.\n */\nPUBLIC ExtUserData *ExtUserDataCreate(void)\n{\n    static ExtUserData UD;\n\n    return &UD;\n} /* end ExtUserDataCreate */\n\n\n/* Function: ExtInit ===========================================================\n * Abstract:\n *  Called once at program startup to do any initialization related to external\n *  mode.  For the TCPIP, example, a socket is created to listen for\n *  connection requests from the host.  EXT_NO_ERROR is returned on success,\n *  EXT_ERROR on failure.\n *\n * NOTES:\n *  o This function should not block.\n */\nPUBLIC boolean_T ExtInit(ExtUserData *UD)\n{\n    boolean_T error      = EXT_NO_ERROR;\n\n    UNUSED_PARAMETER(UD);\n\n\n    /* rtIOStreamOpen has already been called so no further\n     * action required here */\n\n    return(error);\n} /* end ExtInit */\n\n/* Function: ExtSetHostPkt =====================================================\n * Abstract:\n *  Sets (sends) the specified number of bytes on the comm line.  As long as\n *  an error does not occur, this function is guaranteed to set the requested\n *  number of bytes.  The number of bytes set is returned via the 'nBytesSet'\n *  parameter.  EXT_NO_ERROR is returned on success, EXT_ERROR is returned on\n *  failure.\n *\n * NOTES:\n *  o it is always o.k. for this function to block if no room is available\n */\nPUBLIC boolean_T ExtSetHostPkt(\n    const ExtUserData *UD,\n    const int         nBytesToSet,\n    const char        *src,\n    int               *nBytesSet)\n{\n    boolean_T errorCode = EXT_NO_ERROR;\n\tint_T rtIOStreamErrorStatus;\n\t*nBytesSet = 0;\t/* assume */\n\n    #ifdef VXWORKS\n        semTake(commSem, WAIT_FOREVER);\n    #endif\n\n    /* Blocks until all requested outgoing data is sent */\n    rtIOStreamErrorStatus = rtIOStreamBlockingSend(UD->streamID,\n                                                   (const void *) src,\n                                                   (uint32_T) nBytesToSet);\n    \n    if (rtIOStreamErrorStatus == RTIOSTREAM_ERROR) {\n        errorCode = EXT_ERROR;\n    } else { \n        *nBytesSet = nBytesToSet;\n    }\n    \n    #ifdef VXWORKS\n        semGive(commSem);\n    #endif\n\n    return errorCode;\n\n} /* end ExtSetHostPkt */\n\n/* Function: ExtGetHostPkt =====================================================\n * Abstract:\n *  Attempts to get the specified number of bytes from the comm line.  The\n *  number of bytes read is returned via the 'nBytesGot' parameter.\n *  EXT_NO_ERROR is returned on success, EXT_ERROR is returned on failure.\n *\n * NOTES:\n *  o it is not an error for 'nBytesGot' to be returned as 0\n *  o not guaranteed to read total requested number of bytes\n */\nPUBLIC boolean_T ExtGetHostPkt(\n    const ExtUserData *UD,\n    const int         nBytesToGet,\n    int               *nBytesGot, /* out */\n    char              *dst)       /* out */\n{\n    boolean_T error = EXT_NO_ERROR;\n    int_T result;\n    size_t stNBytesGot;\n\n    result = rtIOStreamRecv(UD->streamID, dst, (size_t) nBytesToGet, &stNBytesGot);\n\n    if (result == RTIOSTREAM_ERROR) {\n        error = EXT_ERROR;\n    } else {\n        *nBytesGot = (int) stNBytesGot;\n    }\n\n    return(error);\n} /* end ExtGetHostPkt */\n\n\n/* Function: ExtWaitForStartPktFromHost ========================================\n * Abstract:\n *  Return true if the model should not start executing until told to do so\n *  by the host.\n */\nPUBLIC boolean_T ExtWaitForStartPktFromHost(ExtUserData *UD)\n{\n    return(UD->waitForStartPkt);\n} /* end ExtWaitForStartPktFromHost */\n\n\n/* Function: ExtUserDataDestroy ================================================\n * Abstract:\n *  Destroy the user data.\n */\nPUBLIC void ExtUserDataDestroy(ExtUserData *UD)\n{\n    UNUSED_PARAMETER(UD);\n} /* end ExtUserDataDestroy */\n\n/* Function: ExtUserDataSetPort ================================================\n * Abstract:\n *  Set the port in the external mode user data structure.\n */\n#ifdef VXWORKS\nPUBLIC void ExtUserDataSetPort(ExtUserData *UD, const int_T port)\n{\n#define PORT_NUM_STR_DEFAULT \"00255\\0\"\n#define PORT_NUM_STR_LEN 6 /* allocates extra space for sprintf below */\n#define PORT_ARG_STR \"-port\"\n    /* create an extended argc and argv that includes -port */    \n    const int_T argc = UD->processArgsArgc + 2;\n    const char_T * portArgStr = PORT_ARG_STR;\n    char_T portNumStr[PORT_NUM_STR_LEN] = PORT_NUM_STR_DEFAULT;\n    const char_T ** argv = (const char_T **) calloc(argc, sizeof(char_T *));\n    int_T count;\n    if (argv == NULL) {\n#ifndef EXTMODE_DISABLEPRINTF        \n       (void)fprintf(stderr,\n                \"ExtUserDataSetPort: Memory allocation error.\\n\");\n#endif\n       /* any unprocessed args in the original argv will be caught by caller */\n       return;\n    }\n    /* set a non-default port if valid */ \n    if ( (port >=255) && (port <= 65535)) {\n        sprintf(portNumStr, \"%5d\", port);\n    }\n    /* copy original argv */\n    for (count = 0; count < UD->processArgsArgc; count++) {\n      argv[count] = UD->processArgsArgv[count];\n    }\n    /* add port */\n    argv[argc-2] = portArgStr;\n    argv[argc-1] = (const char_T *) portNumStr;\n        \n    /* rtIOStreamOpen combines argument processing and opening the stream */\n    UD->streamID = rtIOStreamOpen(argc, (void *) argv);\n\n    /* We assume -port argument has been processed by rtIOStream.\n     * Copy back other elements of processed argv which should have been set to NULL. */\n    for (count = 0; count < UD->processArgsArgc; count++) {\n       UD->processArgsArgv[count] = argv[count];\n    }\n    free(argv);\n} /* end ExtUserDataSetPort */\n#endif\n\n\n/* Function: ExtModeSleep =====================================================\n * Abstract:\n *  This function is used if the target is in pause mode or waiting for a\n *  start packet from the host. By calling ExtModeSleep prior to checking \n *  the receive buffer, we can prevent excessive CPU loading.\n */\n#ifndef VXWORKS\nPUBLIC void ExtModeSleep(\n    const ExtUserData *UD,\n    const long        sec,  /* # of secs to wait        */\n    const long        usec) /* # of micros secs to wait */\n{\n\n    UNUSED_PARAMETER(UD);\n    UNUSED_PARAMETER(sec);\n    UNUSED_PARAMETER(usec);\n\n    /* This function is intentionally left empty */\n\n} /* end ExtModeSleep */\n#endif\n\n\n/* Function: ExtOpenConnection =================================================\n * Abstract:\n *  The rtIOStream driver must open a connection implicitly as required. Hence\n *  the implementation of this function is empty.\n */\nPUBLIC boolean_T ExtOpenConnection(\n    ExtUserData *UD,\n    boolean_T   *outConnectionMade)\n{\n    boolean_T          error          = EXT_NO_ERROR;\n    UNUSED_PARAMETER(UD);\n\n    *outConnectionMade = 1;\n    return error;\n\n} /* end ExtOpenConnection */\n\n\n/* Function: ExtForceDisconnect ================================================\n * Abstract:\n *  Called by rt_UploadServerWork() in ext_svr.c when there is an extmode\n *  communication error (e.g. a tcp/ip disconnection between the host and target\n *  caused by a cable problem or extremely high network traffic).  In this case,\n *  we want the target to disconnect from the host even if it can't communicate\n *  with the host because we assume that the communication problem caused the\n *  host to disconnect.  This function will perform all steps necessary to\n *  shutdown the communication and leave the target in a state ready to be\n *  reconnected.\n */\nPUBLIC void ExtForceDisconnect(ExtUserData *UD)\n{\n\n    UNUSED_PARAMETER(UD);\n\n} /* end ExtForceDisconnect */\n\n/* Function: ExtCloseConnection ================================================\n * Abstract:\n *  Called when the target needs to disconnect from the host (disconnect\n *  procedure is initiated by the host).\n */\nPUBLIC void ExtCloseConnection(ExtUserData *UD)\n{\n    UNUSED_PARAMETER(UD);\n    \n    #ifdef LEGO\n    ecrobot_term_bt_connection();\n    #endif\n    \n    #if (defined(ARDUINO_ARCH_AVR) || defined(ARDUINO_SAM_DUE)) && !defined(_ROTH_LEONARDO_)\n    receivedSyncByteE = false;\n    #endif\n            \n} /* end ExtCloseConnection */\n\n\n/* Function: ExtShutDown =======================================================\n * Abstract:\n *  Called when the target program is terminating.\n */\nPUBLIC void ExtShutDown(ExtUserData *UD)\n{\n    rtIOStreamClose(UD->streamID);\n} /* end ExtShutDown */\n\n/* LocalWords:  NULL'd svr extmode tcp ip\n */\n"},{"name":"rtiostream_tcpip.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2023a\\toolbox\\coder\\rtiostream\\src\\rtiostreamtcpip","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2022 The MathWorks, Inc.\n *\n * File: rtiostream_tcpip.c     \n *\n * Abstract: This source file implements both client-side and server-side TCP/IP\n *  and UDP/IP communication. Typically, this driver is used to support host-target\n *  communication where the client-side device driver runs on the host and the\n *  server-side driver runs on the target. For this implementation, both\n *  client-side and server-side driver code has been combined into a single\n *  file.\n *\n *  If you are using this code as a starting point to implement a TCP/IP or \n *  UDP/IP driver for a custom target it is only necessary to include code \n *  for the server side of the connection.\n */\n\n#ifndef _WIN32\n/* Required BSD Unix extensions are not available by default on certain Unix\n * distributions */\n#define _DEFAULT_SOURCE     /* _DEFAULT_SOURCE must be defined to avoid\n                               _BSD_SOURCE deprecation warning\n                               for glibc >= 2.20 */\n#define _BSD_SOURCE         /* Required to support glibc <= 2.19 */\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <limits.h>\n#include \"rtiostream.h\"\n#include \"tmwtypes.h\"\n\n#ifdef _WIN32\n  /* WINDOWS */\n\n#if defined(_MSC_VER)\n /* temporarily disable warning triggered\n  * by windows.h */\n #pragma warning(push)\n #pragma warning(disable: 4255)\n#endif\n\n#include <windows.h>\n\n#if defined(_MSC_VER)\n /* restore warning */\n #pragma warning(pop)\n#endif\n\n# ifdef __LCC__\n# ifndef __LCC64__\n#   include <winsock2.h>\n# endif\n#   include <errno.h>\n# endif\n\n#include <winsock.h> /* in case if WIN32_LEAN_AND_MEAN was defined and needs to be after winsock2 */\n\n#define RTIOSTREAM_ECONNRESET WSAECONNRESET\n\n#elif defined(VXWORKS)\n /*VxWorks headers*/\n# include <selectLib.h>\n# include <sockLib.h>\n# include <inetLib.h>\n# include <ioLib.h>\n# include <taskLib.h>\n# include <netinet/tcp.h> \n\n#define RTIOSTREAM_ECONNRESET ECONNRESET\n\n#else\n  /* UNIX */\n# include <signal.h>\n# include <sys/time.h>      /* Linux */\n# include <sys/types.h>     /* Linux */\n# include <sys/socket.h>\n# include <sys/poll.h>\n# include <netinet/in.h>    /* Linux */\n# include <netinet/tcp.h>   /* Linux */\n# include <arpa/inet.h>     /* Linux */\n# include <netdb.h>\n# include <errno.h>\n# include <fcntl.h>  \n# include <unistd.h>\n\n#define RTIOSTREAM_ECONNRESET ECONNRESET\n#endif\n\n#if defined(_WIN32) || defined(VXWORKS)\n#define USE_SELECT  \n#endif\n\n#ifdef USE_MEXPRINTF\n#include \"mex.h\"\n#define printf mexPrintf\n#define SERVER_PORT_PRINTF(FORMAT, ARG1) mexPrintf(FORMAT, ARG1)\n#else\n/* If stdout is redirected to file, it is essential that the port number is \n * available immediately in the output file. With LCC, printf does not flush \n * correctly to the redirected output file - use fprintf & fflush instead. */\n#define SERVER_PORT_PRINTF(FORMAT, ARG1) fprintf(stdout, FORMAT, ARG1); \\\n                                         fflush(stdout)\n#endif\n\n/***************** DEFINES ****************************************************/                                         \n#define HOSTNAME_MAXLEN (64U)\n\n#define SERVER_PORT_NUM  (17725U)   /* sqrt(pi)*10000 */\n\n/* \n * EXT_BLOCKING  \n *\n * Depending on the implementation of the main program (e.g., grt_main.c,\n * rt_main.c), the EXT_BLOCKING flag must be set to either 0 or 1.\n *\n * rt_main.c (tornado/vxworks): rt_main.c is a real-time, multi-tasking target.\n * The upload and packet servers are called via background (low priority) tasks.\n * In this case, it is o.k. for the transport function to block as the blocked\n * tasks will simply be pre-empted in order to enable the model to run.  It is\n * desirable to block instead of to poll to free up the cpu for any other\n * potential work. \n */\n#ifdef VXWORKS\n# define EXT_BLOCKING (1)  \n#else\n# define EXT_BLOCKING (0)  \n#endif\n\n/* timeout of 0 means to return immediately */\n#define BLOCKING_RECV_TIMEOUT_NOWAIT (0)\n/* timeout of -1 means to wait indefinitely */\n#define BLOCKING_RECV_TIMEOUT_NEVER (-1)\n/* rogue value for blocking receive timeout */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT (-2)\n/* timeout of -3 means to wait for 10 ms to avoid high CPU load */\n#define BLOCKING_RECV_TIMEOUT_10MS (-3)\n/* wake up from blocking every second */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_CLIENT (1) \n/* only wake up from blocking when data arrives */\n#define DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_SERVER (BLOCKING_RECV_TIMEOUT_NEVER)\n/* server wait time for client to close its socket */\n#define BLOCKING_RECV_TIMEOUT_SOCK_SHUTDOWN (60)\n\n/* define a set of verbosity levels:\n *\n * 0: no verbose output\n * 1: verbose output with data\n * 2: extra verbose output including when data size is zero*/\ntypedef enum {VERBOSITY_LEVEL_0=0, VERBOSITY_LEVEL_1, VERBOSITY_LEVEL_2} VerbosityLevel;\n/* default verbosity value */\n#define DEFAULT_VERBOSITY VERBOSITY_LEVEL_0\n\n/* default protocol value */\n#define DEFAULT_PROTOCOL TCP_PROTOCOL\n/* allowed -protocol strings */\n#define TCP_PROTOCOL_STRING \"TCP\"\n#define UDP_PROTOCOL_STRING \"UDP\"\n#define UDP_PACKET_LOSS_DETECTON_PROTOCOL_STRING \"UDP_PACKET_LOSS_DETECTION\"\n\n/* default UDP max packet size \n *\n * The maximum size of UDP packets that are transmitted / received must be\n * consistent on the host and target otherwise receive errors will occur at \n * the side with the smaller buffer size specified.\n *\n * Use the \"-maxudppacketsize SIZE\" argument to specify a different packet size.\n * This option is particularly useful when using a custom server implementation\n * that uses a different max packet size to the default. \n *\n * The maximum UDP payload is 65507 bytes, which can be achieved for localhost\n * based communications on Linux and Windows, but Mac has a lower size of\n * 9216.\n */\n#define UDP_MAX_PACKET_SIZE 9216\n#define DEFAULT_MAX_UDP_PACKET_SIZE UDP_MAX_PACKET_SIZE\n/* increase the UDP socket receive size to decrease the \n * possibility of buffer overflow */\n#define DEFAULT_UDP_SOCKET_RECEIVE_SIZE_REQUEST (512 * 1024) \n#define DEFAULT_UDP_SOCKET_SEND_SIZE_REQUEST (512 * 1024) \n\n#define DEFAULT_IS_USING_SEQ_NUM 1\n\n#ifdef WIN32\n  /* WINDOWS */\n# define close closesocket\n# define SOCK_ERR SOCKET_ERROR\n#else\n  /* UNIX, VXWORKS */\n# define INVALID_SOCKET (-1)\n# define SOCK_ERR (-1)\n\n  typedef int SOCKET;\n#endif\n\n/*\n * send prototype differs on different platforms. The following typedefs\n * suppress compiler warnings.\n */\n#if defined(WIN32)\ntypedef const char * send_buffer_t;\n#elif defined(VXWORKS)\ntypedef char * send_buffer_t;\n#else\ntypedef const void * send_buffer_t;\n#endif\n\n/* MIN utility */\n#ifndef MIN\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#endif\n\n/***************** TYPEDEFS **************************************************/\n\n#if (defined(_WIN32)) || (defined(VXWORKS))\n   /* socklen_t may not be available */\n   typedef int rtiostream_socklen_t;\n#else\n   typedef socklen_t rtiostream_socklen_t;\n#endif\n\n/* Server specific data structure */\ntypedef struct ServerData_tag {\n    int       port;           /* port number associated with the server socket */\n    SOCKET    listenSock;     /* listening socket to accept incoming connections */\n    char      *serverInfoFile; /* the filename that is used to write the server \n                                 port number when dynamic port allocation is used */                      \n} ServerData;\n\n/* UDP send / receive buffer data structure */\ntypedef struct UDPPacketBuffer_tag {\n    char * buffer; /* pointer to the buffer */\n    char * dataPtr; /* pointer to the current position in the buffer */\n    int dataAvail; /* amount of data in the buffer */\n} UDPPacketBuffer;\n\n/* Type for the optional UDP sequence number */\ntypedef uint32_T udpSeqNum_T;\n/* byte size of the UDP sequence number */\n#define UDP_SEQ_NUM_SIZE ((int) sizeof(udpSeqNum_T))\n\n/* UDP specific data structure */\ntypedef struct UDPData_tag {\n   int isUsingSeqNum; /* is this connection using sequence numbers */\n   int maxPacketSize; /* max packet size (buffer size) */\n   UDPPacketBuffer * recvBuffer; /* buffer for an incoming datagram */\n   UDPPacketBuffer * sendBuffer; /* buffer for an outgoing datagram */\n   udpSeqNum_T sendSeqNum; /* sequence number to add to outgoing datagrams */\n   udpSeqNum_T expectedRecvSeqNum; /* expected sequence number in incoming \n                                   datagrams */\n   int resetExpectedRecvSeqNum; /* flags whether to reset expectedRecvSeqNum\n                                   to the sequence number of the next incoming\n                                   datagram */\n} UDPData;\n\n/* enum of supported communications protocols */\ntypedef enum {TCP_PROTOCOL, UDP_PROTOCOL} CommsProtocol;\n\n/* Data encapsulating a single client / server connection  */\ntypedef struct ConnectionData_tag {\n   int isInUse; /* is this ConnectionData instance currently in use? */\n   int isServer; /* is this ConnectionData instance a Server (or client)? */\n   int blockingRecvTimeout; /*    Timeout value in seconds. rtIOStreamRecv \n                                  blocks until at least some of the requested \n                                  data is available or the timeout expires.   \n                                  If a timeout occurs the receiveSize will be 0. \n\n                                  A value of BLOCKING_RECV_TIMEOUT_NOWAIT (0)\n                                  means to block for 0 seconds (polling mode). \n                                  rtIOStreamRecv processes \n                                  any pending data or, if no data is available, \n                                  returns immediately with a receiveSize of 0.\n\n                                  A value of BLOCKING_RECV_TIMEOUT_NEVER (-1)\n                                  means to block indefinitely (full blocking \n                                  mode). rtIOStreamRecv blocks\n                                  until at least some of the requested data is \n                                  available.   receiveSize should always be \n                                  greater than 0. \n\n                                  A value of BLOCKING_RECV_TIMEOUT_10MS (-3)\n                                  means to block for up to 10 ms to avoid high CPU \n                                  load.\n                             */\n   VerbosityLevel verbosity; /* enum indicating the level of verbosity to be displayed on the output */\n   CommsProtocol protocol; /* TCP or UDP protocol */\n   SOCKET sock; /* socket to send/receive packets */\n   ServerData * serverData; /* Server specific data - NULL for clients */\n   UDPData * udpData; /* UDP specific data - NULL for TCP */\n   int udpSendBufSize;\n   int udpRecvBufSize;\n} ConnectionData;\n\n/**************** LOCAL DATA *************************************************/\n\n/* All local data resides in the per client / \n * server instance ConnectionData structures to make sure each connection is\n * completely independent.\n *\n * Each ConnectionData does not use much memory; any optionally required \n * send / recv buffers are dynamically allocated and freed when the ConnectionData \n * actually becomes in use.\n *\n * The static array will be deallocated when the shared library is unloaded. \n *\n * Using an array rather than a linked list allows us to have fast direct lookup\n * of ConnectionData from connectionID during calls to rtIOStreamSend/Recv */\n#define MAX_NUM_CONNECTIONS (50)\nstatic ConnectionData connectionDataArray[MAX_NUM_CONNECTIONS];\n\n/************** LOCAL FUNCTION PROTOTYPES ************************************/\n\nstatic int initConnectionData(int connectionID, \n                          int isServer, \n                          CommsProtocol protocol, \n                          SOCKET sock, \n                          int blockingRecvTimeout,\n                          int maxPacketSize, \n                          int serverPort, \n                          char * serverInfoFile, \n                          VerbosityLevel verbosity, \n                          int isUsingSeqNum,\n                          int udpSendBufSize,\n                          int udpRecvBufSize); \n\nstatic int getConnectionID(void);\n\nstatic ConnectionData * getConnectionData(int connectionID);\n\nstatic void freeConnectionData(ConnectionData * connection);\n\nstatic UDPPacketBuffer * createUDPPacketBuffer(int maxPacketSize);\n\nstatic void freeUDPPacketBuffer(UDPPacketBuffer ** udpPacketBuffer);\n\nstatic void resetUDPPacketBuffer(UDPPacketBuffer * udpPacketBuffer);\n\nstatic int processUDPRecvSeqNum(ConnectionData * connection);\n\nstatic int initialUDPServerRecvfrom(ConnectionData * connection,\n                                    struct sockaddr * clientSA,\n                                    rtiostream_socklen_t * clientSALen);\n\nstatic int waitForClientClose(ConnectionData * connection);\n\nstatic int socketDataSet(\n    ConnectionData * connection, \n    const void *src,\n    const size_t size,\n    size_t *sizeSent);\n\nstatic int socketDataGet(\n    ConnectionData * connection, \n    char          *dst,\n    const size_t   size,\n    size_t        *sizeRecvd);\n\nstatic int socketDataPending(\n    const SOCKET sock,\n    ConnectionData * connection,\n    int    *outPending,\n    int timeoutSecs);\n\nstatic int serverStreamRecv( \n    ConnectionData * connection, \n    void * dst,\n    size_t size,\n    size_t * sizeRecvd);\n\nstatic SOCKET serverOpenSocket(int port, char * serverInfoFile, CommsProtocol protocol,int udpSendBufSize, int udpRecvBufSize);\n\n#if (!defined(VXWORKS))\nstatic SOCKET clientOpenSocket(char * hostName, unsigned int portNum, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize);\n#endif\n\nstatic void serverAcceptSocket(ConnectionData * connection);\n\nstatic int processArgs(\n    const int          argc,\n    void            *  argv[],\n    char           **  hostName, \n    unsigned int    *  portNum,\n    unsigned int    *  isClient,\n    int             *  isBlocking,\n    int             *  recvTimeout, \n    char           **  serverInfoFile, \n    CommsProtocol   * protocol, \n    int             * maxPacketSize,\n    VerbosityLevel  * verbosity, \n    int             * isUsingSeqNum,\n    int             * udpSendBufSize,\n    int             * udpRecvBufSize);\n\n#if (!defined(VXWORKS))\nstatic unsigned long nameLookup(char * hostName);\n#endif\n\n/*************** LOCAL FUNCTIONS **********************************************/\n\n/* Function: initConnectionData =================================================\n * Abstract:\n *  Initializes a client / server ConnectionData for the specified protocol.\n *\n *  A return value of RTIOSTREAM_ERROR indicates an error.\n */\nstatic int initConnectionData(int connectionID, \n                          int isServer, \n                          CommsProtocol protocol, \n                          SOCKET sock, \n                          int blockingRecvTimeout,\n                          int maxPacketSize, \n                          int serverPort, \n                          char * serverInfoFile, \n                          VerbosityLevel verbosity, \n                          int isUsingSeqNum,\n                          int udpSendBufSize,\n                          int udpRecvBufSize) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n   ConnectionData * connection = &connectionDataArray[connectionID];\n  \n   /* initialize the new ConnectionData */\n   connection->isInUse = 1;\n   connection->isServer = isServer;\n   connection->blockingRecvTimeout = blockingRecvTimeout;\n   connection->protocol = protocol;\n   connection->verbosity = verbosity;\n   connection->udpSendBufSize = udpSendBufSize;\n   connection->udpRecvBufSize = udpRecvBufSize;\n   /* initialize to NULL early so that calls to \n    * freeConnectionData on error will succeed */\n   connection->udpData = NULL;\n   connection->serverData = NULL;\n\n   if (connection->protocol == UDP_PROTOCOL) {      \n      /* initialize the UDP data */\n      connection->udpData = (UDPData *) malloc(sizeof(UDPData));\n      if (connection->udpData == NULL) {\n         printf(\"initConnectionData:UDPData malloc failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      /* initialize to NULL */\n      connection->udpData->recvBuffer = NULL;\n      connection->udpData->sendBuffer = NULL;\n      connection->udpData->isUsingSeqNum = isUsingSeqNum;\n      connection->udpData->maxPacketSize = maxPacketSize;\n      /* send sequence numbers always start from 0 */\n      connection->udpData->sendSeqNum = 0;\n      /* initially, seed the expectedRecvSeqNum from the first \n       * received packet */\n      connection->udpData->resetExpectedRecvSeqNum = 1;      \n      connection->udpData->recvBuffer = createUDPPacketBuffer(maxPacketSize);\n      if (connection->udpData->recvBuffer == NULL) {\n         printf(\"initConnectionData:createUDPPacketBuffer failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      if (maxPacketSize > UDP_MAX_PACKET_SIZE) {\n         /* packet size cannot exceed the maximum \n          * UDP packet size */\n         printf(\"initConnectionData: udpmaxpacketsize must be less than %d\\n\", UDP_MAX_PACKET_SIZE);\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      if (connection->udpData->isUsingSeqNum) {\n         /* packet size must be larger than the size\n          * of the sequence number */\n         if (maxPacketSize <= UDP_SEQ_NUM_SIZE) {\n            printf(\"initConnectionData: udpmaxpacketsize must be larger than %d\\n\", UDP_SEQ_NUM_SIZE);\n            freeConnectionData(connection);\n            retVal = RTIOSTREAM_ERROR;\n            return retVal; \n         }\n         /* send buffer will be required in order to add the sequence\n          * number to the outgoing data */\n         connection->udpData->sendBuffer = createUDPPacketBuffer(maxPacketSize);\n         if (connection->udpData->sendBuffer == NULL) {\n            printf(\"initConnectionData:createUDPPacketBuffer failed.\\n\");\n            freeConnectionData(connection);\n            retVal = RTIOSTREAM_ERROR;\n            return retVal; \n         }\n      }\n   }\n\n   if (isServer) {\n      /* initialize server data */\n      connection->serverData = (ServerData *) malloc(sizeof(ServerData));\n      if (connection->serverData == NULL) {\n         printf(\"initConnectionData:ServerData malloc failed.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      connection->serverData->port = serverPort;\n      connection->serverData->serverInfoFile = serverInfoFile;\n      /* provided sock is the listening sock */\n      connection->serverData->listenSock = sock;\n      /* later call to serverAcceptSocket will set sock */ \n      connection->sock = INVALID_SOCKET;\n   }\n   else {\n      /* store the provided socket */\n      connection->sock = sock;\n   }\n\n   if (verbosity) {\n      if (connection->protocol == TCP_PROTOCOL) {\n         printf(\"Connection id %d, protocol: TCP/IP\\n\", connectionID);\n      }\n      else if (connection->protocol == UDP_PROTOCOL) {\n         printf(\"Connection id %d, protocol: UDP/IP\\n\", connectionID);\n         printf(\"Connection id %d, maxPacketSize: %d\\n\", connectionID, \n                                                         connection->udpData->maxPacketSize);\n         printf(\"Connection id %d, isUsingSeqNum: %d\\n\", connectionID, \n                                                         connection->udpData->isUsingSeqNum);\n      }\n      else {\n         printf(\"initConnectionData:invalid protocol.\\n\");\n         freeConnectionData(connection);\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      {\n         /* display the size of the socket receive buffer */\n         rtiostream_socklen_t optionLen = sizeof(int);\n         int optionValue;\n         getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *) &optionValue, &optionLen);\n         printf(\"Connection id %d, udpSendBufSize: %d\\n\", connectionID, optionValue);\n         getsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *) &optionValue, &optionLen);\n         printf(\"Connection id %d, udpRecvBufSize: %d\\n\", connectionID, optionValue);\n      }\n      printf(\"Connection id %d, blockingRecvTimeout: %d\\n\", connectionID, \n                                                            connection->blockingRecvTimeout);\n      if ((connection->isServer) && (connection->serverData != NULL)) {\n         printf(\"Connection id %d, type: server\\n\", connectionID);       \n         if (connection->serverData->serverInfoFile != NULL) {\n            printf(\"Connection id %d, server info file: %s\\n\", connectionID, \n                                                               connection->serverData->serverInfoFile);\n         }\n      }\n      else {\n         printf(\"Connection id %d, type: client\\n\", connectionID);\n      }\n      printf(\"Connection id %d, socket id %d\\n\", connectionID, (int) sock);\n      /* relevant to both clients and servers */\n      printf(\"Connection id %d, server port: %d\\n\", connectionID, serverPort);\n   }\n   return retVal;\n}\n\n/* Function: getConnectionData =================================================\n * Abstract:\n *  Retrieves a ConnectionData instance given its connectionID \n *  (as returned by initConnectionData) \n *\n * NOTE: An invalid connectionID will lead to a NULL pointer being returned \n */\nstatic ConnectionData * getConnectionData(int connectionID) {\n   /* return NULL for invalid or uninitialized connectionIDs */\n   ConnectionData * connection = NULL;\n   if ((connectionID >= 0) && (connectionID < MAX_NUM_CONNECTIONS)) {\n      if (connectionDataArray[connectionID].isInUse) {\n         connection = &connectionDataArray[connectionID];\n      }\n   }\n   return connection;\n}\n\n/* Function: getConnectionID =================================================\n * Abstract:\n *  Returns a connectionID corresponding to a ConnectionData that is not \n *  already in use.\n *\n *  Returns RTIOSTREAM_ERROR if all available ConnectionData instances are \n *  already in use.\n */\nstatic int getConnectionID(void) {\n   int connectionID;\n   int foundUnusedConnectionData = 0;\n   /* linear search for an unused ConnectionData */\n   for (connectionID = 0; connectionID < MAX_NUM_CONNECTIONS; connectionID++) {      \n      if (!connectionDataArray[connectionID].isInUse) {\n         foundUnusedConnectionData = 1;\n         break;\n      }\n   }\n   if (!foundUnusedConnectionData) {\n      /* all ConnectionData's are in use */\n      printf(\"getConnectionID: All %d available connections are in use.\\n\", MAX_NUM_CONNECTIONS);\n      connectionID = RTIOSTREAM_ERROR;\n   }\n   return connectionID;\n}\n\n/* Function: freeConnectionData =================================================\n * Abstract:\n *  Frees memory associated with the ConnectionData referenced by connectionID.\n *  Marks the ConnectionData instance as no longer in use.\n */\nstatic void freeConnectionData(ConnectionData * connection) {\n   /* mark the ConnectionData as not in use */\n   connection->isInUse = 0;\n   /* free dynamic memory */\n   if (connection->protocol == UDP_PROTOCOL) {\n      freeUDPPacketBuffer(&connection->udpData->recvBuffer);\n      /* freeConnectionData is called if connection->udpData did not allocate */\n      if (connection->udpData != NULL) {\n        if (connection->udpData->isUsingSeqNum) {\n            freeUDPPacketBuffer(&connection->udpData->sendBuffer);\n        }\n      }\n      free(connection->udpData);\n      connection->udpData = NULL;\n   }\n   if (connection->isServer) {\n      free(connection->serverData);\n      connection->serverData = NULL;\n   }\n}\n\n/* Function: createUDPPacketBuffer =================================================\n * Abstract:\n *  Allocates storage for and initializes a UDPPacketBuffer\n */\nstatic UDPPacketBuffer * createUDPPacketBuffer(int maxPacketSize) {\n   /* initialize the UDP packet buffer */\n   UDPPacketBuffer * udpPacketBuffer = (UDPPacketBuffer *) malloc(sizeof(UDPPacketBuffer));      \n   if (udpPacketBuffer == NULL) {\n      printf(\"createUDPPacketBuffer:UDPPacketBuffer malloc failed.\\n\");\n      return udpPacketBuffer; \n   }\n   /* allocate the buffer */\n   udpPacketBuffer->buffer = (char *) calloc((size_t)maxPacketSize, sizeof(char));\n   if (udpPacketBuffer->buffer == NULL) {\n      printf(\"createUDPPacketBuffer:UDPPacketBuffer buffer malloc failed.\\n\");\n      /* free everything we allocated */\n      free(udpPacketBuffer);\n      udpPacketBuffer = NULL;\n      return udpPacketBuffer; \n   }\n   resetUDPPacketBuffer(udpPacketBuffer);\n   return udpPacketBuffer;\n}\n\n/* Function: freeUDPPacketBuffer =================================================\n * Abstract:\n *  Frees memory associated with the referenced UDPPacketBuffer \n */\nstatic void freeUDPPacketBuffer(UDPPacketBuffer ** udpPacketBuffer) {\n   if (*udpPacketBuffer != NULL) {\n      /* free the buffer */\n      free((*udpPacketBuffer)->buffer);\n      (*udpPacketBuffer)->buffer = NULL;\n      /* free the container */\n      free(*udpPacketBuffer);\n      *udpPacketBuffer = NULL;\n   }\n}\n\n/* Function: resetUDPPacketBuffer =================================================\n * Abstract:\n *  Resets the referenced UDP Packet Buffer so that it is ready to receive fresh data\n */\nstatic void resetUDPPacketBuffer(UDPPacketBuffer * udpPacketBuffer) {\n   udpPacketBuffer->dataPtr = udpPacketBuffer->buffer;\n   udpPacketBuffer->dataAvail = 0;\n}\n\n/* Function: socketDataPending =================================================\n * Abstract:\n *  Returns true, via the 'pending' arg, if data is pending on the comm line.\n *  Returns false otherwise.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR on failure.\n */\nstatic int socketDataPending(\n    const SOCKET sock,\n    ConnectionData * connection,\n    int    *outPending, \n    int timeoutSecs)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    int pending = SOCK_ERR; /* assume failure until success */\n    \n    #ifdef USE_SELECT\n    /* Variables used with select() on Win32 & VXWorks */\n    struct timeval  tval;\n    struct timeval * tvalPtr;\n    fd_set          ReadFds;\n    #else\n    /* Variables used with poll() on Linux */\n    struct pollfd PollReadFd[1];\n    int tvalPoll;\n    int pollAttempt = 0;\n    #define MAX_POLL_RETRIES 5\n    #endif\n    \n    \n    if (connection->protocol == UDP_PROTOCOL) {\n       /* first check the UDP buffer */\n       UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n       if (udpPacketBuffer->dataAvail) {\n          *outPending = 1;\n          return retVal;\n       }\n    }\n\n    #ifdef USE_SELECT          /* Beginning of block for using select */\n    FD_ZERO(&ReadFds);\n    \n    #if defined(_WIN32) && defined(_MSC_VER)\n      /*temporarily disable warning C4127 caused by using FD_SET*/\n      #pragma warning(push)\n      #pragma warning(disable: 4127)\n    #endif\n\n    /* Using fd_set structure ReadFds on Win32/VXWorks */\n    FD_SET(sock, &ReadFds);\n    \n    #if defined(_WIN32) && defined(_MSC_VER)\n      /*enable the warning C4127*/\n      #pragma warning(pop)\n    #endif\n\n    /* Select() uses a timeval structure for specifying timeout */\n    switch (timeoutSecs) {\n       case BLOCKING_RECV_TIMEOUT_NEVER:\n          /* specify null pointer for blocking */\n          tvalPtr = NULL;\n          break;\n       case BLOCKING_RECV_TIMEOUT_10MS:\n          /* set up the 10ms time-val */\n          tval.tv_sec  = 0;\n          tval.tv_usec = 10000;\n          tvalPtr = &tval;\n          break;\n       default:\n          /* set up the time-val */\n          tval.tv_sec  = timeoutSecs;\n          tval.tv_usec = 0;\n          tvalPtr = &tval;\n          break;\n    }\n    #else                       /* Else block for using select */\n    /* Poll() uses an int specifying timeout in milliseconds */\n    switch (timeoutSecs) {\n       case BLOCKING_RECV_TIMEOUT_NEVER:\n          /* specify negative value for blocking */\n          tvalPoll = -1;\n          break;\n       case BLOCKING_RECV_TIMEOUT_10MS:\n          /* set up the 10ms time-val */\n          tvalPoll = 10;\n          break;\n       default:\n          /* set up the time-val */\n          tvalPoll = timeoutSecs*1000;\n          break;\n    }\n    #endif                      /* End of block for using select */\n\n    \n    #ifdef USE_SELECT\n    /* Use select() on Win32 and VxWorks */\n    /*\n     * Casting the first arg to int removes warnings on windows 64-bit\n     * platform.  It is safe to cast a SOCKET to an int here because on\n     * Linux SOCKET is typedef'd to int and on windows the first argument\n     * to select is ignored (so it doesn't matter what the value is).\n     */\n    pending = select((int)(sock + 1), &ReadFds, NULL, NULL, tvalPtr);\n    #else\n    /* Use poll() on Linux and Mac to avoid issues with sockets >= FD_SETSIZE */\n    PollReadFd[0].fd = sock;\n    PollReadFd[0].events = POLLIN;\n    \n    /* Timer interrupts may cause poll to fail with error EINTR.\n     * In these cases we should retry MAX_POLL_RETRIES times before\n     * concluding an error.\n     */\n    do {\n        pending = poll( PollReadFd, 1, tvalPoll);\n        pollAttempt++;\n    } while (pending == SOCK_ERR && errno == EINTR && pollAttempt < MAX_POLL_RETRIES);\n    #endif\n\n    #ifdef USE_SELECT\n    if (pending == SOCK_ERR) \n    #else\n    /* On Linux an extra check of POLLERR flag is needed to detect and report\n       an error if the other end suddenly crashes. The same flag doesn't seem to be\n       activated on Mac */\n    if ((pending == SOCK_ERR) || \n        (PollReadFd[0].revents & POLLERR))\n    #endif\n    {\n        retVal = RTIOSTREAM_ERROR;\n    }\n\n    *outPending = (pending==1) && (retVal == RTIOSTREAM_NO_ERROR);\n    return(retVal);    \n\n} /* end socketDataPending */ \n\n/* Function: initialUDPServerRecvfrom =====================================================\n * Abstract:\n *  Reads data from the client via \"recvfrom\" into the UDP packet buffer.\n *  The client sockaddr is returned via clientSA and clientSALen.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n */\nstatic int initialUDPServerRecvfrom(ConnectionData * connection,\n                                    struct sockaddr * clientSA,\n                                    rtiostream_socklen_t * clientSALen) {\n   int nRead;\n   int retVal;\n   UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n   /* reset */ \n   resetUDPPacketBuffer(udpPacketBuffer);\n   /* initialize ahead of call to recvfrom */\n   *clientSALen = sizeof(*clientSA);\n   /* read into UDP buffer from the listenSock\n    * and get sockaddr of the client */\n   nRead = recvfrom(connection->serverData->listenSock, \n         udpPacketBuffer->dataPtr, \n                    (size_t)connection->udpData->maxPacketSize, \n         0U, \n         clientSA, \n         clientSALen);\n\n   if (nRead == SOCK_ERR) {\n      retVal = RTIOSTREAM_ERROR;\n   } else {\n      /* set dataAvail */\n      udpPacketBuffer->dataAvail = nRead;\n      /* handle optional sequence number */\n      retVal = processUDPRecvSeqNum(connection);\n   }\n   return retVal;\n}\n\n/* Function: processUDPRecvSeqNum =====================================================\n * Abstract:\n *  Processes sequence numbers in received UDP datagrams.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n */\nstatic int processUDPRecvSeqNum(ConnectionData * connection) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n   if (connection->udpData->isUsingSeqNum) {\n      UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n      /* process sequence number */\n      udpSeqNum_T recvSeqNum;\n      if (udpPacketBuffer->dataAvail < UDP_SEQ_NUM_SIZE) {\n         printf(\"No receive sequence number found.\\n\");\n         retVal = RTIOSTREAM_ERROR;\n         return retVal; \n      }\n      /* read sequence number from the buffer \n       *\n       * sequence number is always transmitted / received in \n       * host Endian */\n      memcpy(&recvSeqNum,\n            udpPacketBuffer->dataPtr,\n            UDP_SEQ_NUM_SIZE);\n      udpPacketBuffer->dataPtr += UDP_SEQ_NUM_SIZE;\n      udpPacketBuffer->dataAvail -= UDP_SEQ_NUM_SIZE;\n      if (connection->verbosity) {\n        printf(\"Received UDP packet with sequence number: %u\\n\", recvSeqNum);\n      }\n      if (connection->udpData->resetExpectedRecvSeqNum) {\n         /* reset the expected sequence number */\n         connection->udpData->expectedRecvSeqNum = recvSeqNum + 1;\n         connection->udpData->resetExpectedRecvSeqNum = 0;\n      }\n      else {\n         /* compare with expected receive seq num */\n         if (recvSeqNum != connection->udpData->expectedRecvSeqNum) {\n            printf(\"UDP packet sequence number mismatch. Expected #: %u, Actual #: %u\\n\", \n                  connection->udpData->expectedRecvSeqNum, recvSeqNum);\n            retVal = RTIOSTREAM_ERROR;\n         } \n         else {\n            /* increment expected receive seq num */\n            connection->udpData->expectedRecvSeqNum++;\n         }\n      }\n   }\n   return retVal;\n}\n\n/* Function: socketDataGet =====================================================\n * Abstract:\n *  Attempts to gets the specified number of bytes from the specified socket.\n *  The number of bytes read is returned via the 'sizeRecvd' parameter.\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n *\n * NOTES:\n *  o it is not an error for 'sizeRecvd' to be returned as 0\n *  o this function blocks if no data is available\n */\nstatic int socketDataGet(ConnectionData * connection,\n    char          *dst,\n    const size_t   size,\n    size_t        *sizeRecvd)\n{\n    int nRead = 0;\n    int retVal = RTIOSTREAM_NO_ERROR; \n    /* Ensure size is not out of range for socket API recv function */\n    int sizeLim = (int) MIN(size, INT_MAX);\n\n    if (connection->protocol == TCP_PROTOCOL) {\n        nRead = recv(connection->sock, dst, (size_t)sizeLim, 0U);\n       if (nRead == SOCK_ERR) {\n          retVal = RTIOSTREAM_ERROR;\n       } else {\n          retVal = RTIOSTREAM_NO_ERROR;\n       }\n    }\n    else { \n       UDPPacketBuffer * udpPacketBuffer = connection->udpData->recvBuffer;\n       /* receive more data in to the buffer if required */\n       if (udpPacketBuffer->dataAvail == 0) {         \n          /* reset */ \n          resetUDPPacketBuffer(udpPacketBuffer);\n          /* read into buffer */\n          nRead = recv(connection->sock, \n                       udpPacketBuffer->dataPtr, \n                       (size_t)connection->udpData->maxPacketSize, \n                       0U);\n          \n          if (nRead == SOCK_ERR) {\n             retVal = RTIOSTREAM_ERROR;\n          } else {\n             udpPacketBuffer->dataAvail = nRead;\n             /* handle optional sequence number */\n             retVal = processUDPRecvSeqNum(connection);             \n             if (retVal == RTIOSTREAM_ERROR) {\n                return retVal;\n             }\n          }\n       }\n       /* get data from the buffer */\n       /* for the special case where we request a  */\n       /* size of 0 bytes, return the whole buffer */\n       if (udpPacketBuffer->dataAvail) {\n          if (size == 0) {\n            nRead = udpPacketBuffer->dataAvail;\n          } else {\n            nRead = MIN(udpPacketBuffer->dataAvail, sizeLim);\n          }\n          memcpy(dst, (void *) udpPacketBuffer->dataPtr, (size_t)nRead);\n          udpPacketBuffer->dataAvail -= nRead;\n          udpPacketBuffer->dataPtr += nRead;\n       }\n    }\n\n    if (retVal!=RTIOSTREAM_ERROR) {\n        *sizeRecvd = (size_t) nRead;\n    }\n\n    return retVal;\n} /* end socketDataGet */ \n\n\n/* Function: socketDataSet =====================================================\n * Abstract:\n *  Utility function to send data via the specified socket\n */\nstatic int socketDataSet(\n    ConnectionData * connection,\n    const void *src,\n    const size_t size,\n    size_t *sizeSent)\n{\n    int nSent;    \n    int retVal = RTIOSTREAM_NO_ERROR;\n    const void *sendSrc = src;    \n\n    /* Ensure size is not out of range for socket API send function */\n    int sizeLim = (int) MIN(size, INT_MAX);\n\n    if (connection->protocol == UDP_PROTOCOL) {\n       /* limit sends according to max packet size */\n       int maxPacketSize = connection->udpData->maxPacketSize;\n       if (connection->udpData->isUsingSeqNum) {          \n          int transferAmount;\n          UDPPacketBuffer * udpPacketBuffer = connection->udpData->sendBuffer;\n          /* need to apply sequence number and then increment it */\n          resetUDPPacketBuffer(udpPacketBuffer); \n          /* set data src */          \n          sendSrc = udpPacketBuffer->dataPtr;\n          /* add sequence number to the buffer \n           *\n           * sequence number is always transmitted / received in \n           * host Endian */\n          memcpy(udpPacketBuffer->dataPtr, \n                 &connection->udpData->sendSeqNum,\n                 UDP_SEQ_NUM_SIZE);\n          udpPacketBuffer->dataPtr += UDP_SEQ_NUM_SIZE;\n          udpPacketBuffer->dataAvail += UDP_SEQ_NUM_SIZE;                \n          /* copy the data - don't overflow the packet buffer */\n          transferAmount = MIN(sizeLim, maxPacketSize - udpPacketBuffer->dataAvail);\n          memcpy(udpPacketBuffer->dataPtr,\n                 src, \n                 (size_t)transferAmount);\n          udpPacketBuffer->dataAvail += transferAmount;                                   \n          sizeLim = udpPacketBuffer->dataAvail;\n       }\n       else {\n          sizeLim = MIN(maxPacketSize, sizeLim);\n       }\n    }\n\n    nSent = send(connection->sock, (send_buffer_t)sendSrc, (size_t)sizeLim, 0);\n    if (nSent == SOCK_ERR) {\n        retVal = RTIOSTREAM_ERROR;\n    } else { \n        if ((connection->protocol == UDP_PROTOCOL) &&\n            (connection->udpData->isUsingSeqNum) && \n            (nSent > 0)) {\n           if (nSent < (int) UDP_SEQ_NUM_SIZE) {\n              /* expected the sequence number to have transmitted */\n              retVal = RTIOSTREAM_ERROR;\n              return retVal;\n           }\n           else {\n              if (connection->verbosity) {\n                 printf(\"Sent UDP packet with sequence number: %u\\n\", connection->udpData->sendSeqNum);\n              }\n              /* increment sequence number */\n              connection->udpData->sendSeqNum++;\n              nSent -= UDP_SEQ_NUM_SIZE;\n           }          \n        }\n        *sizeSent = (size_t)nSent;\n    }\n\n    return retVal;\n}\n\n/* Function: serverStreamRecv =================================================\n * Abstract:\n *  Send data from the server-side\n */\nstatic int serverStreamRecv( \n    ConnectionData * connection, \n    void * dst,\n    size_t size,\n    size_t * sizeRecvd)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    *sizeRecvd = 0;\n\n    if (connection->sock == INVALID_SOCKET) {\n       /* Attempt to open connection */\n       serverAcceptSocket(connection);\n    }\n\n    if (connection->sock != INVALID_SOCKET) {\n        int pending;\n        if (connection->blockingRecvTimeout != BLOCKING_RECV_TIMEOUT_NEVER) {\n           /* only call costly \"select\" if necessary */\n           retVal = socketDataPending(connection->sock, \n                                      connection,\n                                      &pending, \n                                      connection->blockingRecvTimeout);\n        }\n        else {\n           /* block in \"recv\" if necessary */\n           pending = 1;\n        }\n\n        if ( (pending !=0) && (retVal==RTIOSTREAM_NO_ERROR) && (size>0) ) {\n           \n            retVal = socketDataGet(connection, (char *)dst, size, sizeRecvd);\n            \n            if (*sizeRecvd == 0) {\n                \n                if (errno == RTIOSTREAM_ECONNRESET) {\n                    /* If we are closing the connection and we received this\n                     * error, it means the other side of the connection was\n                     * already closed.  Since we are expecting this, we can\n                     * ignore this particular error.\n                     */\n                    retVal = RTIOSTREAM_NO_ERROR;\n                } else {\n                    /* Connection closed gracefully by client */\n                }\n\n                close(connection->sock);\n                connection->sock = INVALID_SOCKET;\n            }\n        }\n        \n        if ( retVal == RTIOSTREAM_ERROR ) {\n            close(connection->sock);\n            connection->sock = INVALID_SOCKET;\n        }\n    }\n\n    return retVal;\n}\n\n/* Function: serverOpenSocket =================================================\n * Abstract:\n *  Opens the listening socket to be used for accepting an incoming connection.\n */\nstatic SOCKET serverOpenSocket(int port, char * serverInfoFile, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize)\n{\n\n    struct sockaddr_in serverAddr;\n    int sockStatus;\n    rtiostream_socklen_t sFdAddSize     = (rtiostream_socklen_t) sizeof(struct sockaddr_in);\n    SOCKET lFd;\n    int option;     \n\n    /*\n    * Create a TCP or UDP based socket.\n    */\n    memset((void *) &serverAddr,0,(size_t)sFdAddSize);\n    serverAddr.sin_family      = AF_INET;\n    serverAddr.sin_port        = htons((unsigned short int) port);\n    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    if (protocol == TCP_PROTOCOL) {\n        lFd = socket(AF_INET, SOCK_STREAM, 0);\n    }\n    else {\n        lFd = socket(AF_INET, SOCK_DGRAM, 0);\n    }\n    \n    if (lFd == INVALID_SOCKET) {\n        printf(\"socket() call failed.\\n\");\n    } else {\n        /*\n        * Listening socket should always use the SO_REUSEADDR option\n        * (\"Unix Network Programming - Networking APIs:Sockets and XTI\",\n        *   Volume 1, 2nd edition, by W. Richard Stevens).\n        */\n        option = 1;\n        sockStatus = \n            setsockopt(lFd,SOL_SOCKET,SO_REUSEADDR,(char*)&option,sizeof(option));\n        if (sockStatus == SOCK_ERR) {\n            printf(\"setsocketopt() call failed.\\n\");\n            close(lFd);\n            lFd = INVALID_SOCKET;\n        }\n        if (protocol == TCP_PROTOCOL)\n        {     \n            if (lFd != INVALID_SOCKET)\n            {\n                /* Disable Nagle's Algorithm*/ \n                option = 1;\n                sockStatus = \n                    setsockopt(lFd,IPPROTO_TCP,TCP_NODELAY,(char*)&option,sizeof(option));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() TCP_NODELAY call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                }\n            }\n        } \n        if (protocol == UDP_PROTOCOL)\n        {\n            if (lFd != INVALID_SOCKET)\n            {\n\n                /* increase the UDP socket send size to increase the \n                * transfer rate */\n                sockStatus = \n                    setsockopt(lFd, SOL_SOCKET, SO_SNDBUF,(char*)&udpSendBufSize, sizeof(int));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() SO_SNDBUF call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                }   \n            }\n\n            if (lFd != INVALID_SOCKET)\n            {\n                /* increase the UDP socket receive size to decrease the \n                * possibility of buffer overflow */\n                sockStatus = \n                    setsockopt(lFd, SOL_SOCKET, SO_RCVBUF,(char*)&udpRecvBufSize, sizeof(int));\n                if (sockStatus == SOCK_ERR) { \n                    printf(\"setsocketopt() SO_RCVBUF call failed.\\n\");\n                    close(lFd); \n                    lFd = INVALID_SOCKET; \n                } \n            }\n        }\n    }\n\n    if (lFd != INVALID_SOCKET) {\n        sockStatus = bind(lFd, (struct sockaddr *) &serverAddr, sFdAddSize);\n        if (sockStatus == SOCK_ERR) {\n            printf(\"bind() call failed: %s\\n\", strerror(errno));\n            close(lFd);\n            lFd = INVALID_SOCKET;\n        }\n    }\n\n    if (lFd != INVALID_SOCKET) {\n        if (port == 0) {\n            /* port 0 specifies dynamic free port allocation\n            * reuse serverAddr to store the actual address / port */\n            sockStatus = getsockname(lFd, (struct sockaddr *) &serverAddr, &sFdAddSize);           \n            if (sockStatus == SOCK_ERR) {\n                fprintf(stderr,\"getsockname() call failed: %s\\n\", strerror(errno));\n                close(lFd);\n                lFd = INVALID_SOCKET;               \n            } else { \n                if(serverInfoFile != NULL) {\n                    FILE* fh;\n                    uint16_T serverPortNo;\n                    int fprintfErr = 0;\n                    int fcloseErr = 0;\n                    \n                    /* Open file in append mode to save info already stored in the file*/\n                    fh = fopen(serverInfoFile,\"a\"); \n#ifdef __LCC64__\n                    /* This is needed due to an issue with LCC64, see the following geck:  g919889 */\n                    fseek ( fh, 0 , SEEK_END );\n#endif\n                    if (fh == NULL) {\n                        fprintf(stderr,\"Unable to open output file to write server port number: %s\\n\", strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n\n                    serverPortNo = ntohs(serverAddr.sin_port);\n                    fprintfErr = fprintf(fh, \"Server Port Number: %d\\n\", serverPortNo);\n                    if (fprintfErr < 0) {\n                        fprintf(stderr,\"Server port number is: %d\\nUnable to write server port number to output file: %s\\n\",\n                                serverPortNo, strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n                    \n                    fcloseErr = fclose(fh);\n                    if (fcloseErr == EOF) {\n                        fprintf(stderr,\"Server port number is: %d\\nUnable to close output file after writing server port number: %s\\n\", \n                                serverPortNo ,strerror(errno));\n                        lFd = INVALID_SOCKET;\n                    }\n                    \n                } else {\n                    /* write the server port number to stdout */\n                    SERVER_PORT_PRINTF(\"Server Port Number: %d\\n\", ntohs(serverAddr.sin_port));\n                }\n            }                 \n        }\n    }\n    if (protocol == TCP_PROTOCOL) {\n        if (lFd != INVALID_SOCKET) {\n            sockStatus = listen(lFd, 2);\n            if (sockStatus == SOCK_ERR) {\n                printf(\"listen() call failed.\\n\");\n                close(lFd);\n                lFd = INVALID_SOCKET;\n            }\n        }\n    }\n    return lFd;\n}\n/* Function: serverAcceptSocket =================================================\n * Abstract:\n *  Called when the target is not currently connected to the host, this \n *  function attempts to open the connection.  \n *\n *  In the case of sockets, this is a passive operation in that the host\n *  initiates contact, the target simply listens for connection requests.\n *\n * NOTES:\n \n * Blocks according to blockingRecvTimeout. When\n * polling, there may be no open requests pending.  In this case, this\n * function returns without making a connection; this is not an error.\n */\nstatic void serverAcceptSocket(ConnectionData * connection)\n{\n   struct sockaddr_in clientAddr;\n   rtiostream_socklen_t     sFdAddSize     = sizeof(struct sockaddr_in);\n   SOCKET  cFd            = INVALID_SOCKET;\n   int error             = RTIOSTREAM_NO_ERROR;\n   int pending;    \n\n   /* Check that the listening socket is still valid and open a new socket if\n    * not */\n   if (connection->serverData->listenSock == INVALID_SOCKET) {\n      connection->serverData->listenSock = serverOpenSocket(connection->serverData->port,\n            connection->serverData->serverInfoFile, \n            connection->protocol,\n            connection->udpSendBufSize, connection->udpRecvBufSize);\n   }\n\n   /* pass listenSock rather than sock */\n   error = socketDataPending(connection->serverData->listenSock, \n         connection,\n         &pending, \n         connection->blockingRecvTimeout);\n\n   if ( (pending > 0) && (error==RTIOSTREAM_NO_ERROR) ) {\n      if (connection->protocol == TCP_PROTOCOL) {\n         /*\n          * Wait to accept a connection on the comm socket.\n          */\n         cFd = accept(connection->serverData->listenSock, \n                     (struct sockaddr *)&clientAddr,\n                     &sFdAddSize);\n\n         if (cFd == INVALID_SOCKET) {\n            printf(\"accept() for comm socket failed.\\n\");\n            error = RTIOSTREAM_ERROR;\n         } \n\n         if (error == RTIOSTREAM_ERROR) {\n            close(connection->serverData->listenSock);\n            connection->serverData->listenSock = INVALID_SOCKET;\n         } \n      }\n      else {\n         /* UDP - data is pending */\n         struct sockaddr clientSA;\n         rtiostream_socklen_t clientSALen;\n         /* new connection, make sure we reset expectedRecvSeqNum, \n          * if sequence numbers are in use */\n         connection->udpData->resetExpectedRecvSeqNum = 1;\n         /* Do the initial UDP server \"recvfrom\" to get the \n          * client sockaddr.   Data read will be placed \n          * ready in the UDP packet buffer. */\n         error = initialUDPServerRecvfrom(connection, &clientSA, &clientSALen); \n         if (error == RTIOSTREAM_ERROR) {\n            close(connection->serverData->listenSock);\n            connection->serverData->listenSock = INVALID_SOCKET;\n            printf(\"initialUDPServerRecvfrom() failed.\\n\");\n         }\n         else {\n            /* connect exclusively to the client so we no longer\n             * have to use recvfrom / sendto */\n            if (connect(connection->serverData->listenSock, \n                        &clientSA, \n                        clientSALen) == SOCK_ERR) {\n               close(connection->serverData->listenSock);\n               connection->serverData->listenSock = INVALID_SOCKET;\n               printf(\"Server connect() failed.\\n\");\n            } \n         } \n         /* for UDP, the socket and listening socket are the same */\n         cFd = connection->serverData->listenSock;\n      }\n   }\n   /* set sock */\n   connection->sock = cFd;\n} \n\n\n/* Function: nameLookup =======================\n * Lookup target network name.\n */\n#if (!defined(VXWORKS))\nstatic unsigned long nameLookup(char * hostName) {\n\n    struct hostent * hp = NULL;\n    struct in_addr * iaddr = NULL;\n    unsigned long addr = INADDR_NONE;\n\n    /*\n     * Default to localhost if hostname not specified.\n     */\n    if (hostName == NULL) {\n        static char localhost[] = \"localhost\";\n        hostName = localhost;\n    }\n    \n    /*\n     * See if the address is an IPV4 dot separated address:\n     */\n    addr = inet_addr(hostName);\n\n    if (addr == INADDR_NONE) {\n        /* Since the address is not an IPV4 dot separated address, \n         * do a name lookup to get this: \n         */\n        hp = gethostbyname(hostName);\n        if (hp == NULL) {\n          printf(\"gethostbyname() call failed.\\n\");\n  \t  addr = INADDR_NONE;\n        } else {\n          iaddr = (struct in_addr *) hp->h_addr;\n          addr = iaddr->s_addr;\n        }\n    }\n    return(addr);\n}\n#endif\n\n/* Function: processArgs ====================================================\n * Abstract:\n *  Process the arguments specified by the user when opening the rtIOStream.\n *      \n *  If any unrecognized options are encountered, ignore them.\n *\n * Returns zero if successful or RTIOSTREAM_ERROR if \n * an error occurred.\n *\n *  o IMPORTANT!!!\n *    As the arguments are processed, their strings should be NULL'd out in\n *    the argv array. \n */\nstatic int processArgs(\n    const int         argc,\n    void            * argv[],\n    char           ** hostName, \n    unsigned int    * portNum,\n    unsigned int    * isClient,\n    int             * isBlocking,\n    int             * recvTimeout, \n    char           ** serverInfoFile, \n    CommsProtocol   * protocol, \n    int             * maxPacketSize, \n    VerbosityLevel  * verbosity, \n    int             * isUsingSeqNum,\n    int             * udpSendBufSize,\n    int             * udpRecvBufSize)\n{\n    int        retVal    = RTIOSTREAM_NO_ERROR;\n    int        count           = 0;\n\n    while(count < argc) {\n        const char *option = (char *)argv[count];\n        count++;\n\n        if (option != NULL) {\n\n            if ((strcmp(option, \"-hostname\") == 0) && (count != argc)) {\n\n                *hostName = (char *)argv[count];\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-port\") == 0) && (count != argc)) {\n                char       tmpstr[2];\n                int itemsConverted;\n                const char *portStr = (char *)argv[count];\n\n                count++;     \n                \n                itemsConverted = sscanf(portStr,\"%d%1s\", (int *) portNum, tmpstr);\n                if ( (itemsConverted != 1) || \n                     ( ((*portNum != 0) && (*portNum < 255)) || (*portNum > 65535)) \n                    ) {\n                    \n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n                }           \n                \n            } else if ((strcmp(option, \"-client\") == 0) && (count != argc)) {\n                \n                *isClient = ( strcmp( (char *)argv[count], \"1\") == 0 );\n\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-blocking\") == 0) && (count != argc)) {\n                \n                *isBlocking = ( strcmp( (char *)argv[count], \"1\") == 0 );\n\n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n\n            } else if ((strcmp(option, \"-verbose\") == 0) && (count != argc)) {\n                int verbosityVal;\n                int itemsConverted;\n                const char *verbosityStr = (char *)argv[count];\n                count++;\n                itemsConverted = sscanf(verbosityStr,\"%d\", &verbosityVal);\n\n                if ((itemsConverted != 1) || (verbosityVal < 0)) {\n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n                    *verbosity = (VerbosityLevel) verbosityVal;\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n               }\n\n            } else if ((strcmp(option, \"-recv_timeout_secs\") == 0) && (count != argc)) {\n                char       tmpstr[2];\n                int itemsConverted;\n                const char *timeoutSecsStr = (char *)argv[count];\n\n                count++;     \n                \n                itemsConverted = sscanf(timeoutSecsStr,\"%d%1s\", (int *) recvTimeout, tmpstr);\n                if ( itemsConverted != 1 ) {\n                    retVal = RTIOSTREAM_ERROR;\n                } else {\n\n                    argv[count-2] = NULL;\n                    argv[count-1] = NULL;\n                }           \n\n            } else if((strcmp(option, \"-server_info_file\") == 0) && (count != argc)) {\n                *serverInfoFile= (char *) argv[count];\n                \n                count++;\n                argv[count-2] = NULL;\n                argv[count-1] = NULL;\n            } else if ((strcmp(option, \"-protocol\") == 0) && (count != argc)) {\n              char * protocolStr = (char *) argv[count];\n              count++;\n              argv[count-2] = NULL;\n              argv[count-1] = NULL;\n              /* initialize dependent properties */\n              *isUsingSeqNum = 0;\n              /* process protocolStr */\n              if (strcmp(protocolStr, TCP_PROTOCOL_STRING) == 0) {\n                 *protocol = TCP_PROTOCOL;                \n              }\n              else if (strcmp(protocolStr, UDP_PROTOCOL_STRING) == 0) {\n                 *protocol = UDP_PROTOCOL;\n              }\n              else if (strcmp(protocolStr, UDP_PACKET_LOSS_DETECTON_PROTOCOL_STRING) == 0) {\n                 *protocol = UDP_PROTOCOL;\n                 /* enable sequence number protocol */\n                 *isUsingSeqNum = 1;\n              }\n              else {\n                 /* unrecognized protocol */\n                 retVal = RTIOSTREAM_ERROR;\n              }            \n            } else if ((strcmp(option, \"-udpmaxpacketsize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *maxUPDSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(maxUPDSizeStr,\"%d%1s\", maxPacketSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n             }else if ((strcmp(option, \"-udpsendbuffersize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *udpSendBufSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(udpSendBufSizeStr,\"%d%1s\", udpSendBufSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n           }else if ((strcmp(option, \"-udpreceivebuffersize\") == 0) && (count != argc)) {\n               char       tmpstr[2];\n               int itemsConverted;\n               const char *udpRecvBufSizeStr = (char *)argv[count];\n\n               count++;     \n\n               itemsConverted = sscanf(udpRecvBufSizeStr,\"%d%1s\", udpRecvBufSize, tmpstr);\n               if ( itemsConverted != 1 ) {\n                  retVal = RTIOSTREAM_ERROR;\n               } else {\n                  argv[count-2] = NULL;\n                  argv[count-1] = NULL;\n               } \n            } else {\n                /* issue a warning for the unexpected argument: exception \n                 * is first argument which might be the executable name (\n                 * SIL/PIL and extmode use-cases). */\n                if ((count!=1) || (strncmp(option, \"-\", 1)==0)) {\n                    printf(\"The argument '%s' passed to rtiostream_tcpip is \"\n                            \"not valid and will be ignored.\\n\", option);\n                }\n            }\n        }\n    }\n    return retVal;\n}\n\n/* Function: clientOpenSocket =================================================\n * Abstract:\n *  Open a connection as Client\n */\n#if (!defined(VXWORKS))\nstatic SOCKET clientOpenSocket(char * hostName, unsigned int portNum, CommsProtocol protocol, int udpSendBufSize, int udpRecvBufSize) {\n    \n    struct sockaddr_in sa;\n    unsigned long addr = INADDR_NONE;\n    int errStatus = RTIOSTREAM_NO_ERROR;\n    SOCKET cSock = INVALID_SOCKET;\n\n    addr = nameLookup(hostName);\n\n    if (addr!=INADDR_NONE) {\n        \n         sa.sin_addr.s_addr = addr;\n         sa.sin_family = AF_INET; /*hp->h_addrtype;*/\n         sa.sin_port   = htons((unsigned short) portNum);\n\n        /*\n         * Create the sockets & make connections.\n         */\n        if (protocol == TCP_PROTOCOL) {\n           cSock = socket(PF_INET,SOCK_STREAM,0);\n        } \n        else {\n           cSock = socket(PF_INET,SOCK_DGRAM,0);\n        }\n        \n        if (cSock == INVALID_SOCKET) {\n            errStatus = RTIOSTREAM_ERROR;\n            printf(\"socket() call failed for comm socket.\\n\");\n        }\n    } else {\n      errStatus = RTIOSTREAM_ERROR;\n    }\n \n    if (protocol == UDP_PROTOCOL)\n    {\n        if (errStatus!=RTIOSTREAM_ERROR)\n        {\n            /* increase the UDP socket send size to increase the \n            * transfer rate */\n           int sockStatus = \n                setsockopt(cSock, SOL_SOCKET, SO_SNDBUF,(char*)&udpSendBufSize, sizeof(int));\n           if (sockStatus == SOCK_ERR) { \n              printf(\"setsocketopt() SO_SNDBUF call failed.\\n\");\n              cSock = INVALID_SOCKET;\n              errStatus = RTIOSTREAM_ERROR;\n           }    \n        }\n        if (errStatus!=RTIOSTREAM_ERROR)\n        {\n            /* increase the UDP socket receive size to decrease the \n            * possibility of buffer overflow */\n           int sockStatus = \n                setsockopt(cSock, SOL_SOCKET, SO_RCVBUF,(char*)&udpRecvBufSize, sizeof(int));\n           if (sockStatus == SOCK_ERR) { \n              printf(\"setsocketopt() SO_RCVBUF call failed.\\n\");\n              cSock = INVALID_SOCKET;\n              errStatus = RTIOSTREAM_ERROR;\n           } \n       }\n    }\n\n    if (errStatus!=RTIOSTREAM_ERROR) {\n        if (connect(cSock, (struct sockaddr *)&sa, sizeof(sa)) == SOCK_ERR) {\n            char tmp[1024];\n\n            sprintf(tmp,\n                    \"Attempting to establish connection with hostname '%s' \"\n                    \"through port %d.\\n\", \n                    hostName,\n                    ntohs(sa.sin_port));\n            cSock = INVALID_SOCKET;\n            printf(\"%s\",tmp);\n        } \n    }\n\n    return cSock;\n}\n#endif\n\n/* Function: waitForClientClose =============================================\n * Abstract:\n *\n * Allow the client to close its end of the socket connection before the server\n * closes its own socket.\n *\n * The server will receive any outstanding data on the socket.   When the server\n * receives 0 bytes, it indicates that it has acknowledged that the client \n * is closing its socket (this is essential for the client to complete\n * closing its socket without error) or that it timed out waiting for the client to \n * close its socket.\n *\n */\nstatic int waitForClientClose(ConnectionData * connection) {\n   int retVal = RTIOSTREAM_NO_ERROR;\n#define TMP_BUF_SIZE (40)\n   char * tmpBuf[TMP_BUF_SIZE];\n   size_t numRecvd;          \n   /* cache the original blockingRecvTimeout */\n   int savedBlockingRecvTimeout = connection->blockingRecvTimeout;      \n   /* wait time for client to close its socket */\n   connection->blockingRecvTimeout = BLOCKING_RECV_TIMEOUT_SOCK_SHUTDOWN;\n   do {         \n      retVal = serverStreamRecv(connection, (void *) tmpBuf, TMP_BUF_SIZE, &numRecvd);\n   } while ((numRecvd > 0) && (retVal == RTIOSTREAM_NO_ERROR));\n   /* restore blockingRecvTimeout */\n   connection->blockingRecvTimeout = savedBlockingRecvTimeout;\n#undef TMP_BUF_SIZE\n   return retVal;\n}\n\n/***************** VISIBLE FUNCTIONS ******************************************/\n\n/* Function: rtIOStreamOpen =================================================\n * Abstract:\n *  Open the connection with the target.\n */\nint rtIOStreamOpen(int argc, void * argv[])\n{\n    char               *xHostName = NULL; /* default */\n    char               *serverInfoFile = NULL; /* default */\n    unsigned int        xPortNum     = (SERVER_PORT_NUM); /* default */\n    unsigned int        isClient = 0; /* default */\n    CommsProtocol       protocol = DEFAULT_PROTOCOL;\n    int                 isBlockingRecv = EXT_BLOCKING; /* default */\n    int                 blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT; /* rogue value */\n    int                 maxPacketSize = DEFAULT_MAX_UDP_PACKET_SIZE;\n    VerbosityLevel      verbosity = DEFAULT_VERBOSITY;\n    int                 isUsingSeqNum = DEFAULT_IS_USING_SEQ_NUM;\n    int                 udpSendBufSize = DEFAULT_UDP_SOCKET_SEND_SIZE_REQUEST;\n    int                 udpRecvBufSize = DEFAULT_UDP_SOCKET_RECEIVE_SIZE_REQUEST;\n    int result = RTIOSTREAM_NO_ERROR;\n    int streamID;\n    SOCKET sock = INVALID_SOCKET;\n\n    /* determine the streamID for this new connection */\n    streamID = getConnectionID();\n    if (streamID == RTIOSTREAM_ERROR) {\n       result = RTIOSTREAM_ERROR;\n       return result;\n    }\n\n    result = processArgs(argc, argv, \n                         &xHostName, \n                         &xPortNum, \n                         &isClient, \n                         &isBlockingRecv,\n                         &blockingRecvTimeout, \n                         &serverInfoFile, \n                         &protocol, \n                         &maxPacketSize, \n                         &verbosity, \n                         &isUsingSeqNum,\n                         &udpSendBufSize,\n                         &udpRecvBufSize);\n\n    if (result == RTIOSTREAM_ERROR) {\n       return result;\n    }\n\n    if (verbosity) {\n       printf(\"rtIOStreamOpen\\n\");\n    }\n\n    if (isBlockingRecv) {\n       /* blocking: if blockingRecvTimeout has not been set, initialize to the client or\n        * server specific default */\n       if ((blockingRecvTimeout == DEFAULT_BLOCKING_RECV_TIMEOUT) ||\n           (blockingRecvTimeout < BLOCKING_RECV_TIMEOUT_10MS)) {\n          if (isClient) {\n             blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_CLIENT;\n          }\n          else {\n             blockingRecvTimeout = DEFAULT_BLOCKING_RECV_TIMEOUT_SECS_SERVER;\n          }\n       }\n    }\n    else {\n       /* not blocking: set the timeout to return immediately */\n       blockingRecvTimeout = BLOCKING_RECV_TIMEOUT_NOWAIT;\n    }\n\n#ifdef VXWORKS /* UDP is not supported on VxWorks */\n    if (protocol == UDP_PROTOCOL) {\n       result = RTIOSTREAM_ERROR;\n       return result;\n    }\n#endif\n\n#ifdef _WIN32\n    {\n        WSADATA data;\n        if (WSAStartup((MAKEWORD(1,1)), &data)) {\n            result = RTIOSTREAM_ERROR;\n            printf(\"WSAStartup() call failed.\\n\");\n        }\n    }\n#endif\n\n    if (result != RTIOSTREAM_ERROR) { /* polyspace DEFECT:USELESS_IF [Not a defect:Unset] \"Needed for Windows\" */\n        if (isClient == 1) {\n#if (!defined(VXWORKS)) /* Client side connection not supported on VxWorks */\n            sock = clientOpenSocket(xHostName, xPortNum, protocol,udpSendBufSize,udpRecvBufSize);\n            if (sock == INVALID_SOCKET) {\n            result = RTIOSTREAM_ERROR;\n            }\n#endif\n        } else {           \n            sock = serverOpenSocket((int)xPortNum, serverInfoFile, protocol,udpSendBufSize,udpRecvBufSize);            \n            if (sock == INVALID_SOCKET) {\n                result = RTIOSTREAM_ERROR;\n            }\n        }\n    }\n\n    if (result != RTIOSTREAM_ERROR) {\n       int isServer;\n       if (isClient == 1) {\n          isServer = 0;   \n       }\n       else {\n          isServer = 1;\n       }\n       result = initConnectionData(streamID, \n             isServer, \n             protocol, \n             sock, \n             blockingRecvTimeout,\n             maxPacketSize, \n             (int)xPortNum, \n             serverInfoFile, \n             verbosity, \n             isUsingSeqNum,\n             udpSendBufSize,\n             udpRecvBufSize);\n    }\n    \n    if (result != RTIOSTREAM_ERROR) {\n       result = streamID;\n    }\n    else {\n       if (sock != INVALID_SOCKET) {\n          /* cleanup */\n          close(sock);\n       }\n    }\n    return result;\n}\n\n/* Function: rtIOStreamSend =====================================================\n * Abstract:\n *  Sends the specified number of bytes on the comm line. Returns the number of\n *  bytes sent (if successful) or a negative value if an error occurred. As long\n *  as an error does not occur, this function is guaranteed to set the requested\n *  number of bytes; the function blocks if tcpip's send buffer doesn't have\n *  room for all of the data to be sent\n */\nint rtIOStreamSend(\n    int streamID,\n    const void *src,\n    size_t size,\n    size_t *sizeSent)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n    *sizeSent = 0;\n\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->isServer) {\n        if (connection->sock == INVALID_SOCKET) {\n            serverAcceptSocket(connection);\n        }\n\n        if (connection->sock != INVALID_SOCKET) {\n#ifndef VXWORKS\n           retVal = socketDataSet(connection, src, size, sizeSent);\n#else           \n           /*\n            * VXWORKS send prototype does not have src as const.  This suppresses\n            * the compiler warning.\n            */\n\n           retVal = socketDataSet(connection, (char *)src, size, sizeSent);\n#endif\n        }\n    } else { /* Client stream */\n        retVal = socketDataSet(connection, src, size, sizeSent);\n    }\n\n    if (connection->verbosity) {\n        if ((*sizeSent > 0) || (connection->verbosity >= VERBOSITY_LEVEL_2)) {\n            size_t currElement;\n            printf(\"rtIOStreamSend (connection id %d): size = %lu, sizeSent = %lu: \", \n                   streamID, \n                   (unsigned long) size, \n                   (unsigned long) *sizeSent);\n        \n            for (currElement = 0; currElement < *sizeSent; currElement++) {\n                printf(\"%02x \", ((const unsigned char *) src)[currElement]);\n            }\n            printf(\"\\n\");\n        }       \n    }\n\n    return retVal;\n}\n\n\n/* Function: rtIOStreamRecv ================================================\n * Abstract: receive data\n *\n */\nint rtIOStreamRecv(\n    int      streamID,\n    void   * dst, \n    size_t   size,\n    size_t * sizeRecvd) \n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n\n    *sizeRecvd = 0;\n\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->isServer) {\n        retVal = serverStreamRecv(connection, dst, size, sizeRecvd); \n    } else { /* Client stream */\n        int pending;\n        if (connection->blockingRecvTimeout != BLOCKING_RECV_TIMEOUT_NEVER) {\n           /* only call costly \"select\" if necessary */\n           retVal = socketDataPending(connection->sock, \n                                      connection,\n                                      &pending, \n                                      connection->blockingRecvTimeout);\n        }\n        else {\n           /* block in \"recv\" if necessary */\n           pending = 1;\n        }\n        if (pending && (size>0))  {\n            retVal = socketDataGet(connection, (char *)dst, size, sizeRecvd);\n        }\n    }\n\n    if (connection->verbosity) {\n        if ((*sizeRecvd > 0 ) || (connection->verbosity >= VERBOSITY_LEVEL_2)) {\n            size_t currElement;\n            printf(\"rtIOStreamRecv (connection id %d): size = %lu, sizeRecvd = %lu: \", \n                   streamID,\n                   (unsigned long) size,\n                   (unsigned long) *sizeRecvd);\n\n            for (currElement = 0; currElement < *sizeRecvd; currElement++) {\n                printf(\"%02x \", ((const unsigned char *) dst)[currElement]);\n            }\n            printf(\"\\n\");\n        }\n    }\n    \n    return retVal;\n}\n\n/* Function: rtIOStreamClose ================================================\n * Abstract: close the connection.\n *\n */\nint rtIOStreamClose(int streamID)\n{\n    int retVal = RTIOSTREAM_NO_ERROR;\n    ConnectionData * connection = getConnectionData(streamID);\n    if (connection == NULL) {\n       retVal = RTIOSTREAM_ERROR;\n       return retVal;\n    }\n\n    if (connection->verbosity) {\n       printf(\"rtIOStreamClose (connection id %d)\\n\", streamID);\n    }\n\n    if (connection->isServer) {\n        /* Only if the client actually made a connection */\n        if (connection->sock != INVALID_SOCKET) {\n            if (connection->protocol == TCP_PROTOCOL) {\n                /* graceful shutdown */\n                retVal = waitForClientClose(connection);\n            }\n            \n            /* close the socket */\n            close(connection->sock);\n            connection->sock = INVALID_SOCKET;\n        }\n       if (connection->protocol == TCP_PROTOCOL) {\n          /* TCP: additionally close the listening socket\n           *\n           * for UDP, sock and listenSock are the same\n           * socket - avoid closing it twice */\n          close(connection->serverData->listenSock);\n       }\n       /* set to INVALID_SOCKET for all protocol types */\n       connection->serverData->listenSock = INVALID_SOCKET;       \n    } else {\n       SOCKET cSock = connection->sock;\n       close(cSock);\n\n    }\n    freeConnectionData(connection);\n    return retVal;\n}\n\n"},{"name":"rtiostream_utils.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2023a\\toolbox\\coder\\rtiostream\\src\\utils","tag":"","groupDisplay":"Other files","code":"/* Copyright 2012-2013 The MathWorks, Inc. */\n\n#include \"rtiostream_utils.h\"\n\n/* include rtIOStream interface to use */\n#include \"rtiostream.h\" \n\n/* TARGET_CONNECTIVITY_TESTING might be defined by some MathWorks tests for\n * testing purposes only. In this case, we force SIZE_MAX to be 4 so we \n * could test the pointer arithmetic in rtIOStreamBlockingSend and\n * rtIOStreamBlockingRecv.\n */ \n#ifdef TARGET_CONNECTIVITY_TESTING\n    #define SIZE_MAX 4\n#else\n    /* define SIZE_MAX if not already defined (e.g. by a C99 compiler) */\n    #ifndef SIZE_MAX\n        #define SIZE_MAX ((size_t)-1)\n    #endif\n#endif\n\n#ifndef MemUnit_T\n   /* External Mode */\n   typedef unsigned char IOUnit_T; \n#else\n   /* SIL/PIL */\n   #ifdef HOST_WORD_ADDRESSABLE_TESTING\n      /* rtIOStream will handle data in single byte chunks \n       *\n       * uint8_T can be > 8-bits for certain portable word sizes \n       * cases (e.g. C2000) so use native type instead */\n      typedef unsigned char IOUnit_T;\n   #else\n      /* rtIOStream will handle data in MemUnit_T size chunks */\n      typedef MemUnit_T IOUnit_T;\n   #endif\n#endif\n\n/* Blocks until all requested outgoing data is sent */\nint rtIOStreamBlockingSend(const int streamID, \n                           const void * const src, \n                           uint32_T size) {\n\n    size_t transferAmount;\n    size_t sizeSent;\n    int errorCode      = RTIOSTREAM_NO_ERROR;   \n    const IOUnit_T * srcPtr = (const IOUnit_T *) src;\n    \n    /* use a variable to avoid SIZE_MAX being treated as a constant\n     * which leads to compiler warnings for \"MIN\" on platforms where\n     * SIZE_MAX > UINT32_MAX */\n    size_t sizeMax = SIZE_MAX;\n    while (size > 0) {\n        /* support full uint32 size */\n        transferAmount = (size_t) MIN(sizeMax, size);        \n        errorCode = rtIOStreamSend(streamID,\n                                   (const void *) srcPtr,\n                                   transferAmount,\n                                   &sizeSent);\n        if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n        }\n        else {            \n            size -= (uint32_T) sizeSent;\n            srcPtr += sizeSent;\n        }\n    }\n    return errorCode;\n}\n\n/* Blocks until all requested incoming data is received */\nint rtIOStreamBlockingRecv(const int streamID,\n                           void * const dst,\n                           uint32_T size) {\n\n   size_t transferAmount;\n   size_t sizeRecvd;\n   int errorCode      = RTIOSTREAM_NO_ERROR;\n   IOUnit_T * dstPtr = (IOUnit_T *) dst;\n   \n   /* use a variable to avoid SIZE_MAX being treated as a constant\n    * which leads to compiler warnings for \"MIN\" on platforms where \n    * SIZE_MAX > UINT32_MAX */\n   size_t sizeMax = SIZE_MAX;\n   while (size > 0) {\n      /* support full uint32 size */\n      transferAmount = (size_t) MIN(sizeMax, size);      \n      errorCode = rtIOStreamRecv(streamID, \n                                 (void *) dstPtr, \n                                 transferAmount, \n                                 &sizeRecvd);\n      if (errorCode == RTIOSTREAM_ERROR) {\n            return errorCode;\n      }\n      else {          \n         size -= (uint32_T) sizeRecvd;\n         dstPtr += sizeRecvd;\n      }\n   }\n   return errorCode;\n}\n\n\n"},{"name":"updown.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2023a\\rtw\\c\\src\\ext_mode\\common","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 1994-2020 The MathWorks, Inc.\n */\n#include <stdlib.h>\n#include <string.h>\n\n/*Real Time Workshop headers*/\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n#include \"sysran_types.h\"\n\n/* \n * String is dynamic in the following cases\n * - Rapid Accelerator mode\n */\n#ifdef IS_RAPID_ACCEL\n#define MW_DYNAMIC_STRING_SUPPORT\n#endif\n\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n#include \"mwstringutil.h\"\n/* \"assert\" is defined in updown_util.h below */ \n#undef assert\n#endif\n\n/* \n * Note: Local headers should be after external headers\n *       Otherwise, some macros may be re-defined\n *       One example is \"assert\" in updown_util.h\n *       mwstringutil.h inderectly re-define it\n */\n#include \"ext_types.h\"\n#include \"ext_share.h\"\n#include \"ext_svr.h\"\n#include \"ext_work.h\"\n#include \"updown_util.h\"\n#include \"dt_info.h\"\n\n/* DUMP_PKT is defined to be (0) below - why? See g2176068. */\n#if defined(VERBOSE) || (defined(DUMP_PKT) && DUMP_PKT)\n#include <stdio.h>\n#endif\n\n/* \n * Depending on the target's native word size and pointer size, interrupts\n * might need to be disabled around critical regions when accessing the \n * the external mode circular buffer. If, for example, reading a pointer \n * is not guaranteed to be an atomic operation on your target, then you  \n * need to define the preprocessor defines below to prevent interrupts  \n * around the critical regions.\n * \n * Here is a description of each of these preprocessor defines:\n * EXTMODE_PROTECT_CRITICAL_REGIONS: this should be defined if interrupts \n *      should be disabled around critical regions\n * EXTMODE_INTERRUPT_INC_HDR: this defines the include header file \n *      containing the declarations for the enabled/disable interrupts \n *      functions\n * EXTMODE_ENABLE_INTERRUPTS:  this defines the enable interrupts function\n * EXTMODE_DISABLE_INTERRUPTS: this defines the disable interrupts function\n *\n * If you define EXTMODE_PROTECT_CRITICAL_REGIONS, you need to define the \n * other above preprocessor defines, otherwise they are not required.\n */\n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    #if !defined (EXTMODE_INTERRUPT_INC_HDR) || \\\n        !defined (EXTMODE_ENABLE_INTERRUPTS) || \\\n        !defined (EXTMODE_DISABLE_INTERRUPTS)\n        #error EXTMODE_INTERRUPT_INC_HDR, EXTMODE_ENABLE_INTERRUPTS and \\\n               EXTMODE_DISABLE_INTERRUPTS should be defined\n    #endif\n    /* \n     * include header file containing declarations for interrupt \n     * enable/disable functions \n     */    \n    #include EXTMODE_INTERRUPT_INC_HDR\n#endif\n\n/**********************\n * External Variables *\n **********************/\n#ifdef VXWORKS\n# include <sockLib.h>\n# include <inetLib.h>\n# include <selectLib.h>\nextern SEM_ID uploadSem;\n\n#endif\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\nboolean_T host_upstatus_is_uploading = false;\n\n/******************************************************************************\n * Parameter Download                                                         *\n ******************************************************************************/\n\n#ifdef VERBOSE\n/* Function: DType2Real_T ======================================================\n * Convert a built-in data type to a real_T value.  Return the real_T value\n * as well as a string (by reference) corresponding to the original data type.\n * If the data type is not recognized as a Simulink built-in data type, then\n * NULL is returned for the dTypeName and 0 is returned for the dTypeValue.\n */\nPRIVATE double DType2Double(\n    const char              *vPtr,\n    const int               dTypeIdx,\n    const DataTypeTransInfo *dtInfo,\n    const char              **dTypeName)\n{\n    real_T     outVal;\n    char * const *dTypeNames = (char * const *)dtGetDataTypeNames(dtInfo);\n    const char *thisName     = dTypeNames[dTypeIdx];\n\n    *dTypeName = thisName;\n\n    if (strcmp(thisName, \"real_T\") == 0) {\n        outVal = (real_T) (((const real_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"real32_T\") == 0) {\n        outVal = (real_T) (((const real32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int8_T\") == 0) {\n        outVal = (real_T) (((const int8_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint8_T\") == 0) {\n        outVal = (real_T) (((const uint8_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int16_T\") == 0) {\n        outVal = (real_T) (((const int16_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint16_T\") == 0) {\n        outVal = (real_T) (((const uint16_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"int32_T\") == 0) {\n        outVal = (real_T) (((const int32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"uint32_T\") == 0) {\n        outVal = (real_T) (((const uint32_T*)vPtr)[0]);\n    } else if (strcmp(thisName, \"boolean_T\") == 0) {\n        outVal = (real_T) (((const boolean_T*)vPtr)[0]);\n    } else {\n        outVal    = 0;\n        dTypeName = NULL;\n    }\n    return(outVal);\n} /* end DType2Double */\n#endif\n\n\n/* Function: SetParam ==========================================================\n * Install new parameters.\n *\n * NOTE: pbuf looks like:\n *  [NPARAMS\n *   B S W DI DATA   % pVal 0\n *   B S W DI DATA   % pVal 1\n *   B S W DI DATA   % pVal N\n *  ]\n *\n *  No assumptions about the alignment of pbuf may be made.\n *\n *  where,\n *      B   : Data type transition index.  Note that on the target the data\n *            type transition index provides both the base address (B)\n *              of the transition as well as whether or not\n *              that section of the array contains complex elements.\n *      S   : starting offset of the data from the DT_TRANS_IDX\n *      W   : number of elements for this param\n *      DI  : index into rtw data type table (inUse idx)\n *      DATA: the param values (in target format).\n *\n *  and,\n *      All values, excluding DATA, are int32_T.\n */\n#ifndef EXTMODE_DISABLEPARAMETERTUNING\nPUBLIC void SetParam(RTWExtModeInfo  *ei, const char *pbuf)\n{\n    int        i;\n    int32_T    nParams;\n    const char *bufPtr    = pbuf;\n    const int  B          = 0; /* index into dtype tran table (base address)  */\n    const int  SI         = 1; /* starting index - wrt to base address        */\n    const int  W          = 2; /* width of section (number of elements)       */\n    const int  DI         = 3; /* index into data type tables                 */\n    const int  tmpBufSize = sizeof(int32_T) * 4;\n    int32_T    tmpBuf[4];\n\n    const DataTypeTransInfo *dtInfo = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetParamDataTypeTrans(dtInfo);\n    const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n    \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    const char_T* *dtNames = dtGetDataTypeNames(dtInfo);\n#endif\n\n    /* unpack NPARAMS */\n    (void)memcpy(&nParams, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    \n#ifdef VERBOSE\n    printf(\"\\nUpdating %d parameters....\\n\", nParams);\n#endif\n\n    /*\n     * Unpack the data and install the new parameters.\n     */\n    for (i=0; i<nParams; i++) {\n        int_T   elSize;\n        int_T   nBytes;\n        char_T  *start;\n        char_T  *tranAddress;\n        int_T   tranIsComplex;\n\n        /* unpack B SI W DI */\n        (void)memcpy(tmpBuf, bufPtr, tmpBufSize);\n        bufPtr += tmpBufSize;\n\n        /* \n         * Find starting address and size (nBytes) for this parameters \n         * section of memory.\n         */\n        tranAddress   = dtTransGetAddress(dtTable, tmpBuf[B]);\n        tranIsComplex = dtTransGetComplexFlag(dtTable, tmpBuf[B]);\n\n        elSize = dtSizes[tmpBuf[DI]] * (tranIsComplex ? 2 : 1);\n        nBytes = tmpBuf[W] * elSize;\n\n        /*\n         * String in rapid accelerator is:\n         *   - transferred as character stream, element size is sizeof(char_T)\n         *   - stored/operated as void *, element size is sizeof(void*)\n         * We need to use the later one to calculate \"start\" address\n         */\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n        if (strcmp(dtNames[tmpBuf[DI]], \"string\") == 0) {\n            elSize = sizeof(void*);\n        }\n#endif\n        start = tranAddress + (tmpBuf[SI] * elSize);\n\n        /* Install the params. */\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n        if (strcmp(dtNames[tmpBuf[DI]], \"string\") == 0) {\n            suInitializeString(start, bufPtr);\n            bufPtr += nBytes;\n        } else\n#endif\n        {\n            (void)memcpy(start, bufPtr, nBytes);\n            bufPtr += nBytes;\n        }\n\n#ifdef VERBOSE\n        /*\n         * It is safe to assume that once the params are installed into\n         * the param vector that they are properly aligned.  So we\n         * do our verbosity print-out here.\n         */\n        {\n            double     val;\n            const char *dTypeName;\n            const char *vPtr = (const char *)start;\n\n            val = DType2Double(start, tmpBuf[DI], dtInfo, &dTypeName);\n            printf(\"\\n\\tParam| \"\n                   \"DT_Trans: %d, index: %d, nEls: %d, data type: [%s, %d]\\n\",\n                   tmpBuf[B], tmpBuf[SI], tmpBuf[W],\n                   (dTypeName != NULL) ? dTypeName : \"\",tmpBuf[DI]);\n\n            if (!tranIsComplex) {\n                int j;\n                for (j=0; j<tmpBuf[W]; j++) {\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%f\\n\", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n                }\n            } else {\n                int j;\n                for (j=0; j<tmpBuf[W]; j++) {\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%f + \", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n\n                    val = DType2Double(vPtr, tmpBuf[DI], dtInfo, &dTypeName);\n                    printf(\"\\t\\t%fi\\n\", val);\n                    vPtr += dtSizes[tmpBuf[DI]];\n                }\n            }\n        }\n#endif\n    }\n} /* end SetParam */\n#endif /* ifndef EXTMODE_DISABLEPARAMETERTUNING */\n\n\n/******************************************************************************\n * Parameter Upload                                                           *\n ******************************************************************************/\n#include \"upsup_public.h\"\n#define DUMP_PKT (0)\n\n\n/*=============================================================================\n * Circular buffer stuff.\n *============================================================================*/\ntypedef struct BufMemList_tag {\n\n#if ASSERTS_ON\n    int_T  maxBufs;     /* for debugging                       */\n#endif\n    int_T  nActiveBufs; /* num non-empty bufs                  */\n    int_T  *tids;       /* tid associated with each active buf */\n    BufMem *bufs;       /* sections of each buffer to upload   */\n} BufMemList;\n\n\ntypedef struct CircularBuf_tag {\n    volatile int_T    empty;\n\n    int_T    bufSize;\n    char_T   *buf;\n    \n    char_T* volatile head;\n    char_T* volatile tail;\n\n    char_T   *newTail;\n\n    struct {\n        int_T count;\n    } preTrig;\n} CircularBuf;\n\n\n/*==============================================================================\n * Trigger stuff.\n *============================================================================*/\ntypedef enum {\n    TRIGGER_UNARMED,\n    TRIGGER_HOLDING_OFF,\n    TRIGGER_ARMED,\n    TRIGGER_DELAYED,\n    TRIGGER_FIRED,\n    TRIGGER_TERMINATING\n} TriggerState;\n\n\n/*==============================================================================\n * General stuff.\n *============================================================================*/\n\n/*\n * An UploadSection defines a contiguous section of the blockio or dwork\n * structure.  Each section consists of elements of the same data type and same\n * complexity.\n * 'start' should be a const pointer\n */\ntypedef struct UploadSection_tag {\n    void   *start;\n    int_T  nBytes;\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    boolean_T isString;\n#endif\n} UploadSection;\n\n/*\n * An UploadMap is an array of UploadSections.  Typically a map consists of all\n * of the sections of the blockio or dwork structure that are relevant to a\n * given task.\n */\ntypedef struct UploadMap_tag {\n    int32_T    nSections;\n    UploadSection *sections;\n\n    int_T nBytes;  /* total number of bytes in this map */\n} UploadMap;\n\n\n/*\n * Each system contains a table of UploadMap's (one for each tid).  If no data\n * uploading is being done for a given tid, the uploadMap pointer is NULL.\n * The enableState field indicates whether the system in question is active.\n *\n * For a model with 5 total tids, the table looks like:\n *\n *               tid 0    tid 1    tid 2   tid 3   tid 4\n * uploadMap   -------------------------------------------\n *             |  ptr  |  NULL  |  NULL  |  ptr  |  NULL |\n *             ----|-------------------------|------------\n *                 |                         |\n *                 v                         v\n *              UploadMap                 UploadMap\n *              for tid 0                 for tid 3\n */\ntypedef struct SysUploadTable_tag {\n    int8_T    *enableState;\n    UploadMap **uploadMap;\n} SysUploadTable;\n\n\ntypedef struct TriggerInfo_tag {\n    TriggerState            state;\n    int_T                   tid;\n    int32_T                 duration;\n    int32_T                 holdOff;\n    int32_T                 delay;\n    int_T                   lookForRising;\n    int_T                   lookForFalling;\n    real_T                  level;\n    int_T                   count;\n    int_T                   overFlow;\n\n    UploadMap               trigSignals;\n    real_T                  *oldTrigSigVals;\n    int_T                   haveOldTrigSigVal;\n\n    struct {\n        int32_T    duration;\n        int32_T    count;\n\n        int_T      checkUnderFlow; /* ??? */\n    } preTrig;\n} TriggerInfo;\n\n\n/*\n * The BdUploadInfo contains all information regarding data logging.\n */\nstruct BdUploadInfo_tag {\n    int32_T        upInfoIdx;  /* index of upInfo in the array                 */\n    int32_T        nSys;       /* # of sys's for which data logging is active  */\n    SysUploadTable *sysTables; /* array of SysUploadTables                     */\n    CircularBuf    *circBufs;  /* circular buffers to store upload data        */\n    BufMemList     bufMemList; /* list of buffer memory holding data to upload */\n\n    TriggerInfo  trigInfo;\n};\n\n\n/*==============================================================================\n * Global upload data.\n */\n\n/*\n * Definitions that must match Simulink definitions.\n */\n\n#define UPLOAD_RISING_TRIGGER                   ((int32_T)  0)\n#define UPLOAD_FALLING_TRIGGER                  ((int32_T)  1)\n#define UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER ((int32_T)  2)\n\n/*\n * Definitions.\n */\n#define TRIGMODE_ONESHOT (-1)\n\n#define NUM_UPINFOS   2\nstatic  BdUploadInfo  uploadInfoArray[NUM_UPINFOS];\n\n\n/* Function ====================================================================\n * Dump the signal selection packet (EXT_SELECT_SIGNALS).  The packet looks\n * like:\n *\n * upInfoIdx - Index of the UploadInfo. \n *\n * nSys - the number of systems that contain upload blocks (length of the\n *        (BdUploadInfo list)\n *\n * enableIdx - the index into the \"mode vector\" that tells whether or not\n *             a given system is active\n *\n * nTids - the number of tids in a system that contain upload blocks (number\n *         of non NULL entries in a SysUploadTable)\n *\n * nSections - the number of contiguous blockio or dwork sections that\n *             correspond to all blocks within a tid (number of sections in\n *             an UploadMap)\n *\n * B  - Index into data type transition table       - gives base address\n * S  - the starting index of a blockio section     - with respect to B\n * W  - the number of elements in a blockio section\n * DI - data type index - index into the rtw data type table\n *\n * target buf size - size of the upload buffer (to be allocated by target) for\n *                   a given tid\n *\n * Here's the packet format:\n *\n * [upInfoIdx\n *  \n *  nSys\n *\n *  enableIdx                           ---\n *  nTids                                 |\n *  tid nSections B S W DI B S W DI ...   | system\n *  tid nSections B S W DI B S W DI ...   |\n *                                      ---\n *  enableIdx                           ---\n *  nTids                                 |\n *  tid nSections B S W DI B S W DI ...   | system\n *  tid nSections B S W DI B S W DI ...   |\n *                                      ---\n *  target buf size for tid 0\n *  target buf size for tid 1\n *            .\n *            .\n *  target buf size for tid n\n * ]\n *\n * All elements are int32_T.\n */\n#if DUMP_PKT\nPRIVATE void DumpSelectSignalPkt(const char *pkt, int nRootTids)\n{\n    int32_T    i,j,k;\n    int32_T    upInfoIdx;\n    int32_T    nSys;\n    const char *bufPtr = pkt;\n\n    printf(\"Signal Select Pkt-----------\\n\");\n\n    /* upInfoIdx */\n    (void)memcpy(&upInfoIdx, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nupInfoIdx: %d\\n\",upInfoIdx);\n\n    /* nSys */\n    (void)memcpy(&nSys, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nnSys: %d\\n\",nSys);\n\n    for (i=0; i<nSys; i++) {\n        int32_T enableIdx, nTids;\n        \n        /* [enableIdx, nTids] */\n        (void)memcpy(&enableIdx, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        (void)memcpy(&nTids, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        printf(\"[enableIdx, nTids]: %d %d\\n\", enableIdx, nTids);\n\n        for (j=0; j<nTids; j++) {\n            int32_T tid;\n            int32_T nSections;\n\n            /* [tid nSections] */\n            (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n            bufPtr += sizeof(int32_T);\n\n            (void)memcpy(&nSections, bufPtr, sizeof(int32_T));\n            bufPtr += sizeof(int32_T);\n\n            printf(\"[tid nSects]: %d %d\\n\", tid, nSections);\n\n            for (k=0; k<nSections; k++) {\n                const int B  = 0;\n                const int S  = 1;\n                const int W  = 2;\n                const int DI = 3;\n                int32_T   tmpBuf[4];\n\n                /* [B S W DI] */\n                (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n                bufPtr += (sizeof(int32_T) * 4);\n                \n                printf(\"%d %d %d %d\\n\",\n                    tmpBuf[B], tmpBuf[S], tmpBuf[W], tmpBuf[DI]);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n\n    /*\n     * Now the buffer sizes.\n     */\n    printf(\"bufSizes: \");\n    for (i=0; i<nRootTids; i++) {\n        int32_T bufSize;\n\n        printf(\"\\nbufSize[%d] of %d: \",i, nRootTids);\n\n        (void)memcpy(&bufSize, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        printf(\"%d\", bufSize);\n    }\n    printf(\"\\nEnd of select sigs pkt----\\n\");\n} /* end DumpSelectSignalPkt */\n#else\n#define DumpSelectSignalPkt(buf, nRootTids) /* do nothing */\n#endif\n\n\n/* Function ====================================================================\n * Dump the trigger selection packet (EXT_SELECT_TRIGGER).  The packet looks\n * like:\n *\n * upInfoIdx - Index of the UploadInfo. \n *\n * tid       - tid of the trigger signal\n *\n * duration  - The number of base rate steps for which the data logging event\n *             occurs.\n *\n * holdOff   - (-1), signifies that this trigger event is a one_shot, else we \n *             are in normal mode.  For normal mode the value indicates\n *             the number of base rate steps to wait between the end a data\n *             logging event and the re-arming of the trigger for the next data\n *             logging event.  The end of a data logging event is defined as\n *             when the last bit of data has been sent to the host (i.e.,\n *             immediately after the termination flag has been sent).\n *\n * delay     - The number of base rate steps to wait after the trigger event\n *             occurs and the before starting the data collection.  This can\n *             be either positive or negative (pre-trigger).  This field is\n *             ignored if the trigger source is manual.\n *\n * nsections - The sections of the blockio array to monitor for a trigger event.\n *             If the trigger event is not based on a signal, this is set to\n *             0 (e.g., the signal source is manual).\n *\n * sections  - \"B, S, W, DI\" description of a signal (see Signal Selection Pkt).\n *             These are the elements of the blockio vector that are monitored\n *             for trigger events when the trigger is based on a signal.  It is\n *             ignored if the trigger event is not based on a signal\n *             (nsections == 0).\n *\n * direction - If the triggering source is a signal, then this specifies the\n *             direction of the crossing (rising, falling or either).  If we\n *             are not triggering on a signal (nsections == 0), then this field\n *             is ignored.\n *\n * level     - If the triggering source is a signal, then this field specifies\n *             the level (value) of the crossing (0 by default).  If we are not\n *             triggering on a signal (nsections == 0), then this field is\n *             ignored.\n *\n * The packet looks like:\n * [tid duration holdOff delay nsections B S W DI B S W DI ... direction level]\n *\n * All fields are int32_T except for level, which is an SL_DOUBLE (real_T\n * on target).\n */\n#if DUMP_PKT\nPRIVATE void DumpSelectTriggerPkt(const char *pkt)\n{\n    int32_T    i;\n    int32_T    upInfoIdx, tid, duration, holdOff, delay, nSections;\n    int32_T    direction;\n    real_T     level;\n    const char *bufPtr = pkt;\n\n    printf(\"Trigger Select Pkt-----------\\n\");\n\n    /* upInfoIdx */\n    (void)memcpy(&upInfoIdx, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nupInfoIdx: %d\\n\",upInfoIdx);\n    \n    /* tid */\n    (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\ntid: %d\\n\",tid);\n    \n    /* duration */\n    (void)memcpy(&duration, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nduration: %d\\n\",duration);\n\n    /* holdOff */\n    (void)memcpy(&holdOff, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\nholdOff: %d\\n\",holdOff);\n\n    /* delay */\n    (void)memcpy(&delay, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"\\ndelay: %d\\n\",delay);\n\n    /* nsections */\n    (void)memcpy(&nSections, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"nSects: %d\\n\", nSections);\n\n    /* each section */\n    for (i=0; i<nSections; i++) {\n        const int B  = 0;\n        const int S  = 1;\n        const int W  = 2;\n        const int DI = 3;\n        int32_T   tmpBuf[4];\n\n        (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n        bufPtr += (sizeof(int32_T) * 4);\n        \n        printf(\"%d %d %d %d\\n\", tmpBuf[B], tmpBuf[S], tmpBuf[W], tmpBuf[DI]);\n    }\n    printf(\"\\n\");\n\n    /* direction */\n    (void)memcpy(&direction, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    printf(\"direction: %d\\n\",direction);\n\n    /* level */\n    (void)memcpy(&level, bufPtr, sizeof(real_T));\n    bufPtr += sizeof(real_T);\n\n    printf(\"level: %f\\n\",level);\n} /* end DumpSelectTriggerPkt */\n#else\n#define DumpSelectTriggerPkt(buf) /* do nothing */\n#endif\n\n\n/* Function ====================================================================\n * Initialize a UploadSection.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE void InitUploadSection(\n    RTWExtModeInfo *ei,\n    const int32_T  *buf,\n    UploadSection  *section)   /* out */\n{\n    int_T                         elSize;\n    int_T                         offset;\n    int_T                         nBytes;\n    char_T                        *tranAddress;\n    int_T                         tranIsComplex;\n    \n    const DataTypeTransInfo       *dtInfo  = (const DataTypeTransInfo *) rteiGetModelMappingInfo(ei);\n    const DataTypeTransitionTable *dtTable = dtGetBIODataTypeTrans(dtInfo);\n    const uint_T *dtSizes = dtGetDataTypeSizes(dtInfo);\n\n    const int BI = 0;  /* index into dtype tran table (base address)  */\n    const int SI = 1;  /* starting index - wrt to base address        */\n    const int W  = 2;  /* width of section (number of elements)       */\n    const int DI = 3;  /* index into data type tables                 */\n\n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    const char_T* *dtNames;\n#endif\n    \n    tranAddress   = dtTransGetAddress(dtTable, buf[BI]);\n    tranIsComplex = dtTransGetComplexFlag(dtTable, buf[BI]);\n\n    elSize = dtSizes[buf[DI]] * (tranIsComplex ? 2 : 1);\n    nBytes = buf[W] * elSize;\n    offset = buf[SI] * elSize;\n\n    section->start  = tranAddress + offset;\n    section->nBytes = nBytes;\n    \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n    dtNames = dtGetDataTypeNames(dtInfo);\n    section->isString = strcmp(dtNames[buf[DI]], \"string\") == 0;\n#endif\n    \n} /* end InitUploadSection */\n\n\n/* Function ====================================================================\n * Initialize a SysUploadTable.  The callerBufPtr points to the current place in\n * the EXT_SELECT_SIGNALS pkt which should be the enableIdx field.  This\n * function moves the callerBufPtr to the next unread field of the packet.\n */\nPRIVATE boolean_T InitSysUploadTable(\n    RTWExtModeInfo *ei,\n    int_T          numSampTimes,\n    SysUploadTable *sysTable,\n    const char     **callerBufPtr) /* in/out */\n{\n    int_T        i;\n    int32_T      nTids;\n    const char_T *bufPtr = *callerBufPtr;\n    boolean_T    error   = EXT_NO_ERROR;\n\n    /*\n     * Set pointer to enable mode.\n     */\n    {\n        int32_T sysIdx;\n\n        /* read sysIdx */\n        (void)memcpy(&sysIdx, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        sysTable->enableState = rteiGetAddrOfSubSystemActiveVector(ei,sysIdx);\n    }\n\n    /*\n     * Allocate/initialize each tid's uploadMap.\n     */\n\n    /* ...read [nTids] */\n    (void)memcpy(&nTids, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    /* Allocate the array of pointers to UploadMaps. */\n    sysTable->uploadMap = (UploadMap **)calloc(numSampTimes, sizeof(UploadMap *));\n    if (sysTable->uploadMap == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;       \n    }\n\n    for (i=0; i<nTids; i++) {\n        int32_T   tid;\n        int32_T   section;\n        UploadMap *map;\n        \n        /* read tid */\n        (void)memcpy(&tid, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n        \n        /* allocate UploadMap */\n        assert(sysTable->uploadMap[tid] == NULL);\n        sysTable->uploadMap[tid] = (UploadMap *)calloc(1, sizeof(UploadMap));\n        if (sysTable->uploadMap[tid] == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;       \n        }\n        map = sysTable->uploadMap[tid];\n        \n        /* read nSections */\n        (void)memcpy(&map->nSections, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n\n        /* Allocate the blockio sections. */\n        assert(map->sections == NULL);\n        if (map->nSections > 0) {\n           map->sections = (UploadSection *)calloc(map->nSections,sizeof(UploadSection));\n           if (map->sections == NULL) {\n               error = EXT_ERROR; goto EXIT_POINT;\n           }\n        }\n\n        /*\n         * Init the UploadSections.\n         */\n        for (section=0; section<map->nSections; section++) {\n            int32_T    tmpBuf[4];\n            UploadSection *uploadSection = &map->sections[section];\n\n            /* read [B S W DI] */\n            (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n            bufPtr += (sizeof(int32_T) * 4);\n\n            InitUploadSection(ei, tmpBuf, uploadSection);\n\n            /* keep track of total number of bytes in this map */\n            map->nBytes += uploadSection->nBytes;\n        }\n    }\n    \nEXIT_POINT:\n    *callerBufPtr = bufPtr;\n    return(error);\n} /* end InitSysUploadTable */\n\n/* Function ====================================================================\n * Initialize circular buffer fields and allocate required memory.\n */\nPRIVATE boolean_T UploadBufInit(CircularBuf *circBuf, int32_T size)\n{\n    boolean_T error = NO_ERR;\n\n    assert(circBuf->buf == NULL);\n\n    /*\n     * Size will be negative to indicate an error if host determines too much\n     * memory is needed (i.e. the size will not fit in an int32).\n     */\n    if (size < 0) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    circBuf->empty = true;\n    if (size > 0) {\n        assert(circBuf->buf == NULL);\n        circBuf->buf = (char_T *)malloc(size);\n        if (circBuf->buf == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    } else {\n        circBuf->buf = NULL;\n    }\n    circBuf->bufSize = size;\n    \n    circBuf->head = circBuf->buf;\n    circBuf->tail = circBuf->buf;\n\n    circBuf->newTail = NULL;\n\nEXIT_POINT:\n    return(error);\n} /* end UploadBufInit */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* Function ====================================================================\n * Free all dynamically allocated fields of the trigInfo structure.\n */\nPRIVATE void UploadDestroyTrigger(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo *trigInfo    = &uploadInfo->trigInfo;\n    UploadMap   *map         = &trigInfo->trigSignals;\n\n    if (map->sections != NULL) {\n        free(map->sections);\n        map->sections = NULL;\n    }\n\n    if (trigInfo->oldTrigSigVals != NULL) {\n        free(trigInfo->oldTrigSigVals);\n        trigInfo->oldTrigSigVals = NULL;\n    }\n\n    /*\n     * Reset trigger info.\n     */\n    trigInfo->state          = TRIGGER_UNARMED;\n    trigInfo->duration       = 0;\n    trigInfo->holdOff        = 0;\n    trigInfo->delay          = 0;\n    trigInfo->lookForRising  = true;\n    trigInfo->lookForFalling = false;\n    trigInfo->level          = (real_T)0;\n    trigInfo->count          = 0;\n    trigInfo->overFlow       = false;\n\n    trigInfo->trigSignals.nSections = 0;\n    trigInfo->trigSignals.sections  = NULL;\n    trigInfo->trigSignals.nBytes    = 0;\n\n    trigInfo->oldTrigSigVals    = NULL;\n    trigInfo->haveOldTrigSigVal = false;\n\n    trigInfo->preTrig.duration       = 0;\n    trigInfo->preTrig.count          = 0;\n    trigInfo->preTrig.checkUnderFlow = false;\n} /* end UploadDestroyTrigger */\n\n\n/* Function ====================================================================\n * Reset fields of the uploadinfo struct.\n */\nPUBLIC void UploadLogInfoReset(int32_T upInfoIdx)\n{\n    static boolean_T firstTime[NUM_UPINFOS] = {true, true};\n    BdUploadInfo     *uploadInfo = &uploadInfoArray[upInfoIdx];\n    \n    /*\n     * uploadInfoArray is declared as global static, so most compilers will\n     * initialize the memory to zero.  However, the tic6000 assigns this\n     * variable into uninitialized memory.  When this function is called for\n     * the first time, we attempt to free garbage pointers and crash.  By\n     * clearing unloadInfoArray explicitly the first time this function is\n     * called, we can ensure that this function will work for all compilers.\n     */\n    if (firstTime[upInfoIdx]) {\n        memset(uploadInfo, 0, sizeof(BdUploadInfo));\n        firstTime[upInfoIdx] = false;\n    }\n   \n    /* sysUploadTable */\n    uploadInfo->nSys      = 0;\n    uploadInfo->sysTables = NULL;\n\n    uploadInfo->circBufs = NULL;\n\n    uploadInfo->bufMemList.bufs = NULL;\n    uploadInfo->bufMemList.tids = NULL;\n\n    /* Reset trigger info */\n    UploadDestroyTrigger(upInfoIdx);\n\n} /* end UploadLogInfoReset */\n\n\n/* Function ====================================================================\n * Destroy all data associated with data logging.  Fields are re-initialized\n * and pointers NULL'ed out by UploadLogInfoReset().\n */\nPUBLIC void UploadLogInfoTerm(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T i;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    if (uploadInfo->nSys == 0) return; /* Nothing to terminate */\n\n    /*\n     * Free fields of the sysUpload tables and then the table itself.\n     */\n    for (i=0; i<uploadInfo->nSys; i++) {\n        int_T     tid;\n        UploadMap **uploadMap = uploadInfo->sysTables[i].uploadMap;\n        \n        for (tid=0; tid<numSampTimes; tid++) {\n            if (uploadMap[tid] != NULL) {\n                /* Free fields of uploadMap. */\n                free(uploadMap[tid]->sections);\n\n                /* Free the uploadMap. */\n                free(uploadMap[tid]);\n            }\n        }\n\n        free(uploadMap);\n    }\n\n    free(uploadInfo->sysTables);\n\n    /* Free circular buf fields and bufMemLists. */\n    if (uploadInfo->circBufs) {\n        for (i=0; i<numSampTimes; i++) {\n            free(uploadInfo->circBufs[i].buf);\n        }\n        free(uploadInfo->circBufs);\n    }\n\n    free(uploadInfo->bufMemList.bufs);\n    free(uploadInfo->bufMemList.tids);\n    \n    /*\n     * Free trigger info.\n     */\n    UploadDestroyTrigger(upInfoIdx);\n\n    /*\n     * Reset all vals to initial value and NULL out pointers.\n     */\n    UploadLogInfoReset(upInfoIdx);\n} /* end UploadLogInfoTerm */\n\n\n/* Function ====================================================================\n * Prepare for final flush of buffers.  This involves setting the trigger\n * state to appropriate values.\n */\nPUBLIC void UploadPrepareForFinalFlush(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    switch(uploadInfo->trigInfo.state) {\n    case TRIGGER_FIRED:\n    case TRIGGER_TERMINATING:\n        /*\n         * 1) set trig state to \"terminating\" so that the eventual call to\n         *    UploadBufGetData knows to add the terminator flag to\n         *    the data stream.\n         * 2) set trig state to \"oneshot\" to prevent re-arming\n         */\n        uploadInfo->trigInfo.state   = TRIGGER_TERMINATING; /* 1 */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;    /* 2 */\n        break;\n\n    case TRIGGER_UNARMED:\n    case TRIGGER_HOLDING_OFF:\n    case TRIGGER_ARMED:\n    case TRIGGER_DELAYED:\n        /* do nothing */\n        break;\n    }\n\n#ifdef VXWORKS\n    /* Let upload server run to ensure that term pkt is sent to host. One\n       semGive() is for the background task and the other is for the explicit\n       call to rt_UploadServerWork() in DisconnectFromHost(). */\n    semGive(uploadSem);\n    semGive(uploadSem);\n#endif\n\t\n} /* end UploadPrepareForFinalFlush */\n\n\n/* Function ====================================================================\n * Initialize data uploading by processing the EXT_SELECT_SIGNALS packet\n * (which is passed in).  Return the error status.  See DumpSelectSignalPkt()\n * for a detailed description of the packet.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC boolean_T UploadLogInfoInit(RTWExtModeInfo *ei,\n                                   int_T          numSampTimes,\n                                   const char     *pkt,\n                                   int32_T        upInfoIdx)\n{\n    int          nActiveTids;\n    int_T        i;\n    boolean_T    error   = EXT_NO_ERROR;\n    const char   *bufPtr = pkt;\n    BdUploadInfo *uploadInfo;\n\n    DumpSelectSignalPkt(pkt, numSampTimes);\n\n    /* Point to the correct uploadInfo */\n    uploadInfo           = &uploadInfoArray[upInfoIdx];\n    uploadInfo->upInfoIdx = upInfoIdx;\n\n    /* Free upInfo if fields are already allocated */\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n\n    /* nSys */\n    (void)memcpy(&uploadInfo->nSys, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    assert(uploadInfo->sysTables == NULL);\n    uploadInfo->sysTables = (SysUploadTable *)\n        calloc(uploadInfo->nSys, sizeof(SysUploadTable));\n    if (uploadInfo->sysTables == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    /*\n     * Init each system table.\n     */\n    for (i=0; i<uploadInfo->nSys; i++) {\n        error = InitSysUploadTable(ei, numSampTimes,\n                                   &uploadInfo->sysTables[i], &bufPtr);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n    }\n\n    assert(uploadInfo->circBufs == NULL);\n    uploadInfo->circBufs = (CircularBuf *) calloc(numSampTimes,\n                                                  sizeof(CircularBuf));\n\n    /*\n     * Allocate the circular buffers.\n     */\n    nActiveTids = 0;\n    for (i=0; i<numSampTimes; i++) {\n        int32_T size;\n        \n        (void)memcpy(&size, bufPtr, sizeof(int32_T));\n        bufPtr += sizeof(int32_T);\n        \n        error = UploadBufInit(&uploadInfo->circBufs[i], size);\n        if (error != EXT_NO_ERROR) goto EXIT_POINT;\n\n        nActiveTids += (size != 0);\n    }\n\n    /*\n     * Initialize/Allocate the bufMemLists - these are used by\n     * ext_svr to pull the appropriate data out of the buffers and send it\n     * to the host.\n     */\n#if ASSERTS_ON\n    uploadInfo->bufMemList.maxBufs = nActiveTids;\n#endif\n    uploadInfo->bufMemList.nActiveBufs = 0;\n\n    assert(uploadInfo->bufMemList.bufs == NULL);\n    uploadInfo->bufMemList.bufs = (BufMem *)malloc(nActiveTids*sizeof(BufMem));\n    if (uploadInfo->bufMemList.bufs == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\n    assert(uploadInfo->bufMemList.tids == NULL);\n    uploadInfo->bufMemList.tids = (int_T *)malloc(nActiveTids*sizeof(int_T));\n    if (uploadInfo->bufMemList.tids == NULL) {\n        error = EXT_ERROR; goto EXIT_POINT;\n    }\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        UploadLogInfoTerm(upInfoIdx, numSampTimes);\n    }\n    return(error);\n} /* end UploadLogInfoInit */\n\n\n/* Function ====================================================================\n * Initialize and configure the trigger attributes.  See DumpSelectTriggerPkt()\n * for a detailed description of the packet.\n */\nPUBLIC boolean_T UploadInitTrigger(RTWExtModeInfo *ei,\n                                   const char     *pkt,\n                                   int32_T         upInfoIdx)\n{\n    int_T       nSections;\n    int32_T     i32_tid;\n    int32_T     direction;\n    TriggerInfo *trigInfo;\n    boolean_T   error     = EXT_NO_ERROR;\n    const char  *bufPtr   = pkt;\n    \n    DumpSelectTriggerPkt(pkt);\n    \n    /* Select the trig Info */\n    trigInfo = &uploadInfoArray[upInfoIdx].trigInfo;\n\n    /* tid, duration, holdOff, delay and nsections */\n    (void)memcpy(&i32_tid, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    trigInfo->tid = (int_T)i32_tid;\n\n    (void)memcpy(&trigInfo->duration, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->holdOff, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->delay, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    (void)memcpy(&trigInfo->trigSignals.nSections, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n    \n    nSections = trigInfo->trigSignals.nSections;\n\n    /*\n     * Init the UploadSections - if the trigger is signal based.\n     */\n    if (nSections > 0) {\n        /* trigger is signal based */\n        int       section;\n        UploadMap *map = &trigInfo->trigSignals;\n\n        assert(map->nBytes == 0);\n        assert(map->sections == NULL);\n        map->sections = (UploadSection *)malloc(nSections * sizeof(UploadSection));\n        if (map->sections == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n            \n        for (section=0; section<map->nSections; section++) {\n            int32_T       tmpBuf[4];\n            UploadSection *uploadSection = &map->sections[section];\n\n            /* read [B S W DI] */\n            (void)memcpy(&tmpBuf, bufPtr, sizeof(int32_T)*4);\n            bufPtr += (sizeof(int32_T) * 4);\n            \n            InitUploadSection(ei, tmpBuf, uploadSection);\n\n            /* keep track of total number of bytes in this map */\n            map->nBytes += uploadSection->nBytes;\n        }\n\n        /*\n         * Allocate space to hold the old values of the trigger signals.  Note\n         * that trigger signals are guaranteed to be of type SL_DOUBLE (real_T)\n         * and non-complex.\n         */\n        assert(trigInfo->oldTrigSigVals == NULL);\n        assert(trigInfo->oldTrigSigVals == NULL);\n        trigInfo->oldTrigSigVals = (real_T *)malloc(map->nBytes);\n        if (trigInfo->oldTrigSigVals == NULL) {\n            error = EXT_ERROR; goto EXIT_POINT;\n        }\n    }\n            \n    /* Direction. */\n    (void)memcpy(&direction, bufPtr, sizeof(int32_T));\n    bufPtr += sizeof(int32_T);\n\n    trigInfo->lookForRising  = \n        ((direction == UPLOAD_RISING_TRIGGER)  || \n         (direction == UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER));\n\n    trigInfo->lookForFalling = \n        ((direction == UPLOAD_FALLING_TRIGGER) || \n         (direction == UPLOAD_EITHER_RISING_OR_FALLING_TRIGGER));\n    \n    /* level */\n    (void)memcpy(&trigInfo->level, bufPtr, sizeof(real_T));\n    bufPtr += sizeof(real_T);\n\n    /*\n     * Convert delay to pre-trigger duration.\n     */\n    if (trigInfo->delay < 0) {\n        trigInfo->preTrig.duration = -trigInfo->delay;\n        trigInfo->delay            = 0;\n    } else {\n        trigInfo->preTrig.duration = 0;\n    }\n\nEXIT_POINT:\n    if (error != EXT_NO_ERROR) {\n        UploadDestroyTrigger(upInfoIdx);\n    }\n    return(error);\n} /* end UploadInitTrigger */\n\n\n/* Function ====================================================================\n * Arm the trigger.\n */\nPUBLIC void UploadArmTrigger(int32_T upInfoIdx, int_T numSampTimes)\n{\n    int_T   tid;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    assert((uploadInfo->trigInfo.state == TRIGGER_UNARMED) ||\n           (uploadInfo->trigInfo.state == TRIGGER_HOLDING_OFF));\n\n    host_upstatus_is_uploading = false;\n\n    /*\n     * Re-initialize.\n     */\n    uploadInfo->trigInfo.overFlow = false;\n    for (tid=0; tid<numSampTimes; tid++) {\n        CircularBuf *circBuf = &uploadInfo->circBufs[tid];\n        if (circBuf->bufSize > 0) {\n            circBuf->head = circBuf->buf;\n            circBuf->tail = circBuf->buf;\n\n            circBuf->newTail = NULL;\n            circBuf->empty   = true;\n        }\n    }\n\n    /* \n     * Re-initialize trigger fields.\n     */\n    uploadInfo->trigInfo.count             = 0;\n    uploadInfo->trigInfo.haveOldTrigSigVal = false;\n\n    /* \n     * Reset pre-trig counts for normal mode.\n     */\n    uploadInfo->trigInfo.preTrig.count = 0;\n\n    /* \n     * Re-arm after all initialization.  Make sure that trigInfo.state is\n     * set last since this routine may be interrupted.\n     */\n    uploadInfo->trigInfo.state = TRIGGER_ARMED;\n\n} /* end UploadArmTrigger */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function ====================================================================\n * Terminate this data logging session by destroying the uploadInfo and\n * setting the trigger backed to the unarmed state.\n */\nPUBLIC void UploadEndLoggingSession(int32_T upInfoIdx, int_T numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    uploadInfo->trigInfo.state = TRIGGER_UNARMED;\n    UploadLogInfoTerm(upInfoIdx, numSampTimes);\n} /* end UploadEndLoggingSession */\n\n\n/* Function ====================================================================\n * Cancel this data logging session.\n */\nPUBLIC void UploadCancelLogging(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    switch(uploadInfo->trigInfo.state) {\n\n    case TRIGGER_UNARMED:\n        break;\n\n    case TRIGGER_HOLDING_OFF:\n    case TRIGGER_ARMED:\n    case TRIGGER_DELAYED:\n    case TRIGGER_FIRED:\n        /*\n         * Move to TRIGGER_TERMINATING and ensure that we are no longer in\n         * \"normal\" mode (TRIGMODE_NORMAL) so that the trigger does not get\n         * re-armed.\n         */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;\n        uploadInfo->trigInfo.state   = TRIGGER_TERMINATING;\n#ifdef VXWORKS\n        /*\n         * Let upload server run to ensure that term pkt is sent to host (needed\n         * for all but the TRIGGERED_FIRED case since the upload server is\n         * inactive).\n         */\n        semGive(uploadSem);\n#endif\n        break;\n    \n    case TRIGGER_TERMINATING:\n        /*\n         * Ensure that we are no longer in \"normal\" mode (TRIGMODE_NORMAL) so\n         * that the trigger does not get re-armed.\n         */\n        uploadInfo->trigInfo.holdOff = TRIGMODE_ONESHOT;\n        break;\n    }\n} /* end UploadCancelLogEvent */\n\n\n/* Function ====================================================================\n * Called by ext_svr (background task), in order to perform tasks that need\n * to be done after each time that data has been sent to the host.  This\n * includes:\n *\n * o move the tail for the specified buffer forward\n * o detect the end of a data logging event so that the trigger state can\n *   be either set to unarmed (for one shot) or backed to armed (for normal\n *   mode).\n * \n * NOTE:  UploadBufGetData and UploadBufMoveTail must be called in pairs where the\n *        UploadBufGetData call precedes the UploadBufMoveTail call.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void UploadBufDataSent(const int_T tid, int32_T upInfoIdx)\n{   \n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    CircularBuf  *circBuf    = &uploadInfo->circBufs[tid];            \n\n    host_upstatus_is_uploading = true;\n    \n    /* Move the tail forward. */\n    circBuf->tail = circBuf->newTail;\n        \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    /* \n     * disable interrupts around this critical region. We need to \n     * guarantee that reading the head pointer is an atomic \n     * operation.\n     */\n    EXTMODE_DISABLE_INTERRUPTS;\n#endif\n    \n    /* \n     * Since we are moving the tail forward, we know that head == tail\n     * represents an empty buffer and not a full buffer.\n     */\n    circBuf->empty = (circBuf->tail == circBuf->head);\n    \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n    /* re-enable interrupts */\n    EXTMODE_ENABLE_INTERRUPTS;\n#endif\n\n} /* end UploadBufDataSent */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/*\n * Macro =======================================================================\n * Move the tail of a circular buffer forward by one time step - accounting for\n * wrapping.\n */\n#define MOVE_TAIL_ONESTEP(circBuf, end)                            \\\n{                                                                  \\\n    int     nBytesPassedEnd;                                       \\\n    int     nBytesInStep;                                          \\\n    int32_T *nBytesPtr = (int32_T *)((circBuf)->tail)+1;           \\\n                                                                   \\\n    (void)memcpy(&nBytesInStep, nBytesPtr, sizeof(int32_T));       \\\n    nBytesInStep += (2*sizeof(int32_T));                           \\\n    assert(nBytesInStep > 0);                                      \\\n    (circBuf)->tail += (nBytesInStep);                             \\\n    nBytesPassedEnd = (int)((circBuf)->tail - (end));              \\\n    if (nBytesPassedEnd >= 0) {                                    \\\n        (circBuf)->tail = (circBuf)->buf + nBytesPassedEnd;        \\\n    }                                                              \\\n} /* end MOVE_TAIL_ONESTEP */\n\n\n/*\n * Macro =======================================================================\n * Copy data into the circular buffer.\n */\n#define CIRCBUF_COPY_DATA(bufMem, data)                         \\\n{                                                               \\\n    (void)memcpy((bufMem).section1, (data), (bufMem).nBytes1);  \\\n    if ((bufMem).section2 != NULL) {                            \\\n        char *tmp = ((char *)(data)) + (bufMem).nBytes1;        \\\n        (void)memcpy((bufMem).section2, tmp, (bufMem).nBytes2); \\\n    }                                                           \\\n} /* end CIRCBUF_COPY_DATA */\n\n\n/* Function ====================================================================\n * Assign sections in the circular buffer for the requested number of bytes\n * (i.e., fill in the bufMem struct).  If there is no room in the circular\n * buffer return an overflow error.\n *\n * NOTE: Do not move the CircularBuffers head forward in this function!  \n *       Only move the tmpHead forward.  The actual head is not advanced\n *       until the entire time point is successfully copied into the buffer.\n *\n *       This function modifies tmpHead to point at the next available \n *       location.\n *\n *       It is possible for tmpHead to equal the tail upon entry to this\n *       function.  This does not necessarily mean that the buffer is\n *       empty (unwrapped).  It could also mean that the buffer is exactly\n *       full (this is considered as wrapped).\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T UploadBufAssignMem(\n    CircularBuf  *circBuf,\n    int_T        nBytesToAdd,\n    char         **tmpHead,   /* in-out */\n    BufMem       *bufMem)     /* out */\n{\n    int_T       nBytesLeft;\n    boolean_T   overFlow  = false;\n    char        *end      = circBuf->buf + circBuf->bufSize; /* 1 passed end */\n\n    if ((*tmpHead > circBuf->tail) || circBuf->empty) {\n        /* buffer not wrapped */\n        nBytesLeft = (int_T)((end - *tmpHead) + (circBuf->tail - circBuf->buf));\n\n        if (nBytesLeft < nBytesToAdd) {\n            overFlow = true;\n            goto EXIT_POINT;\n        }\n\n        if ((*tmpHead + nBytesToAdd) < end) {\n            /* still not wrapped */\n            bufMem->nBytes1  = nBytesToAdd;\n            bufMem->section1 = *tmpHead;\n\n            bufMem->nBytes2  = 0;\n            bufMem->section2 = NULL;\n\n            *tmpHead += nBytesToAdd;\n        } else {\n            /* now we're wrapped */\n            bufMem->nBytes1  = (int_T)(end - *tmpHead);\n            bufMem->section1 = *tmpHead;\n\n            bufMem->nBytes2  = nBytesToAdd - bufMem->nBytes1;\n            bufMem->section2 = (bufMem->nBytes2 > 0) ? circBuf->buf : NULL;\n\n            *tmpHead = circBuf->buf + bufMem->nBytes2;\n        }  \n    } else {\n        /* wrapped */\n        nBytesLeft = (int_T)(circBuf->tail - *tmpHead);\n        if (nBytesLeft < nBytesToAdd) {\n            overFlow = true;\n            goto EXIT_POINT;\n        }\n\n        bufMem->nBytes1  = nBytesToAdd;\n        bufMem->section1 = *tmpHead;\n\n        bufMem->nBytes2  = 0;\n        bufMem->section2 = NULL;\n\n        *tmpHead += nBytesToAdd;\n    }\n    \nEXIT_POINT:\n    return(overFlow);\n} /* end UploadBufAssignMem */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n/* Function ====================================================================\n * Check the trigger signals for crossings.  Return true if a trigger event is\n * encountered.  It is assumed that the trigger signals are real_T.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPRIVATE boolean_T UploadCheckTriggerSignals(int32_T upInfoIdx)\n{\n    int          i;\n    BdUploadInfo *uploadInfo      = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo        = &uploadInfo->trigInfo;\n    real_T       *oldTrigSigVals  = trigInfo->oldTrigSigVals;\n    real_T       *oldSigPtr       = oldTrigSigVals;\n       \n    for (i=0; i<trigInfo->trigSignals.nSections; i++) {\n        UploadSection *section = &trigInfo->trigSignals.sections[i];\n        int_T         nEls     = section->nBytes / sizeof(real_T);\n\n        /*\n         * If we have a previous signal value to check, then see if we had\n         * a crossing.\n         */\n        if (trigInfo->haveOldTrigSigVal) {\n            int_T   j;\n            real_T  level   = trigInfo->level;\n            real_T  *rStart = (real_T *)section->start; /* guaranteed by host */\n            \n            for (j=0; j<nEls; j++) {\n                if (trigInfo->lookForRising && \n                    (((rStart[j] >= level) && (oldSigPtr[j] <  level)) ||\n                     ((rStart[j] >  level) && (oldSigPtr[j] == level)))) {\n                    return(true);\n                }\n                if (trigInfo->lookForFalling &&\n                    (((rStart[j] < level)  && (oldSigPtr[j] >= level)) ||\n                     ((rStart[j] == level) && (oldSigPtr[j] >  level)))) {\n                    return(true);\n                }\n            }\n        }\n\n        /*\n         * Update old signal values.\n         */\n        (void)memcpy(oldSigPtr, section->start, section->nBytes);\n        oldSigPtr += nEls;\n    }\n    assert(((unsigned char *)oldTrigSigVals) + trigInfo->trigSignals.nBytes == oldSigPtr);\n    trigInfo->haveOldTrigSigVal = true;\n    return(false);\n} /* end UploadCheckTriggerSignals */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* Function ====================================================================\n * If the trigger is in the TRIGGER_FIRED state or we are collecting data for\n * pre-triggering, add data, for each tid with a hit, to the upload buffers.  \n * This function is called from within the appropriate task, once per sample\n * hit.\n *\n * The format of the packet that is sent to the host is as follows:\n *\n * definitions:\n *      pktType - A qualifier indicating any special action that needs to be\n *                taken (e.g., a termination flag following the last data point,\n *                or a flag indicating that it is the first data point after\n *                a trigger event).\n *\n *      nBytes - total number of target bytes for this packet (including the\n *               nBytes field).  nBytes worth of data represents 1 full time\n *               step of the target simulation.\n *\n *      nSys - The number of systems for which this packet contains data.\n *\n *      tid - The tid with which this data is associated.\n *\n *      upInfoIdx - upInfo index\n *\n *      t - simulation time\n *\n *      sysId - The index into the BdUploadInfo.sysTables array so that we can\n *              map the target data back to the appropriate system.  This is\n *              NOT the descendant system index!\n *\n *      data - the target simulation data (in target format)\n *\n * The packet looks like:\n * [nBytes pktType nSys tid upInfoIdx t sysId [data] sysId [data]...]\n *     |                            | |         | |          |\n *     ----------------------------- ----------- ------------\n *          pkt header          sys data     sys data\n *\n * Ints are int32_T.\n */\n#ifndef EXTMODE_DISABLESIGNALMONITORING\nPUBLIC void UploadBufAddTimePoint(int_T tid, real_T taskTime,\n                                  int32_T upInfoIdx)\n{\n    int_T        preTrig;\n    int_T        overFlow;\n    TriggerInfo  *trigInfo;\n    CircularBuf  *circBuf;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n\n    overFlow   = false;\n    trigInfo   = &uploadInfo->trigInfo;\n    circBuf    = &uploadInfo->circBufs[tid];\n    \n    /*\n     * Check for transitions from the TRIGGER_ARMED state to either the\n     * TRIGGER_FIRED_STATE or the TRIGGER_DELAYED state.  We only do this\n     * if it is a sample hit for the trigger signal.  Note that this\n     * is the only place in the whole world that the trigger state can\n     * move from TRIGGER_ARMED_STATE to TRIGGER_DELAYED or TRIGGER_FIRED.\n     */\n    if (trigInfo->state == TRIGGER_ARMED) {\n        if (trigInfo->trigSignals.nSections == 0) {\n            /* short-circuit for manual trigger */\n            trigInfo->state = TRIGGER_FIRED;\n        } else\n            if ((tid == trigInfo->tid) &&\n                (UploadCheckTriggerSignals(upInfoIdx))) {\n                /* trig signal crossing */\n                if (trigInfo->delay == 0) {\n                    trigInfo->state = TRIGGER_FIRED;\n                    /* 0 unless pre-trig */\n                    trigInfo->count = trigInfo->preTrig.count;\n                } else {\n                    trigInfo->state = TRIGGER_DELAYED;\n                    assert(trigInfo->count == 0);\n                    \n                    /* We will be skipping this step, so the delay count is 1. */\n                    trigInfo->count = 1;\n                }\n            }\n    }\n    \n    preTrig = (trigInfo->state == TRIGGER_ARMED) &&\n        (trigInfo->preTrig.duration > 0);\n    \n    /*\n     * Handle adding data to the collection buffers - if needed.\n     */\n    if (((trigInfo->state == TRIGGER_FIRED) || preTrig) &&\n        /* bufSize == 0 means no signals in this tid */\n        circBuf->bufSize != 0) {\n        \n        int32_T     i;\n        BufMem      bufMem;\n        BufMem      pktStart;\n        int_T       size;\n        char_T *tmpHead    = circBuf->head;\n        const int_T PKT_TYPE_IDX = 0;\n        const int_T NBYTES_IDX   = 1;\n        const int_T NSYS_IDX     = 2;\n        const int_T TID_IDX      = 3;\n        const int_T UPINFO_IDX   = 4;\n\n        int32_T intHdr[5] = {0, 0, 0, 0, 0};\n        intHdr[UPINFO_IDX] = upInfoIdx;\n        \n        if (preTrig && (trigInfo->preTrig.count==trigInfo->preTrig.duration)) {\n            /* Advance the tail (we don't need the oldest point anymore). */\n            char *end = circBuf->buf + circBuf->bufSize;\n            MOVE_TAIL_ONESTEP(circBuf, end);\n            trigInfo->preTrig.count--;\n        }\n        \n        /*\n         * Save some space for the 5 integer values that make up the packet\n         * header: [pktType nBytes nSys tid upInfoIdx].\n         * The values are filled in later.\n         */\n        size = 5*sizeof(int32_T);\n        overFlow = UploadBufAssignMem(circBuf, size, &tmpHead, &pktStart);\n        if (overFlow) goto EXIT_POINT;\n\n        /*\n         * We do not want to include the packet type and number of bytes\n         * in the size calculation.  Size should represent the payload of\n         * this packet.  The packet type and number of bytes represent the\n         * packet header and are not included in the payload size.\n         */\n        size -= 2*sizeof(int32_T);\n        intHdr[NBYTES_IDX] += size;\n        \n        /* time */\n        overFlow =\n            UploadBufAssignMem(circBuf, sizeof(real_T), &tmpHead, &bufMem);\n        if (overFlow) goto EXIT_POINT;\n        intHdr[NBYTES_IDX] += sizeof(real_T);\n        \n        CIRCBUF_COPY_DATA(bufMem, &taskTime);\n\n        /*\n         * Check each system for an UploadMap. \n         */\n        for (i=0; i<uploadInfo->nSys; i++) {\n            const SysUploadTable *sysTable =\n                (const SysUploadTable *)&uploadInfo->sysTables[i];\n            \n            if ( (*sysTable->enableState != SUBSYS_RAN_BC_DISABLE) && \n                 (*sysTable->enableState != SUBSYS_RAN_BC_ENABLE_TO_DISABLE) ) {\n                UploadMap *map = sysTable->uploadMap[tid];\n\n                if (map != NULL) {\n                    int_T section;\n                    intHdr[NSYS_IDX]++;\n                    \n                    /* Add system index */\n                    size = sizeof(int32_T);\n                    overFlow =\n                        UploadBufAssignMem(circBuf, size, &tmpHead, &bufMem);\n                    if (overFlow) goto EXIT_POINT;\n                    intHdr[NBYTES_IDX] += size;\n                    \n                    CIRCBUF_COPY_DATA(bufMem, &i);\n                    \n                    /* Add data values */\n                    for (section=0; section<map->nSections; section++) {\n                        UploadSection *sect = &map->sections[section];\n                        \n#ifdef MW_DYNAMIC_STRING_SUPPORT\n                        if (sect->isString) {\n                            /* String data is [nBytes \"abc...\\0\"] */\n                            const void* strPtr = *(void**)sect->start;\n                            /* Add number of bytes of the string, including null-terminator */\n                            int32_T strNBytes = suStrlen(strPtr) + 1;\n                            char *tmpStr;\n                            \n                            overFlow = UploadBufAssignMem(circBuf, size, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += size;\n                            CIRCBUF_COPY_DATA(bufMem, &strNBytes);\n\n                            /* Add character bytes */\n                            overFlow = UploadBufAssignMem(circBuf, strNBytes, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += strNBytes;\n                            \n                            tmpStr = suToCStr(strPtr);\n                            CIRCBUF_COPY_DATA(bufMem, tmpStr);\n                            free(tmpStr);\n                        } else\n#endif\n                        \n                        {\n                            /* Regular cases */\n                            overFlow = UploadBufAssignMem(\n                                circBuf, sect->nBytes, &tmpHead, &bufMem);\n                            if (overFlow) goto EXIT_POINT;\n                            intHdr[NBYTES_IDX] += sect->nBytes;\n                            \n                            CIRCBUF_COPY_DATA(bufMem, sect->start);\n                        }\n                    }\n                }\n            }\n        }\n\n        /* If no systems were active then, do nothing. */\n        if (intHdr[NSYS_IDX] == 0) goto EXIT_POINT;\n        \n        /*\n         * Go back and finish the header: [nBytes pktType nSys tid]\n         */\n        \n        /* ...pktType */\n        intHdr[PKT_TYPE_IDX] = EXT_UPLOAD_LOGGING_DATA;\n\n        /* ...tid */\n        intHdr[TID_IDX] = tid;\n        CIRCBUF_COPY_DATA(pktStart, intHdr);\n\n        /*\n         * Time point successfully added to queue.\n         */\n        circBuf->head  = tmpHead;\n        circBuf->empty = false;\n        \n        if (preTrig) {\n            trigInfo->preTrig.count++;\n        }\n    }\n\nEXIT_POINT:\n    if (!preTrig) {\n        if (overFlow) {\n            trigInfo->overFlow = true;\n            trigInfo->state    = TRIGGER_TERMINATING;\n        }\n#ifdef VXWORKS\n        else if (trigInfo->state == TRIGGER_FIRED) {\n            /* allow upload server to run - if data needs to be uploaded */\n            semGive(uploadSem);\n        }\n#endif\n    } \n} /* end UploadBufAddTimePoint */\n\n\n/* Function ====================================================================\n * Called at the base rate, controls the state of data logging including:\n *   - monitoring the trigger signal for a trigger event\n *   - managing transition of most trigger states\n *      o a separate function (UploadCheckEndTrigger manages the duration\n *        count and the transition from fired to terminating at the end\n *        of the data collection event).\n *\n * NOTE:\n *  o This function should be called after mdlOutputs for the base rate\n */\nPUBLIC void UploadCheckTrigger(int32_T upInfoIdx, int_T numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo   = &uploadInfo->trigInfo;\n\n    if (trigInfo->state == TRIGGER_UNARMED) return;\n\n    if (trigInfo->state == TRIGGER_HOLDING_OFF) {\n        if (trigInfo->count++ == trigInfo->holdOff) {\n            UploadArmTrigger(upInfoIdx, numSampTimes);\n        } else {\n            return;\n        }\n    }\n\n    /*\n     * Transitions from the TRIGGER_ARMED_STATE to the TRIGGER_DELAYED\n     * state or to the TRIGGER_FIRED_STATE are checked for and realized\n     * within the task (tid) associated with the trigger signal.\n     * See UploadBufAddTimePoint().\n     */ \n    \n    /*\n     * Look for transitions from the TRIGGER_DELAYED state.  The TRIGGER_FIRED\n     * state always follows the TRIGGER_DELAYED state.\n     *\n     * NOTE: the trigInfo count field is first used to count the trigger delay\n     *       and then used to count the trigger duration\n     */\n    if (trigInfo->state == TRIGGER_DELAYED) {\n        if (trigInfo->count++ >= trigInfo->delay) {\n            trigInfo->count = trigInfo->preTrig.count; /* 0 unless pre-trig */\n            trigInfo->state = TRIGGER_FIRED;\n            if (trigInfo->preTrig.duration > 0) {\n                trigInfo->preTrig.checkUnderFlow = true;\n            }\n#ifdef VERBOSE\n            printf(\"\\nTrigger fired!\\n\");\n#endif\n        }\n    }\n} /* end UploadCheckTrigger */\n\n\n/* Function ====================================================================\n * Called at the base rate, controls the state of data logging wrt\n *  o incrementing the duration count\n *  o managing the transition to the trigger terminating state\n *\n * NOTES:\n *  o Call this function at the very end of a step.\n *  o Also see UploadCheckTrigger()\n */\nPUBLIC void UploadCheckEndTrigger(int32_T upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo *trigInfo    = &uploadInfo->trigInfo;\n\n    if (trigInfo->state == TRIGGER_UNARMED) return;\n\n    /*\n     * Increment duration count and terminate the data logging event if\n     * the duration has been met.\n     */\n    if (trigInfo->state == TRIGGER_FIRED) {\n        trigInfo->count++;\n        if (trigInfo->count == trigInfo->duration) {\n            trigInfo->state = TRIGGER_TERMINATING;\n        }\n    }\n\n#ifdef VXWORKS\n    if (trigInfo->state == TRIGGER_TERMINATING) {\n        /* Let upload server run to ensure that term pkt is sent to host. */\n        semGive(uploadSem);\n    }\n#endif\n} /* end UploadCheckEndTrigger */\n\n\n/* Function ===================================================================\n * Search through the upload buffers and fill out the internal copy of the\n * buffer list.  It contains a list of all buffer memory (1 entry per non-empty\n * tid buffer) that needs to be sent to the host.  Fill out the fields of the\n * specified ExtBufMemList (passed in by ext_svr) to provide public, read-only\n * access.\n */\nPRIVATE void SetExtBufListFields(ExtBufMemList *extBufList,\n                                 int32_T       upInfoIdx,\n                                 int_T         numSampTimes)\n{\n    int_T       tid;\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    BufMemList   *bufList    = &uploadInfo->bufMemList;\n\n    bufList->nActiveBufs = 0;\n\n    for (tid=0; tid<numSampTimes; tid++) {\n        CircularBuf *circBuf = &uploadInfo->circBufs[tid];\n\n        if (!circBuf->empty) {\n            BufMem  *bufMem;\n            char_T  *head;\n            char_T  *tail   = circBuf->tail;\n            int_T   size    = circBuf->bufSize;\n\n            \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n            /* \n             * disable interrupts around this critical region. We need to \n             * guarantee that reading the head pointer is an atomic \n             * operation.\n             */\n            EXTMODE_DISABLE_INTERRUPTS;\n#endif\n\n            head = circBuf->head;\n\n            \n#ifdef EXTMODE_PROTECT_CRITICAL_REGIONS\n            /* re-enable interrupts */\n            EXTMODE_ENABLE_INTERRUPTS;\n#endif\n\n            /* Validate that head/tail ptrs are within allocated range. */\n            assert((head >= circBuf->buf) && (tail >= circBuf->buf));\n            assert((head < circBuf->buf + circBuf->bufSize) &&\n                   (tail < circBuf->buf + circBuf->bufSize));\n\n            bufMem = &bufList->bufs[bufList->nActiveBufs];\n            bufList->tids[bufList->nActiveBufs] = tid;\n            assert(bufList->nActiveBufs < bufList->maxBufs);\n            bufList->nActiveBufs++;\n\n            bufMem->section1 = tail;\n            circBuf->newTail = head;\n\n            if (head > tail) {\n                /* not wrapped - only one section required */\n                bufMem->nBytes1  = (int_T)(head - tail);\n\n                bufMem->nBytes2  = 0;\n                bufMem->section2 = NULL;\n            } else {\n                /* wrapped - 2 sections required */\n                bufMem->nBytes1 = (int_T)(circBuf->buf + size - tail);\n\n                bufMem->nBytes2  = (int_T)(head - circBuf->buf);\n                bufMem->section2 = circBuf->buf;\n            }\n        }\n    }\n\n    /*\n     * Provide ext_svr with readonly access to the bufMemList.\n     */\n    extBufList->nActiveBufs = bufList->nActiveBufs;\n    extBufList->bufs        = (const BufMem *)bufList->bufs;\n    extBufList->tids        = (const int_T *)bufList->tids;\n} /* end SetExtBufListFields */\n\n\n/* Function ===================================================================\n * Set the internal copy of the buffer list to \"empty\" & fill out the fields\n * of the specified ExtBufMemList (passed in by ext_svr) to provide public,\n * read only access.\n */\nPRIVATE void SetExtBufListFieldsForEmptyList(ExtBufMemList *extBufList,\n                                             int32_T       upInfoIdx)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    BufMemList   *bufList    = &uploadInfo->bufMemList;\n\n    bufList->nActiveBufs = 0;\n\n    extBufList->nActiveBufs = bufList->nActiveBufs;\n    extBufList->bufs        = (const BufMem *)NULL;\n} /* end SetExtBufListFieldsForEmptyList */\n\n\n/* Function ====================================================================\n * Called by ext_svr (background task), this function checks all buffers for\n * data and returns a list of buffer memory to be sent to the host.\n */\nPUBLIC void UploadBufGetData(ExtBufMemList *extBufList,\n                             int32_T       upInfoIdx,\n                             int_T         numSampTimes)\n{\n    BdUploadInfo *uploadInfo = &uploadInfoArray[upInfoIdx];\n    TriggerInfo  *trigInfo   = &uploadInfo->trigInfo;\n    TriggerState trigState = trigInfo->state;\n \n    if ((trigState == TRIGGER_FIRED) ||\n        (trigState == TRIGGER_TERMINATING)) {\n\n        /* Make sure we start with an empty list */\n        SetExtBufListFieldsForEmptyList(extBufList, upInfoIdx);\n        SetExtBufListFields(extBufList, upInfoIdx, numSampTimes);\n\n        /*\n         * If all bufs are empty and we are terminating then we're now done!\n         */\n        if ((extBufList->nActiveBufs == 0) &&\n            (trigState == TRIGGER_TERMINATING)) {\n\n            host_upstatus_is_uploading = false;\n\n            if (trigInfo->holdOff == TRIGMODE_ONESHOT) {\n                SendPktToHost(EXT_TERMINATE_LOG_SESSION, sizeof(int32_T),\n                              (char *)&upInfoIdx);\n                UploadEndLoggingSession(upInfoIdx, numSampTimes);\n            } else {\n                SendPktToHost(EXT_TERMINATE_LOG_EVENT, sizeof(int32_T),\n                              (char *)&upInfoIdx);\n                trigInfo->count = 0;\n                trigInfo->state = TRIGGER_HOLDING_OFF;\n            }\n        }\n    } else {\n        SetExtBufListFieldsForEmptyList(extBufList, upInfoIdx);\n    }\n} /* end UploadBufGetData */\n#endif /* ifndef EXTMODE_DISABLESIGNALMONITORING */\n\n\n/* [EOF] updown.c */\n\n/* LocalWords:  DType pbuf NPARAMS dtype tran Els EXTMODE HDR abc\n * LocalWords:  DISABLEPARAMETERTUNING bufs buf blockio tids sys's nbuf sigs\n * LocalWords:  tid's DISABLESIGNALMONITORING uploadinfo NULL'ed vals oneshot\n * LocalWords:  sem svr TRIGMODE ONESTEP CIRCBUF tmp\n */\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};